/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(globalThis["webpackChunksuperset"] = globalThis["webpackChunksuperset"] || []).push([["plugins_legacy-plugin-chart-parallel-coordinates_src_ReactParallelCoordinates_jsx"],{

/***/ "./plugins/legacy-plugin-chart-parallel-coordinates/src/ParallelCoordinates.js":
/*!*************************************************************************************!*\
  !*** ./plugins/legacy-plugin-chart-parallel-coordinates/src/ParallelCoordinates.js ***!
  \*************************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var d3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3 */ \"./node_modules/d3/d3.js\");\n/* harmony import */ var d3__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(d3__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! prop-types */ \"./node_modules/prop-types/index.js\");\n/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _superset_ui_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @superset-ui/core */ \"./packages/superset-ui-core/src/color/SequentialSchemeRegistrySingleton.ts\");\n/* harmony import */ var _vendor_parcoords_d3_parcoords__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./vendor/parcoords/d3.parcoords */ \"./plugins/legacy-plugin-chart-parallel-coordinates/src/vendor/parcoords/d3.parcoords.js\");\n/* harmony import */ var _vendor_parcoords_divgrid__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./vendor/parcoords/divgrid */ \"./plugins/legacy-plugin-chart-parallel-coordinates/src/vendor/parcoords/divgrid.js\");\n/* module decorator */ module = __webpack_require__.hmd(module);\n(function () {var enterModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.enterModule : undefined;enterModule && enterModule(module);})();var __signature__ = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default.signature : function (a) {return a;}; /**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n/* eslint-disable react/sort-prop-types */\n\n\n\n\n\n\n\nconst propTypes = {\n  // Standard tabular data [{ fieldName1: value1, fieldName2: value2 }]\n  data: prop_types__WEBPACK_IMPORTED_MODULE_1___default().arrayOf((prop_types__WEBPACK_IMPORTED_MODULE_1___default().object)),\n  width: (prop_types__WEBPACK_IMPORTED_MODULE_1___default().number),\n  height: (prop_types__WEBPACK_IMPORTED_MODULE_1___default().number),\n  colorMetric: (prop_types__WEBPACK_IMPORTED_MODULE_1___default().string),\n  includeSeries: (prop_types__WEBPACK_IMPORTED_MODULE_1___default().bool),\n  linearColorScheme: (prop_types__WEBPACK_IMPORTED_MODULE_1___default().string),\n  metrics: prop_types__WEBPACK_IMPORTED_MODULE_1___default().arrayOf((prop_types__WEBPACK_IMPORTED_MODULE_1___default().string)),\n  series: (prop_types__WEBPACK_IMPORTED_MODULE_1___default().string),\n  showDatatable: (prop_types__WEBPACK_IMPORTED_MODULE_1___default().bool) };\n\n\nfunction ParallelCoordinates(element, props) {\n  const {\n    data,\n    width,\n    height,\n    colorMetric,\n    includeSeries,\n    linearColorScheme,\n    metrics,\n    series,\n    showDatatable } =\n  props;\n\n  const cols = includeSeries ? [series].concat(metrics) : metrics;\n\n  const ttypes = {};\n  ttypes[series] = 'string';\n  metrics.forEach((v) => {\n    ttypes[v] = 'number';\n  });\n\n  const colorScale = colorMetric ?\n  (0,_superset_ui_core__WEBPACK_IMPORTED_MODULE_2__[\"default\"])().\n  get(linearColorScheme).\n  createLinearScale(d3__WEBPACK_IMPORTED_MODULE_0___default().extent(data, (d) => d[colorMetric])) :\n  () => 'grey';\n  const color = (d) => colorScale(d[colorMetric]);\n  const container = d3__WEBPACK_IMPORTED_MODULE_0___default().select(element).\n  classed('superset-legacy-chart-parallel-coordinates', true);\n  container.selectAll('*').remove();\n  const effHeight = showDatatable ? height / 2 : height;\n\n  const div = container.\n  append('div').\n  style('height', `${effHeight}px`).\n  classed('parcoords', true);\n\n  const chart = (0,_vendor_parcoords_d3_parcoords__WEBPACK_IMPORTED_MODULE_3__[\"default\"])()(div.node()).\n  width(width).\n  color(color).\n  alpha(0.5).\n  composite('darken').\n  height(effHeight).\n  data(data).\n  dimensions(cols).\n  types(ttypes).\n  render().\n  createAxes().\n  shadows().\n  reorderable().\n  brushMode('1D-axes');\n\n  if (showDatatable) {\n    // create data table, row hover highlighting\n    const grid = (0,_vendor_parcoords_divgrid__WEBPACK_IMPORTED_MODULE_4__[\"default\"])();\n    container.\n    append('div').\n    style('height', `${effHeight}px`).\n    datum(data).\n    call(grid).\n    classed('parcoords grid', true).\n    selectAll('.row').\n    on({\n      mouseover(d) {\n        chart.highlight([d]);\n      },\n      mouseout: chart.unhighlight });\n\n    // update data table on brush event\n    chart.on('brush', (d) => {\n      d3__WEBPACK_IMPORTED_MODULE_0___default().select('.grid').\n      datum(d).\n      call(grid).\n      selectAll('.row').\n      on({\n        mouseover(dd) {\n          chart.highlight([dd]);\n        },\n        mouseout: chart.unhighlight });\n\n    });\n  }\n}\n\nParallelCoordinates.displayName = 'ParallelCoordinates';\nParallelCoordinates.propTypes = propTypes;const _default =\n\nParallelCoordinates;/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_default);;(function () {var reactHotLoader = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default : undefined;if (!reactHotLoader) {return;}reactHotLoader.register(propTypes, \"propTypes\", \"/app/superset-frontend/plugins/legacy-plugin-chart-parallel-coordinates/src/ParallelCoordinates.js\");reactHotLoader.register(ParallelCoordinates, \"ParallelCoordinates\", \"/app/superset-frontend/plugins/legacy-plugin-chart-parallel-coordinates/src/ParallelCoordinates.js\");reactHotLoader.register(_default, \"default\", \"/app/superset-frontend/plugins/legacy-plugin-chart-parallel-coordinates/src/ParallelCoordinates.js\");})();;(function () {var leaveModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.leaveModule : undefined;leaveModule && leaveModule(module);})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9wbHVnaW5zL2xlZ2FjeS1wbHVnaW4tY2hhcnQtcGFyYWxsZWwtY29vcmRpbmF0ZXMvc3JjL1BhcmFsbGVsQ29vcmRpbmF0ZXMuanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zdXBlcnNldC8uL3BsdWdpbnMvbGVnYWN5LXBsdWdpbi1jaGFydC1wYXJhbGxlbC1jb29yZGluYXRlcy9zcmMvUGFyYWxsZWxDb29yZGluYXRlcy5qcz9mYTA5Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuICogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4gKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuICogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuICogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuICogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4gKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4gKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuICogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiAqIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuICogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuICogdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIHJlYWN0L3NvcnQtcHJvcC10eXBlcyAqL1xuaW1wb3J0IGQzIGZyb20gJ2QzJztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgeyBnZXRTZXF1ZW50aWFsU2NoZW1lUmVnaXN0cnkgfSBmcm9tICdAc3VwZXJzZXQtdWkvY29yZSc7XG5cbmltcG9ydCBwYXJjb29yZHMgZnJvbSAnLi92ZW5kb3IvcGFyY29vcmRzL2QzLnBhcmNvb3Jkcyc7XG5pbXBvcnQgZGl2Z3JpZCBmcm9tICcuL3ZlbmRvci9wYXJjb29yZHMvZGl2Z3JpZCc7XG5cbmNvbnN0IHByb3BUeXBlcyA9IHtcbiAgLy8gU3RhbmRhcmQgdGFidWxhciBkYXRhIFt7IGZpZWxkTmFtZTE6IHZhbHVlMSwgZmllbGROYW1lMjogdmFsdWUyIH1dXG4gIGRhdGE6IFByb3BUeXBlcy5hcnJheU9mKFByb3BUeXBlcy5vYmplY3QpLFxuICB3aWR0aDogUHJvcFR5cGVzLm51bWJlcixcbiAgaGVpZ2h0OiBQcm9wVHlwZXMubnVtYmVyLFxuICBjb2xvck1ldHJpYzogUHJvcFR5cGVzLnN0cmluZyxcbiAgaW5jbHVkZVNlcmllczogUHJvcFR5cGVzLmJvb2wsXG4gIGxpbmVhckNvbG9yU2NoZW1lOiBQcm9wVHlwZXMuc3RyaW5nLFxuICBtZXRyaWNzOiBQcm9wVHlwZXMuYXJyYXlPZihQcm9wVHlwZXMuc3RyaW5nKSxcbiAgc2VyaWVzOiBQcm9wVHlwZXMuc3RyaW5nLFxuICBzaG93RGF0YXRhYmxlOiBQcm9wVHlwZXMuYm9vbCxcbn07XG5cbmZ1bmN0aW9uIFBhcmFsbGVsQ29vcmRpbmF0ZXMoZWxlbWVudCwgcHJvcHMpIHtcbiAgY29uc3Qge1xuICAgIGRhdGEsXG4gICAgd2lkdGgsXG4gICAgaGVpZ2h0LFxuICAgIGNvbG9yTWV0cmljLFxuICAgIGluY2x1ZGVTZXJpZXMsXG4gICAgbGluZWFyQ29sb3JTY2hlbWUsXG4gICAgbWV0cmljcyxcbiAgICBzZXJpZXMsXG4gICAgc2hvd0RhdGF0YWJsZSxcbiAgfSA9IHByb3BzO1xuXG4gIGNvbnN0IGNvbHMgPSBpbmNsdWRlU2VyaWVzID8gW3Nlcmllc10uY29uY2F0KG1ldHJpY3MpIDogbWV0cmljcztcblxuICBjb25zdCB0dHlwZXMgPSB7fTtcbiAgdHR5cGVzW3Nlcmllc10gPSAnc3RyaW5nJztcbiAgbWV0cmljcy5mb3JFYWNoKHYgPT4ge1xuICAgIHR0eXBlc1t2XSA9ICdudW1iZXInO1xuICB9KTtcblxuICBjb25zdCBjb2xvclNjYWxlID0gY29sb3JNZXRyaWNcbiAgICA/IGdldFNlcXVlbnRpYWxTY2hlbWVSZWdpc3RyeSgpXG4gICAgICAgIC5nZXQobGluZWFyQ29sb3JTY2hlbWUpXG4gICAgICAgIC5jcmVhdGVMaW5lYXJTY2FsZShkMy5leHRlbnQoZGF0YSwgZCA9PiBkW2NvbG9yTWV0cmljXSkpXG4gICAgOiAoKSA9PiAnZ3JleSc7XG4gIGNvbnN0IGNvbG9yID0gZCA9PiBjb2xvclNjYWxlKGRbY29sb3JNZXRyaWNdKTtcbiAgY29uc3QgY29udGFpbmVyID0gZDNcbiAgICAuc2VsZWN0KGVsZW1lbnQpXG4gICAgLmNsYXNzZWQoJ3N1cGVyc2V0LWxlZ2FjeS1jaGFydC1wYXJhbGxlbC1jb29yZGluYXRlcycsIHRydWUpO1xuICBjb250YWluZXIuc2VsZWN0QWxsKCcqJykucmVtb3ZlKCk7XG4gIGNvbnN0IGVmZkhlaWdodCA9IHNob3dEYXRhdGFibGUgPyBoZWlnaHQgLyAyIDogaGVpZ2h0O1xuXG4gIGNvbnN0IGRpdiA9IGNvbnRhaW5lclxuICAgIC5hcHBlbmQoJ2RpdicpXG4gICAgLnN0eWxlKCdoZWlnaHQnLCBgJHtlZmZIZWlnaHR9cHhgKVxuICAgIC5jbGFzc2VkKCdwYXJjb29yZHMnLCB0cnVlKTtcblxuICBjb25zdCBjaGFydCA9IHBhcmNvb3JkcygpKGRpdi5ub2RlKCkpXG4gICAgLndpZHRoKHdpZHRoKVxuICAgIC5jb2xvcihjb2xvcilcbiAgICAuYWxwaGEoMC41KVxuICAgIC5jb21wb3NpdGUoJ2RhcmtlbicpXG4gICAgLmhlaWdodChlZmZIZWlnaHQpXG4gICAgLmRhdGEoZGF0YSlcbiAgICAuZGltZW5zaW9ucyhjb2xzKVxuICAgIC50eXBlcyh0dHlwZXMpXG4gICAgLnJlbmRlcigpXG4gICAgLmNyZWF0ZUF4ZXMoKVxuICAgIC5zaGFkb3dzKClcbiAgICAucmVvcmRlcmFibGUoKVxuICAgIC5icnVzaE1vZGUoJzFELWF4ZXMnKTtcblxuICBpZiAoc2hvd0RhdGF0YWJsZSkge1xuICAgIC8vIGNyZWF0ZSBkYXRhIHRhYmxlLCByb3cgaG92ZXIgaGlnaGxpZ2h0aW5nXG4gICAgY29uc3QgZ3JpZCA9IGRpdmdyaWQoKTtcbiAgICBjb250YWluZXJcbiAgICAgIC5hcHBlbmQoJ2RpdicpXG4gICAgICAuc3R5bGUoJ2hlaWdodCcsIGAke2VmZkhlaWdodH1weGApXG4gICAgICAuZGF0dW0oZGF0YSlcbiAgICAgIC5jYWxsKGdyaWQpXG4gICAgICAuY2xhc3NlZCgncGFyY29vcmRzIGdyaWQnLCB0cnVlKVxuICAgICAgLnNlbGVjdEFsbCgnLnJvdycpXG4gICAgICAub24oe1xuICAgICAgICBtb3VzZW92ZXIoZCkge1xuICAgICAgICAgIGNoYXJ0LmhpZ2hsaWdodChbZF0pO1xuICAgICAgICB9LFxuICAgICAgICBtb3VzZW91dDogY2hhcnQudW5oaWdobGlnaHQsXG4gICAgICB9KTtcbiAgICAvLyB1cGRhdGUgZGF0YSB0YWJsZSBvbiBicnVzaCBldmVudFxuICAgIGNoYXJ0Lm9uKCdicnVzaCcsIGQgPT4ge1xuICAgICAgZDMuc2VsZWN0KCcuZ3JpZCcpXG4gICAgICAgIC5kYXR1bShkKVxuICAgICAgICAuY2FsbChncmlkKVxuICAgICAgICAuc2VsZWN0QWxsKCcucm93JylcbiAgICAgICAgLm9uKHtcbiAgICAgICAgICBtb3VzZW92ZXIoZGQpIHtcbiAgICAgICAgICAgIGNoYXJ0LmhpZ2hsaWdodChbZGRdKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIG1vdXNlb3V0OiBjaGFydC51bmhpZ2hsaWdodCxcbiAgICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbn1cblxuUGFyYWxsZWxDb29yZGluYXRlcy5kaXNwbGF5TmFtZSA9ICdQYXJhbGxlbENvb3JkaW5hdGVzJztcblBhcmFsbGVsQ29vcmRpbmF0ZXMucHJvcFR5cGVzID0gcHJvcFR5cGVzO1xuXG5leHBvcnQgZGVmYXVsdCBQYXJhbGxlbENvb3JkaW5hdGVzO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./plugins/legacy-plugin-chart-parallel-coordinates/src/ParallelCoordinates.js\n");

/***/ }),

/***/ "./plugins/legacy-plugin-chart-parallel-coordinates/src/ReactParallelCoordinates.jsx":
/*!*******************************************************************************************!*\
  !*** ./plugins/legacy-plugin-chart-parallel-coordinates/src/ReactParallelCoordinates.jsx ***!
  \*******************************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var _superset_ui_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @superset-ui/core */ \"./packages/superset-ui-core/src/chart/components/reactify.tsx\");\n/* harmony import */ var _superset_ui_core__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @superset-ui/core */ \"./packages/superset-ui-core/src/style/index.tsx\");\n/* harmony import */ var _superset_ui_core__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @superset-ui/core */ \"./packages/superset-ui-core/src/color/utils.ts\");\n/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! prop-types */ \"./node_modules/prop-types/index.js\");\n/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var _ParallelCoordinates__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ParallelCoordinates */ \"./plugins/legacy-plugin-chart-parallel-coordinates/src/ParallelCoordinates.js\");\n/* harmony import */ var _emotion_react__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @emotion/react */ \"./node_modules/@emotion/react/dist/emotion-react.browser.esm.js\");\n/* module decorator */ module = __webpack_require__.hmd(module);\n(function () {var enterModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.enterModule : undefined;enterModule && enterModule(module);})();var __signature__ = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default.signature : function (a) {return a;}; /**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\n\n\n\n\nconst ReactComponent = (0,_superset_ui_core__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(_ParallelCoordinates__WEBPACK_IMPORTED_MODULE_2__[\"default\"]);\n\nconst ParallelCoordinates = (_ref) => {let { className, ...otherProps } = _ref;return (\n    (0,_emotion_react__WEBPACK_IMPORTED_MODULE_3__.jsx)(\"div\", { className: className },\n    (0,_emotion_react__WEBPACK_IMPORTED_MODULE_3__.jsx)(ReactComponent, otherProps)));};\n\n\n\nParallelCoordinates.propTypes = {\n  className: (prop_types__WEBPACK_IMPORTED_MODULE_4___default().string.isRequired) };const _default =\n\n\n(0,_superset_ui_core__WEBPACK_IMPORTED_MODULE_5__.styled)(ParallelCoordinates)`\n  ${(_ref2) => {let { theme } = _ref2;return `\n    .superset-legacy-chart-parallel-coordinates {\n      div.grid {\n        overflow: auto;\n        div.row {\n          &:hover {\n            background-color: ${theme.colors.grayscale.light2};\n          }\n        }\n      }\n    }\n    .parcoords svg,\n    .parcoords canvas {\n      font-size: ${theme.typography.sizes.s}px;\n      position: absolute;\n    }\n    .parcoords > canvas {\n      pointer-events: none;\n    }\n\n    .parcoords text.label {\n      font: 100%;\n      font-size: ${theme.typography.sizes.s}px;\n      cursor: drag;\n    }\n    .parcoords rect.background {\n      fill: transparent;\n    }\n    .parcoords rect.background:hover {\n      fill: ${(0,_superset_ui_core__WEBPACK_IMPORTED_MODULE_6__.addAlpha)(theme.colors.grayscale.base, 0.2)};\n    }\n    .parcoords .resize rect {\n      fill: ${(0,_superset_ui_core__WEBPACK_IMPORTED_MODULE_6__.addAlpha)(theme.colors.grayscale.dark2, 0.1)};\n    }\n    .parcoords rect.extent {\n      fill: ${(0,_superset_ui_core__WEBPACK_IMPORTED_MODULE_6__.addAlpha)(theme.colors.grayscale.light5, 0.25)};\n      stroke: ${(0,_superset_ui_core__WEBPACK_IMPORTED_MODULE_6__.addAlpha)(theme.colors.grayscale.dark2, 0.6)};\n    }\n    .parcoords .axis line,\n    .parcoords .axis path {\n      fill: none;\n      stroke: ${theme.colors.grayscale.dark1};\n      shape-rendering: crispEdges;\n    }\n    .parcoords canvas {\n      opacity: 1;\n      -moz-transition: opacity 0.3s;\n      -webkit-transition: opacity 0.3s;\n      -o-transition: opacity 0.3s;\n    }\n    .parcoords canvas.faded {\n      opacity: ${theme.opacity.mediumLight};\n    }\n    .parcoords {\n      -webkit-touch-callout: none;\n      -webkit-user-select: none;\n      -khtml-user-select: none;\n      -moz-user-select: none;\n      -ms-user-select: none;\n      user-select: none;\n      background-color: ${theme.colors.grayscale.light5};\n    }\n\n    /* data table styles */\n    .parcoords .row,\n    .parcoords .header {\n      clear: left;\n      font-size: ${theme.typography.sizes.s}px;\n      line-height: 18px;\n      height: 18px;\n      margin: 0px;\n    }\n    .parcoords .row:nth-child(odd) {\n      background: ${(0,_superset_ui_core__WEBPACK_IMPORTED_MODULE_6__.addAlpha)(theme.colors.grayscale.dark2, 0.05)};\n    }\n    .parcoords .header {\n      font-weight: ${theme.typography.weights.bold};\n    }\n    .parcoords .cell {\n      float: left;\n      overflow: hidden;\n      white-space: nowrap;\n      width: 100px;\n      height: 18px;\n    }\n    .parcoords .col-0 {\n      width: 180px;\n    }\n  `;}}\n`;/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_default);;(function () {var reactHotLoader = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default : undefined;if (!reactHotLoader) {return;}reactHotLoader.register(ReactComponent, \"ReactComponent\", \"/app/superset-frontend/plugins/legacy-plugin-chart-parallel-coordinates/src/ReactParallelCoordinates.jsx\");reactHotLoader.register(ParallelCoordinates, \"ParallelCoordinates\", \"/app/superset-frontend/plugins/legacy-plugin-chart-parallel-coordinates/src/ReactParallelCoordinates.jsx\");reactHotLoader.register(_default, \"default\", \"/app/superset-frontend/plugins/legacy-plugin-chart-parallel-coordinates/src/ReactParallelCoordinates.jsx\");})();;(function () {var leaveModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.leaveModule : undefined;leaveModule && leaveModule(module);})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9wbHVnaW5zL2xlZ2FjeS1wbHVnaW4tY2hhcnQtcGFyYWxsZWwtY29vcmRpbmF0ZXMvc3JjL1JlYWN0UGFyYWxsZWxDb29yZGluYXRlcy5qc3guanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc3VwZXJzZXQvLi9wbHVnaW5zL2xlZ2FjeS1wbHVnaW4tY2hhcnQtcGFyYWxsZWwtY29vcmRpbmF0ZXMvc3JjL1JlYWN0UGFyYWxsZWxDb29yZGluYXRlcy5qc3g/MjY2MSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiAqIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuICogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiAqIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiAqIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiAqIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuICogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuICogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiAqIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4gKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiAqIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiAqIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgc3R5bGVkLCByZWFjdGlmeSwgYWRkQWxwaGEgfSBmcm9tICdAc3VwZXJzZXQtdWkvY29yZSc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IENvbXBvbmVudCBmcm9tICcuL1BhcmFsbGVsQ29vcmRpbmF0ZXMnO1xuXG5jb25zdCBSZWFjdENvbXBvbmVudCA9IHJlYWN0aWZ5KENvbXBvbmVudCk7XG5cbmNvbnN0IFBhcmFsbGVsQ29vcmRpbmF0ZXMgPSAoeyBjbGFzc05hbWUsIC4uLm90aGVyUHJvcHMgfSkgPT4gKFxuICA8ZGl2IGNsYXNzTmFtZT17Y2xhc3NOYW1lfT5cbiAgICA8UmVhY3RDb21wb25lbnQgey4uLm90aGVyUHJvcHN9IC8+XG4gIDwvZGl2PlxuKTtcblxuUGFyYWxsZWxDb29yZGluYXRlcy5wcm9wVHlwZXMgPSB7XG4gIGNsYXNzTmFtZTogUHJvcFR5cGVzLnN0cmluZy5pc1JlcXVpcmVkLFxufTtcblxuZXhwb3J0IGRlZmF1bHQgc3R5bGVkKFBhcmFsbGVsQ29vcmRpbmF0ZXMpYFxuICAkeyh7IHRoZW1lIH0pID0+IGBcbiAgICAuc3VwZXJzZXQtbGVnYWN5LWNoYXJ0LXBhcmFsbGVsLWNvb3JkaW5hdGVzIHtcbiAgICAgIGRpdi5ncmlkIHtcbiAgICAgICAgb3ZlcmZsb3c6IGF1dG87XG4gICAgICAgIGRpdi5yb3cge1xuICAgICAgICAgICY6aG92ZXIge1xuICAgICAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogJHt0aGVtZS5jb2xvcnMuZ3JheXNjYWxlLmxpZ2h0Mn07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC5wYXJjb29yZHMgc3ZnLFxuICAgIC5wYXJjb29yZHMgY2FudmFzIHtcbiAgICAgIGZvbnQtc2l6ZTogJHt0aGVtZS50eXBvZ3JhcGh5LnNpemVzLnN9cHg7XG4gICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgfVxuICAgIC5wYXJjb29yZHMgPiBjYW52YXMge1xuICAgICAgcG9pbnRlci1ldmVudHM6IG5vbmU7XG4gICAgfVxuXG4gICAgLnBhcmNvb3JkcyB0ZXh0LmxhYmVsIHtcbiAgICAgIGZvbnQ6IDEwMCU7XG4gICAgICBmb250LXNpemU6ICR7dGhlbWUudHlwb2dyYXBoeS5zaXplcy5zfXB4O1xuICAgICAgY3Vyc29yOiBkcmFnO1xuICAgIH1cbiAgICAucGFyY29vcmRzIHJlY3QuYmFja2dyb3VuZCB7XG4gICAgICBmaWxsOiB0cmFuc3BhcmVudDtcbiAgICB9XG4gICAgLnBhcmNvb3JkcyByZWN0LmJhY2tncm91bmQ6aG92ZXIge1xuICAgICAgZmlsbDogJHthZGRBbHBoYSh0aGVtZS5jb2xvcnMuZ3JheXNjYWxlLmJhc2UsIDAuMil9O1xuICAgIH1cbiAgICAucGFyY29vcmRzIC5yZXNpemUgcmVjdCB7XG4gICAgICBmaWxsOiAke2FkZEFscGhhKHRoZW1lLmNvbG9ycy5ncmF5c2NhbGUuZGFyazIsIDAuMSl9O1xuICAgIH1cbiAgICAucGFyY29vcmRzIHJlY3QuZXh0ZW50IHtcbiAgICAgIGZpbGw6ICR7YWRkQWxwaGEodGhlbWUuY29sb3JzLmdyYXlzY2FsZS5saWdodDUsIDAuMjUpfTtcbiAgICAgIHN0cm9rZTogJHthZGRBbHBoYSh0aGVtZS5jb2xvcnMuZ3JheXNjYWxlLmRhcmsyLCAwLjYpfTtcbiAgICB9XG4gICAgLnBhcmNvb3JkcyAuYXhpcyBsaW5lLFxuICAgIC5wYXJjb29yZHMgLmF4aXMgcGF0aCB7XG4gICAgICBmaWxsOiBub25lO1xuICAgICAgc3Ryb2tlOiAke3RoZW1lLmNvbG9ycy5ncmF5c2NhbGUuZGFyazF9O1xuICAgICAgc2hhcGUtcmVuZGVyaW5nOiBjcmlzcEVkZ2VzO1xuICAgIH1cbiAgICAucGFyY29vcmRzIGNhbnZhcyB7XG4gICAgICBvcGFjaXR5OiAxO1xuICAgICAgLW1vei10cmFuc2l0aW9uOiBvcGFjaXR5IDAuM3M7XG4gICAgICAtd2Via2l0LXRyYW5zaXRpb246IG9wYWNpdHkgMC4zcztcbiAgICAgIC1vLXRyYW5zaXRpb246IG9wYWNpdHkgMC4zcztcbiAgICB9XG4gICAgLnBhcmNvb3JkcyBjYW52YXMuZmFkZWQge1xuICAgICAgb3BhY2l0eTogJHt0aGVtZS5vcGFjaXR5Lm1lZGl1bUxpZ2h0fTtcbiAgICB9XG4gICAgLnBhcmNvb3JkcyB7XG4gICAgICAtd2Via2l0LXRvdWNoLWNhbGxvdXQ6IG5vbmU7XG4gICAgICAtd2Via2l0LXVzZXItc2VsZWN0OiBub25lO1xuICAgICAgLWtodG1sLXVzZXItc2VsZWN0OiBub25lO1xuICAgICAgLW1vei11c2VyLXNlbGVjdDogbm9uZTtcbiAgICAgIC1tcy11c2VyLXNlbGVjdDogbm9uZTtcbiAgICAgIHVzZXItc2VsZWN0OiBub25lO1xuICAgICAgYmFja2dyb3VuZC1jb2xvcjogJHt0aGVtZS5jb2xvcnMuZ3JheXNjYWxlLmxpZ2h0NX07XG4gICAgfVxuXG4gICAgLyogZGF0YSB0YWJsZSBzdHlsZXMgKi9cbiAgICAucGFyY29vcmRzIC5yb3csXG4gICAgLnBhcmNvb3JkcyAuaGVhZGVyIHtcbiAgICAgIGNsZWFyOiBsZWZ0O1xuICAgICAgZm9udC1zaXplOiAke3RoZW1lLnR5cG9ncmFwaHkuc2l6ZXMuc31weDtcbiAgICAgIGxpbmUtaGVpZ2h0OiAxOHB4O1xuICAgICAgaGVpZ2h0OiAxOHB4O1xuICAgICAgbWFyZ2luOiAwcHg7XG4gICAgfVxuICAgIC5wYXJjb29yZHMgLnJvdzpudGgtY2hpbGQob2RkKSB7XG4gICAgICBiYWNrZ3JvdW5kOiAke2FkZEFscGhhKHRoZW1lLmNvbG9ycy5ncmF5c2NhbGUuZGFyazIsIDAuMDUpfTtcbiAgICB9XG4gICAgLnBhcmNvb3JkcyAuaGVhZGVyIHtcbiAgICAgIGZvbnQtd2VpZ2h0OiAke3RoZW1lLnR5cG9ncmFwaHkud2VpZ2h0cy5ib2xkfTtcbiAgICB9XG4gICAgLnBhcmNvb3JkcyAuY2VsbCB7XG4gICAgICBmbG9hdDogbGVmdDtcbiAgICAgIG92ZXJmbG93OiBoaWRkZW47XG4gICAgICB3aGl0ZS1zcGFjZTogbm93cmFwO1xuICAgICAgd2lkdGg6IDEwMHB4O1xuICAgICAgaGVpZ2h0OiAxOHB4O1xuICAgIH1cbiAgICAucGFyY29vcmRzIC5jb2wtMCB7XG4gICAgICB3aWR0aDogMTgwcHg7XG4gICAgfVxuICBgfVxuYDtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./plugins/legacy-plugin-chart-parallel-coordinates/src/ReactParallelCoordinates.jsx\n");

/***/ }),

/***/ "./plugins/legacy-plugin-chart-parallel-coordinates/src/vendor/parcoords/d3.parcoords.js":
/*!***********************************************************************************************!*\
  !*** ./plugins/legacy-plugin-chart-parallel-coordinates/src/vendor/parcoords/d3.parcoords.js ***!
  \***********************************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var core_js_modules_es_regexp_flags_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! core-js/modules/es.regexp.flags.js */ \"./node_modules/core-js/modules/es.regexp.flags.js\");\n/* harmony import */ var core_js_modules_es_regexp_flags_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_regexp_flags_js__WEBPACK_IMPORTED_MODULE_0__);\n/* module decorator */ module = __webpack_require__.hmd(module);\n(function () {var enterModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.enterModule : undefined;enterModule && enterModule(module);})();var __signature__ = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default.signature : function (a) {return a;};const _default =\n\nfunction (config) {\n  var __ = {\n    data: [],\n    highlighted: [],\n    dimensions: [],\n    dimensionTitles: {},\n    dimensionTitleRotation: 0,\n    types: {},\n    brushed: false,\n    brushedColor: null,\n    alphaOnBrushed: 0.0,\n    mode: 'default',\n    rate: 20,\n    width: 600,\n    height: 300,\n    margin: { top: 24, right: 0, bottom: 12, left: 0 },\n    nullValueSeparator: 'undefined', // set to \"top\" or \"bottom\"\n    nullValueSeparatorPadding: { top: 8, right: 0, bottom: 8, left: 0 },\n    color: '#069',\n    composite: 'source-over',\n    alpha: 0.7,\n    bundlingStrength: 0.5,\n    bundleDimension: null,\n    smoothness: 0.0,\n    showControlPoints: false,\n    hideAxis: [] };\n\n\n  extend(__, config);\n\n  var pc = function (selection) {\n    selection = pc.selection = d3.select(selection);\n\n    __.width = selection[0][0].clientWidth;\n    __.height = selection[0][0].clientHeight;\n\n    // canvas data layers\n    ['marks', 'foreground', 'brushed', 'highlight'].forEach(function (layer) {\n      canvas[layer] = selection.append('canvas').attr('class', layer)[0][0];\n      ctx[layer] = canvas[layer].getContext('2d');\n    });\n\n    // svg tick and brush layers\n    pc.svg = selection.\n    append('svg').\n    attr('width', __.width).\n    attr('height', __.height).\n    append('svg:g').\n    attr(\n    'transform',\n    'translate(' + __.margin.left + ',' + __.margin.top + ')');\n\n\n    return pc;\n  };\n  var events = d3.dispatch.apply(\n  this,\n  [\n  'render',\n  'resize',\n  'highlight',\n  'brush',\n  'brushend',\n  'axesreorder'].\n  concat(d3.keys(__))),\n\n  w = function () {\n    return __.width - __.margin.right - __.margin.left;\n  },\n  h = function () {\n    return __.height - __.margin.top - __.margin.bottom;\n  },\n  flags = {\n    brushable: false,\n    reorderable: false,\n    axes: false,\n    interactive: false,\n    debug: false },\n\n  xscale = d3.scale.ordinal(),\n  yscale = {},\n  dragging = {},\n  line = d3.svg.line(),\n  axis = d3.svg.axis().orient('left').ticks(5),\n  g, // groups for axes, brushes\n  ctx = {},\n  canvas = {},\n  clusterCentroids = [];\n\n  // side effects for setters\n  var side_effects = d3.dispatch.\n  apply(this, d3.keys(__)).\n  on('composite', function (d) {\n    ctx.foreground.globalCompositeOperation = d.value;\n    ctx.brushed.globalCompositeOperation = d.value;\n  }).\n  on('alpha', function (d) {\n    ctx.foreground.globalAlpha = d.value;\n    ctx.brushed.globalAlpha = d.value;\n  }).\n  on('brushedColor', function (d) {\n    ctx.brushed.strokeStyle = d.value;\n  }).\n  on('width', function (d) {\n    pc.resize();\n  }).\n  on('height', function (d) {\n    pc.resize();\n  }).\n  on('margin', function (d) {\n    pc.resize();\n  }).\n  on('rate', function (d) {\n    brushedQueue.rate(d.value);\n    foregroundQueue.rate(d.value);\n  }).\n  on('dimensions', function (d) {\n    xscale.domain(__.dimensions);\n    if (flags.interactive) {\n      pc.render().updateAxes();\n    }\n  }).\n  on('bundleDimension', function (d) {\n    if (!__.dimensions.length) pc.detectDimensions();\n    if (!(__.dimensions[0] in yscale)) pc.autoscale();\n    if (typeof d.value === 'number') {\n      if (d.value < __.dimensions.length) {\n        __.bundleDimension = __.dimensions[d.value];\n      } else if (d.value < __.hideAxis.length) {\n        __.bundleDimension = __.hideAxis[d.value];\n      }\n    } else {\n      __.bundleDimension = d.value;\n    }\n\n    __.clusterCentroids = compute_cluster_centroids(__.bundleDimension);\n  }).\n  on('hideAxis', function (d) {\n    if (!__.dimensions.length) pc.detectDimensions();\n    pc.dimensions(without(__.dimensions, d.value));\n  });\n\n  // expose the state of the chart\n  pc.state = __;\n  pc.flags = flags;\n\n  // create getter/setters\n  getset(pc, __, events);\n\n  // expose events\n  d3.rebind(pc, events, 'on');\n\n  // getter/setter with event firing\n  function getset(obj, state, events) {\n    d3.keys(state).forEach(function (key) {\n      obj[key] = function (x) {\n        if (!arguments.length) {\n          return state[key];\n        }\n        var old = state[key];\n        state[key] = x;\n        side_effects[key].call(pc, { value: x, previous: old });\n        events[key].call(pc, { value: x, previous: old });\n        return obj;\n      };\n    });\n  }\n\n  function extend(target, source) {\n    for (var key in source) {\n      target[key] = source[key];\n    }\n    return target;\n  }\n\n  function without(arr, item) {\n    return arr.filter(function (elem) {\n      return item.indexOf(elem) === -1;\n    });\n  }\n  /** adjusts an axis' default range [h()+1, 1] if a NullValueSeparator is set */\n  function getRange() {\n    if (__.nullValueSeparator == 'bottom') {\n      return [\n      h() +\n      1 -\n      __.nullValueSeparatorPadding.bottom -\n      __.nullValueSeparatorPadding.top,\n      1];\n\n    } else if (__.nullValueSeparator == 'top') {\n      return [\n      h() + 1,\n      1 +\n      __.nullValueSeparatorPadding.bottom +\n      __.nullValueSeparatorPadding.top];\n\n    }\n    return [h() + 1, 1];\n  }\n\n  pc.autoscale = function () {\n    // yscale\n    var defaultScales = {\n      date: function (k) {\n        var extent = d3.extent(__.data, function (d) {\n          return d[k] ? d[k].getTime() : null;\n        });\n\n        // special case if single value\n        if (extent[0] === extent[1]) {\n          return d3.scale.ordinal().domain([extent[0]]).rangePoints(getRange());\n        }\n\n        return d3.time.scale().domain(extent).range(getRange());\n      },\n      number: function (k) {\n        var extent = d3.extent(__.data, function (d) {\n          return +d[k];\n        });\n\n        // special case if single value\n        if (extent[0] === extent[1]) {\n          return d3.scale.ordinal().domain([extent[0]]).rangePoints(getRange());\n        }\n\n        return d3.scale.linear().domain(extent).range(getRange());\n      },\n      string: function (k) {\n        var counts = {},\n        domain = [];\n\n        // Let's get the count for each value so that we can sort the domain based\n        // on the number of items for each value.\n        __.data.map(function (p) {\n          if (p[k] === undefined && __.nullValueSeparator !== 'undefined') {\n            return; // null values will be drawn beyond the horizontal null value separator!\n          }\n          if (counts[p[k]] === undefined) {\n            counts[p[k]] = 1;\n          } else {\n            counts[p[k]] = counts[p[k]] + 1;\n          }\n        });\n\n        domain = Object.getOwnPropertyNames(counts).sort(function (a, b) {\n          return counts[a] - counts[b];\n        });\n\n        return d3.scale.ordinal().domain(domain).rangePoints(getRange());\n      } };\n\n\n    __.dimensions.forEach(function (k) {\n      yscale[k] = defaultScales[__.types[k]](k);\n    });\n\n    __.hideAxis.forEach(function (k) {\n      yscale[k] = defaultScales[__.types[k]](k);\n    });\n\n    // xscale\n    xscale.rangePoints([0, w()], 1);\n\n    // canvas sizes\n    pc.selection.\n    selectAll('canvas').\n    style('margin-top', __.margin.top + 'px').\n    style('margin-left', __.margin.left + 'px').\n    attr('width', w() + 2).\n    attr('height', h() + 2);\n\n    // default styles, needs to be set when canvas width changes\n    ctx.foreground.strokeStyle = __.color;\n    ctx.foreground.lineWidth = 1.4;\n    ctx.foreground.globalCompositeOperation = __.composite;\n    ctx.foreground.globalAlpha = __.alpha;\n    ctx.brushed.strokeStyle = __.brushedColor;\n    ctx.brushed.lineWidth = 1.4;\n    ctx.brushed.globalCompositeOperation = __.composite;\n    ctx.brushed.globalAlpha = __.alpha;\n    ctx.highlight.lineWidth = 3;\n\n    return this;\n  };\n\n  pc.scale = function (d, domain) {\n    yscale[d].domain(domain);\n\n    return this;\n  };\n\n  pc.flip = function (d) {\n    //yscale[d].domain().reverse();         // does not work\n    yscale[d].domain(yscale[d].domain().reverse()); // works\n\n    return this;\n  };\n\n  pc.commonScale = function (global, type) {\n    var t = type || 'number';\n    if (typeof global === 'undefined') {\n      global = true;\n    }\n\n    // scales of the same type\n    var scales = __.dimensions.concat(__.hideAxis).filter(function (p) {\n      return __.types[p] == t;\n    });\n\n    if (global) {\n      var extent = d3.extent(\n      scales.\n      map(function (p, i) {\n        return yscale[p].domain();\n      }).\n      reduce(function (a, b) {\n        return a.concat(b);\n      }));\n\n\n      scales.forEach(function (d) {\n        yscale[d].domain(extent);\n      });\n    } else {\n      scales.forEach(function (k) {\n        yscale[k].domain(\n        d3.extent(__.data, function (d) {\n          return +d[k];\n        }));\n\n      });\n    }\n\n    // update centroids\n    if (__.bundleDimension !== null) {\n      pc.bundleDimension(__.bundleDimension);\n    }\n\n    return this;\n  };\n  pc.detectDimensions = function () {\n    pc.types(pc.detectDimensionTypes(__.data));\n    pc.dimensions(d3.keys(pc.types()));\n    return this;\n  };\n\n  // a better \"typeof\" from this post: http://stackoverflow.com/questions/7390426/better-way-to-get-type-of-a-javascript-variable\n  pc.toType = function (v) {\n    return {}.toString.\n    call(v).\n    match(/\\s([a-zA-Z]+)/)[1].\n    toLowerCase();\n  };\n\n  // try to coerce to number before returning type\n  pc.toTypeCoerceNumbers = function (v) {\n    if (parseFloat(v) == v && v != null) {\n      return 'number';\n    }\n    return pc.toType(v);\n  };\n\n  // attempt to determine types of each dimension based on first row of data\n  pc.detectDimensionTypes = function (data) {\n    var types = {};\n    d3.keys(data[0]).forEach(function (col) {\n      types[col] = pc.toTypeCoerceNumbers(data[0][col]);\n    });\n    return types;\n  };\n  pc.render = function () {\n    // try to autodetect dimensions and create scales\n    if (!__.dimensions.length) pc.detectDimensions();\n    if (!(__.dimensions[0] in yscale)) pc.autoscale();\n\n    pc.render[__.mode]();\n\n    events.render.call(this);\n    return this;\n  };\n\n  pc.renderBrushed = function () {\n    if (!__.dimensions.length) pc.detectDimensions();\n    if (!(__.dimensions[0] in yscale)) pc.autoscale();\n\n    pc.renderBrushed[__.mode]();\n\n    events.render.call(this);\n    return this;\n  };\n\n  function isBrushed() {\n    if (__.brushed && __.brushed.length !== __.data.length) return true;\n\n    var object = brush.currentMode().brushState();\n\n    for (var key in object) {\n      if (object.hasOwnProperty(key)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  pc.render.default = function () {\n    pc.clear('foreground');\n    pc.clear('highlight');\n\n    pc.renderBrushed.default();\n\n    __.data.forEach(path_foreground);\n  };\n\n  var foregroundQueue = d3.\n  renderQueue(path_foreground).\n  rate(50).\n  clear(function () {\n    pc.clear('foreground');\n    pc.clear('highlight');\n  });\n\n  pc.render.queue = function () {\n    pc.renderBrushed.queue();\n\n    foregroundQueue(__.data);\n  };\n\n  pc.renderBrushed.default = function () {\n    pc.clear('brushed');\n\n    if (isBrushed()) {\n      __.brushed.forEach(path_brushed);\n    }\n  };\n\n  var brushedQueue = d3.\n  renderQueue(path_brushed).\n  rate(50).\n  clear(function () {\n    pc.clear('brushed');\n  });\n\n  pc.renderBrushed.queue = function () {\n    if (isBrushed()) {\n      brushedQueue(__.brushed);\n    } else {\n      brushedQueue([]); // This is needed to clear the currently brushed items\n    }\n  };\n  function compute_cluster_centroids(d) {\n    var clusterCentroids = d3.map();\n    var clusterCounts = d3.map();\n    // determine clusterCounts\n    __.data.forEach(function (row) {\n      var scaled = yscale[d](row[d]);\n      if (!clusterCounts.has(scaled)) {\n        clusterCounts.set(scaled, 0);\n      }\n      var count = clusterCounts.get(scaled);\n      clusterCounts.set(scaled, count + 1);\n    });\n\n    __.data.forEach(function (row) {\n      __.dimensions.map(function (p, i) {\n        var scaled = yscale[d](row[d]);\n        if (!clusterCentroids.has(scaled)) {\n          var map = d3.map();\n          clusterCentroids.set(scaled, map);\n        }\n        if (!clusterCentroids.get(scaled).has(p)) {\n          clusterCentroids.get(scaled).set(p, 0);\n        }\n        var value = clusterCentroids.get(scaled).get(p);\n        value += yscale[p](row[p]) / clusterCounts.get(scaled);\n        clusterCentroids.get(scaled).set(p, value);\n      });\n    });\n\n    return clusterCentroids;\n  }\n\n  function compute_centroids(row) {\n    var centroids = [];\n\n    var p = __.dimensions;\n    var cols = p.length;\n    var a = 0.5; // center between axes\n    for (var i = 0; i < cols; ++i) {\n      // centroids on 'real' axes\n      var x = position(p[i]);\n      var y = yscale[p[i]](row[p[i]]);\n      centroids.push($V([x, y]));\n\n      // centroids on 'virtual' axes\n      if (i < cols - 1) {\n        var cx = x + a * (position(p[i + 1]) - x);\n        var cy = y + a * (yscale[p[i + 1]](row[p[i + 1]]) - y);\n        if (__.bundleDimension !== null) {\n          var leftCentroid = __.clusterCentroids.\n          get(yscale[__.bundleDimension](row[__.bundleDimension])).\n          get(p[i]);\n          var rightCentroid = __.clusterCentroids.\n          get(yscale[__.bundleDimension](row[__.bundleDimension])).\n          get(p[i + 1]);\n          var centroid = 0.5 * (leftCentroid + rightCentroid);\n          cy = centroid + (1 - __.bundlingStrength) * (cy - centroid);\n        }\n        centroids.push($V([cx, cy]));\n      }\n    }\n\n    return centroids;\n  }\n\n  function compute_control_points(centroids) {\n    var cols = centroids.length;\n    var a = __.smoothness;\n    var cps = [];\n\n    cps.push(centroids[0]);\n    cps.push(\n    $V([\n    centroids[0].e(1) + a * 2 * (centroids[1].e(1) - centroids[0].e(1)),\n    centroids[0].e(2)]));\n\n\n    for (var col = 1; col < cols - 1; ++col) {\n      var mid = centroids[col];\n      var left = centroids[col - 1];\n      var right = centroids[col + 1];\n\n      var diff = left.subtract(right);\n      cps.push(mid.add(diff.x(a)));\n      cps.push(mid);\n      cps.push(mid.subtract(diff.x(a)));\n    }\n    cps.push(\n    $V([\n    centroids[cols - 1].e(1) +\n    a * 2 * (centroids[cols - 2].e(1) - centroids[cols - 1].e(1)),\n    centroids[cols - 1].e(2)]));\n\n\n    cps.push(centroids[cols - 1]);\n\n    return cps;\n  }\n\n  pc.shadows = function () {\n    flags.shadows = true;\n    pc.alphaOnBrushed(0.1);\n    pc.render();\n    return this;\n  };\n\n  // draw dots with radius r on the axis line where data intersects\n  pc.axisDots = function (r) {\n    var r = r || 0.1;\n    var ctx = pc.ctx.marks;\n    var startAngle = 0;\n    var endAngle = 2 * Math.PI;\n    ctx.globalAlpha = d3.min([1 / Math.pow(__.data.length, 1 / 2), 1]);\n    __.data.forEach(function (d) {\n      __.dimensions.map(function (p, i) {\n        ctx.beginPath();\n        ctx.arc(position(p), yscale[p](d[p]), r, startAngle, endAngle);\n        ctx.stroke();\n        ctx.fill();\n      });\n    });\n    return this;\n  };\n\n  // draw single cubic bezier curve\n  function single_curve(d, ctx) {\n    var centroids = compute_centroids(d);\n    var cps = compute_control_points(centroids);\n\n    ctx.moveTo(cps[0].e(1), cps[0].e(2));\n    for (var i = 1; i < cps.length; i += 3) {\n      if (__.showControlPoints) {\n        for (var j = 0; j < 3; j += 1) {\n          ctx.fillRect(cps[i + j].e(1), cps[i + j].e(2), 2, 2);\n        }\n      }\n      ctx.bezierCurveTo(\n      cps[i].e(1),\n      cps[i].e(2),\n      cps[i + 1].e(1),\n      cps[i + 1].e(2),\n      cps[i + 2].e(1),\n      cps[i + 2].e(2));\n\n    }\n  }\n\n  // draw single polyline\n  function color_path(d, ctx) {\n    ctx.beginPath();\n    if (\n    __.bundleDimension !== null && __.bundlingStrength > 0 ||\n    __.smoothness > 0)\n    {\n      single_curve(d, ctx);\n    } else {\n      single_path(d, ctx);\n    }\n    ctx.stroke();\n  }\n\n  // draw many polylines of the same color\n  function paths(data, ctx) {\n    ctx.clearRect(-1, -1, w() + 2, h() + 2);\n    ctx.beginPath();\n    data.forEach(function (d) {\n      if (\n      __.bundleDimension !== null && __.bundlingStrength > 0 ||\n      __.smoothness > 0)\n      {\n        single_curve(d, ctx);\n      } else {\n        single_path(d, ctx);\n      }\n    });\n    ctx.stroke();\n  }\n\n  // returns the y-position just beyond the separating null value line\n  function getNullPosition() {\n    if (__.nullValueSeparator == 'bottom') {\n      return h() + 1;\n    } else if (__.nullValueSeparator == 'top') {\n      return 1;\n    } else {\n      console.log(\n      \"A value is NULL, but nullValueSeparator is not set; set it to 'bottom' or 'top'.\");\n\n    }\n    return h() + 1;\n  }\n\n  function single_path(d, ctx) {\n    __.dimensions.map(function (p, i) {\n      if (i == 0) {\n        ctx.moveTo(\n        position(p),\n        typeof d[p] == 'undefined' ? getNullPosition() : yscale[p](d[p]));\n\n      } else {\n        ctx.lineTo(\n        position(p),\n        typeof d[p] == 'undefined' ? getNullPosition() : yscale[p](d[p]));\n\n      }\n    });\n  }\n\n  function path_brushed(d, i) {\n    if (__.brushedColor !== null) {\n      ctx.brushed.strokeStyle = d3.functor(__.brushedColor)(d, i);\n    } else {\n      ctx.brushed.strokeStyle = d3.functor(__.color)(d, i);\n    }\n    return color_path(d, ctx.brushed);\n  }\n\n  function path_foreground(d, i) {\n    ctx.foreground.strokeStyle = d3.functor(__.color)(d, i);\n    return color_path(d, ctx.foreground);\n  }\n\n  function path_highlight(d, i) {\n    ctx.highlight.strokeStyle = d3.functor(__.color)(d, i);\n    return color_path(d, ctx.highlight);\n  }\n  pc.clear = function (layer) {\n    ctx[layer].clearRect(0, 0, w() + 2, h() + 2);\n\n    // This will make sure that the foreground items are transparent\n    // without the need for changing the opacity style of the foreground canvas\n    // as this would stop the css styling from working\n    if (layer === 'brushed' && isBrushed()) {\n      ctx.brushed.fillStyle = pc.selection.style('background-color');\n      ctx.brushed.globalAlpha = 1 - __.alphaOnBrushed;\n      ctx.brushed.fillRect(0, 0, w() + 2, h() + 2);\n      ctx.brushed.globalAlpha = __.alpha;\n    }\n    return this;\n  };\n\n  d3.rebind(\n  pc,\n  axis,\n  'ticks',\n  'orient',\n  'tickValues',\n  'tickSubdivide',\n  'tickSize',\n  'tickPadding',\n  'tickFormat');\n\n\n  function flipAxisAndUpdatePCP(dimension) {\n    var g = pc.svg.selectAll('.dimension');\n\n    pc.flip(dimension);\n\n    d3.select(this.parentElement).\n    transition().\n    duration(1100).\n    call(axis.scale(yscale[dimension]));\n\n    pc.render();\n  }\n\n  function rotateLabels() {\n    var delta = d3.event.deltaY;\n    delta = delta < 0 ? -5 : delta;\n    delta = delta > 0 ? 5 : delta;\n\n    __.dimensionTitleRotation += delta;\n    pc.svg.\n    selectAll('text.label').\n    attr(\n    'transform',\n    'translate(0,-5) rotate(' + __.dimensionTitleRotation + ')');\n\n    d3.event.preventDefault();\n  }\n\n  function dimensionLabels(d) {\n    return d in __.dimensionTitles ? __.dimensionTitles[d] : d; // dimension display names\n  }\n\n  pc.createAxes = function () {\n    if (g) pc.removeAxes();\n\n    // Add a group element for each dimension.\n    g = pc.svg.\n    selectAll('.dimension').\n    data(__.dimensions, function (d) {\n      return d;\n    }).\n    enter().\n    append('svg:g').\n    attr('class', 'dimension').\n    attr('transform', function (d) {\n      return 'translate(' + xscale(d) + ')';\n    });\n\n    // Add an axis and title.\n    g.append('svg:g').\n    attr('class', 'axis').\n    attr('transform', 'translate(0,0)').\n    each(function (d) {\n      d3.select(this).call(axis.scale(yscale[d]));\n    }).\n    append('svg:text').\n    attr({\n      'text-anchor': 'middle',\n      y: 0,\n      transform: 'translate(0,-5) rotate(' + __.dimensionTitleRotation + ')',\n      x: 0,\n      class: 'label' }).\n\n    text(dimensionLabels).\n    on('dblclick', flipAxisAndUpdatePCP).\n    on('wheel', rotateLabels);\n\n    if (__.nullValueSeparator == 'top') {\n      pc.svg.\n      append('line').\n      attr('x1', 0).\n      attr('y1', 1 + __.nullValueSeparatorPadding.top).\n      attr('x2', w()).\n      attr('y2', 1 + __.nullValueSeparatorPadding.top).\n      attr('stroke-width', 1).\n      attr('stroke', '#777').\n      attr('fill', 'none').\n      attr('shape-rendering', 'crispEdges');\n    } else if (__.nullValueSeparator == 'bottom') {\n      pc.svg.\n      append('line').\n      attr('x1', 0).\n      attr('y1', h() + 1 - __.nullValueSeparatorPadding.bottom).\n      attr('x2', w()).\n      attr('y2', h() + 1 - __.nullValueSeparatorPadding.bottom).\n      attr('stroke-width', 1).\n      attr('stroke', '#777').\n      attr('fill', 'none').\n      attr('shape-rendering', 'crispEdges');\n    }\n\n    flags.axes = true;\n    return this;\n  };\n\n  pc.removeAxes = function () {\n    g.remove();\n    return this;\n  };\n\n  pc.updateAxes = function () {\n    var g_data = pc.svg.selectAll('.dimension').data(__.dimensions);\n\n    // Enter\n    g_data.\n    enter().\n    append('svg:g').\n    attr('class', 'dimension').\n    attr('transform', function (p) {\n      return 'translate(' + position(p) + ')';\n    }).\n    style('opacity', 0).\n    append('svg:g').\n    attr('class', 'axis').\n    attr('transform', 'translate(0,0)').\n    each(function (d) {\n      d3.select(this).call(axis.scale(yscale[d]));\n    }).\n    append('svg:text').\n    attr({\n      'text-anchor': 'middle',\n      y: 0,\n      transform: 'translate(0,-5) rotate(' + __.dimensionTitleRotation + ')',\n      x: 0,\n      class: 'label' }).\n\n    text(dimensionLabels).\n    on('dblclick', flipAxisAndUpdatePCP).\n    on('wheel', rotateLabels);\n\n    // Update\n    g_data.attr('opacity', 0);\n    g_data.\n    select('.axis').\n    transition().\n    duration(1100).\n    each(function (d) {\n      d3.select(this).call(axis.scale(yscale[d]));\n    });\n    g_data.\n    select('.label').\n    transition().\n    duration(1100).\n    text(dimensionLabels).\n    attr(\n    'transform',\n    'translate(0,-5) rotate(' + __.dimensionTitleRotation + ')');\n\n\n    // Exit\n    g_data.exit().remove();\n\n    g = pc.svg.selectAll('.dimension');\n    g.transition().\n    duration(1100).\n    attr('transform', function (p) {\n      return 'translate(' + position(p) + ')';\n    }).\n    style('opacity', 1);\n\n    pc.svg.\n    selectAll('.axis').\n    transition().\n    duration(1100).\n    each(function (d) {\n      d3.select(this).call(axis.scale(yscale[d]));\n    });\n\n    if (flags.brushable) pc.brushable();\n    if (flags.reorderable) pc.reorderable();\n    if (pc.brushMode() !== 'None') {\n      var mode = pc.brushMode();\n      pc.brushMode('None');\n      pc.brushMode(mode);\n    }\n    return this;\n  };\n\n  // Jason Davies, http://bl.ocks.org/1341281\n  pc.reorderable = function () {\n    if (!g) pc.createAxes();\n\n    g.style('cursor', 'move').call(\n    d3.behavior.\n    drag().\n    on('dragstart', function (d) {\n      dragging[d] = this.__origin__ = xscale(d);\n    }).\n    on('drag', function (d) {\n      dragging[d] = Math.min(\n      w(),\n      Math.max(0, this.__origin__ += d3.event.dx));\n\n      __.dimensions.sort(function (a, b) {\n        return position(a) - position(b);\n      });\n      xscale.domain(__.dimensions);\n      pc.render();\n      g.attr('transform', function (d) {\n        return 'translate(' + position(d) + ')';\n      });\n    }).\n    on('dragend', function (d) {\n      // Let's see if the order has changed and send out an event if so.\n      var i = 0,\n      j = __.dimensions.indexOf(d),\n      elem = this,\n      parent = this.parentElement;\n\n      while ((elem = elem.previousElementSibling) != null) ++i;\n      if (i !== j) {\n        events.axesreorder.call(pc, __.dimensions);\n        // We now also want to reorder the actual dom elements that represent\n        // the axes. That is, the g.dimension elements. If we don't do this,\n        // we get a weird and confusing transition when updateAxes is called.\n        // This is due to the fact that, initially the nth g.dimension element\n        // represents the nth axis. However, after a manual reordering,\n        // without reordering the dom elements, the nth dom elements no longer\n        // necessarily represents the nth axis.\n        //\n        // i is the original index of the dom element\n        // j is the new index of the dom element\n        if (i > j) {\n          // Element moved left\n          parent.insertBefore(this, parent.children[j - 1]);\n        } else {\n          // Element moved right\n          if (j + 1 < parent.children.length) {\n            parent.insertBefore(this, parent.children[j + 1]);\n          } else {\n            parent.appendChild(this);\n          }\n        }\n      }\n\n      delete this.__origin__;\n      delete dragging[d];\n      d3.select(this).\n      transition().\n      attr('transform', 'translate(' + xscale(d) + ')');\n      pc.render();\n    }));\n\n    flags.reorderable = true;\n    return this;\n  };\n\n  // Reorder dimensions, such that the highest value (visually) is on the left and\n  // the lowest on the right. Visual values are determined by the data values in\n  // the given row.\n  pc.reorder = function (rowdata) {\n    var dims = __.dimensions.slice(0);\n    __.dimensions.sort(function (a, b) {\n      var pixelDifference = yscale[a](rowdata[a]) - yscale[b](rowdata[b]);\n\n      // Array.sort is not necessarily stable, this means that if pixelDifference is zero\n      // the ordering of dimensions might change unexpectedly. This is solved by sorting on\n      // variable name in that case.\n      if (pixelDifference === 0) {\n        return a.localeCompare(b);\n      } // else\n      return pixelDifference;\n    });\n\n    // NOTE: this is relatively cheap given that:\n    // number of dimensions < number of data items\n    // Thus we check equality of order to prevent rerendering when this is the case.\n    var reordered = false;\n    dims.some(function (val, index) {\n      reordered = val !== __.dimensions[index];\n      return reordered;\n    });\n\n    if (reordered) {\n      xscale.domain(__.dimensions);\n      var highlighted = __.highlighted.slice(0);\n      pc.unhighlight();\n\n      g.transition().\n      duration(1500).\n      attr('transform', function (d) {\n        return 'translate(' + xscale(d) + ')';\n      });\n      pc.render();\n\n      // pc.highlight() does not check whether highlighted is length zero, so we do that here.\n      if (highlighted.length !== 0) {\n        pc.highlight(highlighted);\n      }\n    }\n  };\n\n  // pairs of adjacent dimensions\n  pc.adjacent_pairs = function (arr) {\n    var ret = [];\n    for (var i = 0; i < arr.length - 1; i += 1) {\n      ret.push([arr[i], arr[i + 1]]);\n    }\n    return ret;\n  };\n\n  var brush = {\n    modes: {\n      None: {\n        install: function (pc) {}, // Nothing to be done.\n        uninstall: function (pc) {}, // Nothing to be done.\n        selected: function () {\n          return [];\n        }, // Nothing to return\n        brushState: function () {\n          return {};\n        } } },\n\n\n    mode: 'None',\n    predicate: 'AND',\n    currentMode: function () {\n      return this.modes[this.mode];\n    } };\n\n\n  // This function can be used for 'live' updates of brushes. That is, during the\n  // specification of a brush, this method can be called to update the view.\n  //\n  // @param newSelection - The new set of data items that is currently contained\n  //                       by the brushes\n  function brushUpdated(newSelection) {\n    __.brushed = newSelection;\n    events.brush.call(pc, __.brushed);\n    pc.renderBrushed();\n  }\n\n  function brushPredicate(predicate) {\n    if (!arguments.length) {\n      return brush.predicate;\n    }\n\n    predicate = String(predicate).toUpperCase();\n    if (predicate !== 'AND' && predicate !== 'OR') {\n      throw 'Invalid predicate ' + predicate;\n    }\n\n    brush.predicate = predicate;\n    __.brushed = brush.currentMode().selected();\n    pc.renderBrushed();\n    return pc;\n  }\n\n  pc.brushModes = function () {\n    return Object.getOwnPropertyNames(brush.modes);\n  };\n\n  pc.brushMode = function (mode) {\n    if (arguments.length === 0) {\n      return brush.mode;\n    }\n\n    if (pc.brushModes().indexOf(mode) === -1) {\n      throw 'pc.brushmode: Unsupported brush mode: ' + mode;\n    }\n\n    // Make sure that we don't trigger unnecessary events by checking if the mode\n    // actually changes.\n    if (mode !== brush.mode) {\n      // When changing brush modes, the first thing we need to do is clearing any\n      // brushes from the current mode, if any.\n      if (brush.mode !== 'None') {\n        pc.brushReset();\n      }\n\n      // Next, we need to 'uninstall' the current brushMode.\n      brush.modes[brush.mode].uninstall(pc);\n      // Finally, we can install the requested one.\n      brush.mode = mode;\n      brush.modes[brush.mode].install();\n      if (mode === 'None') {\n        delete pc.brushPredicate;\n      } else {\n        pc.brushPredicate = brushPredicate;\n      }\n    }\n\n    return pc;\n  };\n\n  // brush mode: 1D-Axes\n\n  (function () {\n    var brushes = {};\n\n    function is_brushed(p) {\n      return !brushes[p].empty();\n    }\n\n    // data within extents\n    function selected() {\n      var actives = __.dimensions.filter(is_brushed),\n      extents = actives.map(function (p) {\n        return brushes[p].extent();\n      });\n\n      // We don't want to return the full data set when there are no axes brushed.\n      // Actually, when there are no axes brushed, by definition, no items are\n      // selected. So, let's avoid the filtering and just return false.\n      //if (actives.length === 0) return false;\n\n      // Resolves broken examples for now. They expect to get the full dataset back from empty brushes\n      if (actives.length === 0) return __.data;\n\n      // test if within range\n      var within = {\n        date: function (d, p, dimension) {\n          if (typeof yscale[p].rangePoints === 'function') {\n            // if it is ordinal\n            return (\n              extents[dimension][0] <= yscale[p](d[p]) &&\n              yscale[p](d[p]) <= extents[dimension][1]);\n\n          } else {\n            return (\n              extents[dimension][0] <= d[p] && d[p] <= extents[dimension][1]);\n\n          }\n        },\n        number: function (d, p, dimension) {\n          if (typeof yscale[p].rangePoints === 'function') {\n            // if it is ordinal\n            return (\n              extents[dimension][0] <= yscale[p](d[p]) &&\n              yscale[p](d[p]) <= extents[dimension][1]);\n\n          } else {\n            return (\n              extents[dimension][0] <= d[p] && d[p] <= extents[dimension][1]);\n\n          }\n        },\n        string: function (d, p, dimension) {\n          return (\n            extents[dimension][0] <= yscale[p](d[p]) &&\n            yscale[p](d[p]) <= extents[dimension][1]);\n\n        } };\n\n\n      return __.data.filter(function (d) {\n        switch (brush.predicate) {\n          case 'AND':\n            return actives.every(function (p, dimension) {\n              return within[__.types[p]](d, p, dimension);\n            });\n          case 'OR':\n            return actives.some(function (p, dimension) {\n              return within[__.types[p]](d, p, dimension);\n            });\n          default:\n            throw 'Unknown brush predicate ' + __.brushPredicate;}\n\n      });\n    }\n\n    function brushExtents(extents) {\n      if (typeof extents === 'undefined') {\n        var extents = {};\n        __.dimensions.forEach(function (d) {\n          var brush = brushes[d];\n          if (brush !== undefined && !brush.empty()) {\n            var extent = brush.extent();\n            extent.sort(d3.ascending);\n            extents[d] = extent;\n          }\n        });\n        return extents;\n      } else {\n        //first get all the brush selections\n        var brushSelections = {};\n        g.selectAll('.brush').each(function (d) {\n          brushSelections[d] = d3.select(this);\n        });\n\n        // loop over each dimension and update appropriately (if it was passed in through extents)\n        __.dimensions.forEach(function (d) {\n          if (extents[d] === undefined) {\n            return;\n          }\n\n          var brush = brushes[d];\n          if (brush !== undefined) {\n            //update the extent\n            brush.extent(extents[d]);\n\n            //redraw the brush\n            brush(brushSelections[d]);\n\n            //fire some events\n            brush.event(brushSelections[d]);\n          }\n        });\n\n        //redraw the chart\n        pc.renderBrushed();\n      }\n    }\n    function brushFor(axis) {\n      var brush = d3.svg.brush();\n\n      brush.\n      y(yscale[axis]).\n      on('brushstart', function () {\n        if (d3.event.sourceEvent !== null) {\n          d3.event.sourceEvent.stopPropagation();\n        }\n      }).\n      on('brush', function () {\n        brushUpdated(selected());\n      }).\n      on('brushend', function () {\n        events.brushend.call(pc, __.brushed);\n      });\n\n      brushes[axis] = brush;\n      return brush;\n    }\n    function brushReset(dimension) {\n      __.brushed = false;\n      if (g) {\n        g.selectAll('.brush').each(function (d) {\n          d3.select(this).call(brushes[d].clear());\n        });\n        pc.renderBrushed();\n      }\n      return this;\n    }\n\n    function install() {\n      if (!g) pc.createAxes();\n\n      // Add and store a brush for each axis.\n      g.append('svg:g').\n      attr('class', 'brush').\n      each(function (d) {\n        d3.select(this).call(brushFor(d));\n      }).\n      selectAll('rect').\n      style('visibility', null).\n      attr('x', -15).\n      attr('width', 30);\n\n      pc.brushExtents = brushExtents;\n      pc.brushReset = brushReset;\n      return pc;\n    }\n\n    brush.modes['1D-axes'] = {\n      install: install,\n      uninstall: function () {\n        g.selectAll('.brush').remove();\n        brushes = {};\n        delete pc.brushExtents;\n        delete pc.brushReset;\n      },\n      selected: selected,\n      brushState: brushExtents };\n\n  })();\n  // brush mode: 2D-strums\n  // bl.ocks.org/syntagmatic/5441022\n\n  (function () {\n    var strums = {},\n    strumRect;\n\n    function drawStrum(strum, activePoint) {\n      var svg = pc.selection.select('svg').select('g#strums'),\n      id = strum.dims.i,\n      points = [strum.p1, strum.p2],\n      line = svg.selectAll('line#strum-' + id).data([strum]),\n      circles = svg.selectAll('circle#strum-' + id).data(points),\n      drag = d3.behavior.drag();\n\n      line.\n      enter().\n      append('line').\n      attr('id', 'strum-' + id).\n      attr('class', 'strum');\n\n      line.\n      attr('x1', function (d) {\n        return d.p1[0];\n      }).\n      attr('y1', function (d) {\n        return d.p1[1];\n      }).\n      attr('x2', function (d) {\n        return d.p2[0];\n      }).\n      attr('y2', function (d) {\n        return d.p2[1];\n      }).\n      attr('stroke', 'black').\n      attr('stroke-width', 2);\n\n      drag.\n      on('drag', function (d, i) {\n        var ev = d3.event;\n        i = i + 1;\n        strum['p' + i][0] = Math.min(\n        Math.max(strum.minX + 1, ev.x),\n        strum.maxX);\n\n        strum['p' + i][1] = Math.min(Math.max(strum.minY, ev.y), strum.maxY);\n        drawStrum(strum, i - 1);\n      }).\n      on('dragend', onDragEnd());\n\n      circles.\n      enter().\n      append('circle').\n      attr('id', 'strum-' + id).\n      attr('class', 'strum');\n\n      circles.\n      attr('cx', function (d) {\n        return d[0];\n      }).\n      attr('cy', function (d) {\n        return d[1];\n      }).\n      attr('r', 5).\n      style('opacity', function (d, i) {\n        return activePoint !== undefined && i === activePoint ? 0.8 : 0;\n      }).\n      on('mouseover', function () {\n        d3.select(this).style('opacity', 0.8);\n      }).\n      on('mouseout', function () {\n        d3.select(this).style('opacity', 0);\n      }).\n      call(drag);\n    }\n\n    function dimensionsForPoint(p) {\n      var dims = { i: -1, left: undefined, right: undefined };\n      __.dimensions.some(function (dim, i) {\n        if (xscale(dim) < p[0]) {\n          var next = __.dimensions[i + 1];\n          dims.i = i;\n          dims.left = dim;\n          dims.right = next;\n          return false;\n        }\n        return true;\n      });\n\n      if (dims.left === undefined) {\n        // Event on the left side of the first axis.\n        dims.i = 0;\n        dims.left = __.dimensions[0];\n        dims.right = __.dimensions[1];\n      } else if (dims.right === undefined) {\n        // Event on the right side of the last axis\n        dims.i = __.dimensions.length - 1;\n        dims.right = dims.left;\n        dims.left = __.dimensions[__.dimensions.length - 2];\n      }\n\n      return dims;\n    }\n\n    function onDragStart() {\n      // First we need to determine between which two axes the sturm was started.\n      // This will determine the freedom of movement, because a strum can\n      // logically only happen between two axes, so no movement outside these axes\n      // should be allowed.\n      return function () {\n        var p = d3.mouse(strumRect[0][0]),\n        dims,\n        strum;\n\n        p[0] = p[0] - __.margin.left;\n        p[1] = p[1] - __.margin.top;\n\n        dims = dimensionsForPoint(p),\n        strum = {\n          p1: p,\n          dims: dims,\n          minX: xscale(dims.left),\n          maxX: xscale(dims.right),\n          minY: 0,\n          maxY: h() };\n\n\n        strums[dims.i] = strum;\n        strums.active = dims.i;\n\n        // Make sure that the point is within the bounds\n        strum.p1[0] = Math.min(Math.max(strum.minX, p[0]), strum.maxX);\n        strum.p2 = strum.p1.slice();\n      };\n    }\n\n    function onDrag() {\n      return function () {\n        var ev = d3.event,\n        strum = strums[strums.active];\n\n        // Make sure that the point is within the bounds\n        strum.p2[0] = Math.min(\n        Math.max(strum.minX + 1, ev.x - __.margin.left),\n        strum.maxX);\n\n        strum.p2[1] = Math.min(\n        Math.max(strum.minY, ev.y - __.margin.top),\n        strum.maxY);\n\n        drawStrum(strum, 1);\n      };\n    }\n\n    function containmentTest(strum, width) {\n      var p1 = [strum.p1[0] - strum.minX, strum.p1[1] - strum.minX],\n      p2 = [strum.p2[0] - strum.minX, strum.p2[1] - strum.minX],\n      m1 = 1 - width / p1[0],\n      b1 = p1[1] * (1 - m1),\n      m2 = 1 - width / p2[0],\n      b2 = p2[1] * (1 - m2);\n\n      // test if point falls between lines\n      return function (p) {\n        var x = p[0],\n        y = p[1],\n        y1 = m1 * x + b1,\n        y2 = m2 * x + b2;\n\n        if (y > Math.min(y1, y2) && y < Math.max(y1, y2)) {\n          return true;\n        }\n\n        return false;\n      };\n    }\n\n    function selected() {\n      var ids = Object.getOwnPropertyNames(strums),\n      brushed = __.data;\n\n      // Get the ids of the currently active strums.\n      ids = ids.filter(function (d) {\n        return !isNaN(d);\n      });\n\n      function crossesStrum(d, id) {\n        var strum = strums[id],\n        test = containmentTest(strum, strums.width(id)),\n        d1 = strum.dims.left,\n        d2 = strum.dims.right,\n        y1 = yscale[d1],\n        y2 = yscale[d2],\n        point = [y1(d[d1]) - strum.minX, y2(d[d2]) - strum.minX];\n        return test(point);\n      }\n\n      if (ids.length === 0) {\n        return brushed;\n      }\n\n      return brushed.filter(function (d) {\n        switch (brush.predicate) {\n          case 'AND':\n            return ids.every(function (id) {\n              return crossesStrum(d, id);\n            });\n          case 'OR':\n            return ids.some(function (id) {\n              return crossesStrum(d, id);\n            });\n          default:\n            throw 'Unknown brush predicate ' + __.brushPredicate;}\n\n      });\n    }\n\n    function removeStrum() {\n      var strum = strums[strums.active],\n      svg = pc.selection.select('svg').select('g#strums');\n\n      delete strums[strums.active];\n      strums.active = undefined;\n      svg.selectAll('line#strum-' + strum.dims.i).remove();\n      svg.selectAll('circle#strum-' + strum.dims.i).remove();\n    }\n\n    function onDragEnd() {\n      return function () {\n        var brushed = __.data,\n        strum = strums[strums.active];\n\n        // Okay, somewhat unexpected, but not totally unsurprising, a mousclick is\n        // considered a drag without move. So we have to deal with that case\n        if (\n        strum &&\n        strum.p1[0] === strum.p2[0] &&\n        strum.p1[1] === strum.p2[1])\n        {\n          removeStrum(strums);\n        }\n\n        brushed = selected(strums);\n        strums.active = undefined;\n        __.brushed = brushed;\n        pc.renderBrushed();\n        events.brushend.call(pc, __.brushed);\n      };\n    }\n\n    function brushReset(strums) {\n      return function () {\n        var ids = Object.getOwnPropertyNames(strums).filter(function (d) {\n          return !isNaN(d);\n        });\n\n        ids.forEach(function (d) {\n          strums.active = d;\n          removeStrum(strums);\n        });\n        onDragEnd(strums)();\n      };\n    }\n\n    function install() {\n      var drag = d3.behavior.drag();\n\n      // Map of current strums. Strums are stored per segment of the PC. A segment,\n      // being the area between two axes. The left most area is indexed at 0.\n      strums.active = undefined;\n      // Returns the width of the PC segment where currently a strum is being\n      // placed. NOTE: even though they are evenly spaced in our current\n      // implementation, we keep for when non-even spaced segments are supported as\n      // well.\n      strums.width = function (id) {\n        var strum = strums[id];\n\n        if (strum === undefined) {\n          return undefined;\n        }\n\n        return strum.maxX - strum.minX;\n      };\n\n      pc.on('axesreorder.strums', function () {\n        var ids = Object.getOwnPropertyNames(strums).filter(function (d) {\n          return !isNaN(d);\n        });\n\n        // Checks if the first dimension is directly left of the second dimension.\n        function consecutive(first, second) {\n          var length = __.dimensions.length;\n          return __.dimensions.some(function (d, i) {\n            return d === first ?\n            i + i < length && __.dimensions[i + 1] === second :\n            false;\n          });\n        }\n\n        if (ids.length > 0) {\n          // We have some strums, which might need to be removed.\n          ids.forEach(function (d) {\n            var dims = strums[d].dims;\n            strums.active = d;\n            // If the two dimensions of the current strum are not next to each other\n            // any more, than we'll need to remove the strum. Otherwise we keep it.\n            if (!consecutive(dims.left, dims.right)) {\n              removeStrum(strums);\n            }\n          });\n          onDragEnd(strums)();\n        }\n      });\n\n      // Add a new svg group in which we draw the strums.\n      pc.selection.\n      select('svg').\n      append('g').\n      attr('id', 'strums').\n      attr(\n      'transform',\n      'translate(' + __.margin.left + ',' + __.margin.top + ')');\n\n\n      // Install the required brushReset function\n      pc.brushReset = brushReset(strums);\n\n      drag.\n      on('dragstart', onDragStart(strums)).\n      on('drag', onDrag(strums)).\n      on('dragend', onDragEnd(strums));\n\n      // NOTE: The styling needs to be done here and not in the css. This is because\n      //       for 1D brushing, the canvas layers should not listen to\n      //       pointer-events.\n      strumRect = pc.selection.\n      select('svg').\n      insert('rect', 'g#strums').\n      attr('id', 'strum-events').\n      attr('x', __.margin.left).\n      attr('y', __.margin.top).\n      attr('width', w()).\n      attr('height', h() + 2).\n      style('opacity', 0).\n      call(drag);\n    }\n\n    brush.modes['2D-strums'] = {\n      install: install,\n      uninstall: function () {\n        pc.selection.select('svg').select('g#strums').remove();\n        pc.selection.select('svg').select('rect#strum-events').remove();\n        pc.on('axesreorder.strums', undefined);\n        delete pc.brushReset;\n\n        strumRect = undefined;\n      },\n      selected: selected,\n      brushState: function () {\n        return strums;\n      } };\n\n  })();\n\n  // brush mode: 1D-Axes with multiple extents\n  // requires d3.svg.multibrush\n\n  (function () {\n    if (typeof d3.svg.multibrush !== 'function') {\n      return;\n    }\n    var brushes = {};\n\n    function is_brushed(p) {\n      return !brushes[p].empty();\n    }\n\n    // data within extents\n    function selected() {\n      var actives = __.dimensions.filter(is_brushed),\n      extents = actives.map(function (p) {\n        return brushes[p].extent();\n      });\n\n      // We don't want to return the full data set when there are no axes brushed.\n      // Actually, when there are no axes brushed, by definition, no items are\n      // selected. So, let's avoid the filtering and just return false.\n      //if (actives.length === 0) return false;\n\n      // Resolves broken examples for now. They expect to get the full dataset back from empty brushes\n      if (actives.length === 0) return __.data;\n\n      // test if within range\n      var within = {\n        date: function (d, p, dimension, b) {\n          if (typeof yscale[p].rangePoints === 'function') {\n            // if it is ordinal\n            return b[0] <= yscale[p](d[p]) && yscale[p](d[p]) <= b[1];\n          } else {\n            return b[0] <= d[p] && d[p] <= b[1];\n          }\n        },\n        number: function (d, p, dimension, b) {\n          if (typeof yscale[p].rangePoints === 'function') {\n            // if it is ordinal\n            return b[0] <= yscale[p](d[p]) && yscale[p](d[p]) <= b[1];\n          } else {\n            return b[0] <= d[p] && d[p] <= b[1];\n          }\n        },\n        string: function (d, p, dimension, b) {\n          return b[0] <= yscale[p](d[p]) && yscale[p](d[p]) <= b[1];\n        } };\n\n\n      return __.data.filter(function (d) {\n        switch (brush.predicate) {\n          case 'AND':\n            return actives.every(function (p, dimension) {\n              return extents[dimension].some(function (b) {\n                return within[__.types[p]](d, p, dimension, b);\n              });\n            });\n          case 'OR':\n            return actives.some(function (p, dimension) {\n              return extents[dimension].some(function (b) {\n                return within[__.types[p]](d, p, dimension, b);\n              });\n            });\n          default:\n            throw 'Unknown brush predicate ' + __.brushPredicate;}\n\n      });\n    }\n\n    function brushExtents() {\n      var extents = {};\n      __.dimensions.forEach(function (d) {\n        var brush = brushes[d];\n        if (brush !== undefined && !brush.empty()) {\n          var extent = brush.extent();\n          extents[d] = extent;\n        }\n      });\n      return extents;\n    }\n\n    function brushFor(axis) {\n      var brush = d3.svg.multibrush();\n\n      brush.\n      y(yscale[axis]).\n      on('brushstart', function () {\n        if (d3.event.sourceEvent !== null) {\n          d3.event.sourceEvent.stopPropagation();\n        }\n      }).\n      on('brush', function () {\n        brushUpdated(selected());\n      }).\n      on('brushend', function () {\n        // d3.svg.multibrush clears extents just before calling 'brushend'\n        // so we have to update here again.\n        // This fixes issue #103 for now, but should be changed in d3.svg.multibrush\n        // to avoid unnecessary computation.\n        brushUpdated(selected());\n        events.brushend.call(pc, __.brushed);\n      }).\n      extentAdaption(function (selection) {\n        selection.style('visibility', null).attr('x', -15).attr('width', 30);\n      }).\n      resizeAdaption(function (selection) {\n        selection.selectAll('rect').attr('x', -15).attr('width', 30);\n      });\n\n      brushes[axis] = brush;\n      return brush;\n    }\n\n    function brushReset(dimension) {\n      __.brushed = false;\n      if (g) {\n        g.selectAll('.brush').each(function (d) {\n          d3.select(this).call(brushes[d].clear());\n        });\n        pc.renderBrushed();\n      }\n      return this;\n    }\n\n    function install() {\n      if (!g) pc.createAxes();\n\n      // Add and store a brush for each axis.\n      g.append('svg:g').\n      attr('class', 'brush').\n      each(function (d) {\n        d3.select(this).call(brushFor(d));\n      }).\n      selectAll('rect').\n      style('visibility', null).\n      attr('x', -15).\n      attr('width', 30);\n\n      pc.brushExtents = brushExtents;\n      pc.brushReset = brushReset;\n      return pc;\n    }\n\n    brush.modes['1D-axes-multi'] = {\n      install: install,\n      uninstall: function () {\n        g.selectAll('.brush').remove();\n        brushes = {};\n        delete pc.brushExtents;\n        delete pc.brushReset;\n      },\n      selected: selected,\n      brushState: brushExtents };\n\n  })();\n  // brush mode: angular\n  // code based on 2D.strums.js\n\n  (function () {\n    var arcs = {},\n    strumRect;\n\n    function drawStrum(arc, activePoint) {\n      var svg = pc.selection.select('svg').select('g#arcs'),\n      id = arc.dims.i,\n      points = [arc.p2, arc.p3],\n      line = svg.selectAll('line#arc-' + id).data([\n      { p1: arc.p1, p2: arc.p2 },\n      { p1: arc.p1, p2: arc.p3 }]),\n\n      circles = svg.selectAll('circle#arc-' + id).data(points),\n      drag = d3.behavior.drag(),\n      path = svg.selectAll('path#arc-' + id).data([arc]);\n\n      path.\n      enter().\n      append('path').\n      attr('id', 'arc-' + id).\n      attr('class', 'arc').\n      style('fill', 'orange').\n      style('opacity', 0.5);\n\n      path.\n      attr('d', arc.arc).\n      attr('transform', 'translate(' + arc.p1[0] + ',' + arc.p1[1] + ')');\n\n      line.\n      enter().\n      append('line').\n      attr('id', 'arc-' + id).\n      attr('class', 'arc');\n\n      line.\n      attr('x1', function (d) {\n        return d.p1[0];\n      }).\n      attr('y1', function (d) {\n        return d.p1[1];\n      }).\n      attr('x2', function (d) {\n        return d.p2[0];\n      }).\n      attr('y2', function (d) {\n        return d.p2[1];\n      }).\n      attr('stroke', 'black').\n      attr('stroke-width', 2);\n\n      drag.\n      on('drag', function (d, i) {\n        var ev = d3.event,\n        angle = 0;\n\n        i = i + 2;\n\n        arc['p' + i][0] = Math.min(Math.max(arc.minX + 1, ev.x), arc.maxX);\n        arc['p' + i][1] = Math.min(Math.max(arc.minY, ev.y), arc.maxY);\n\n        angle = i === 3 ? arcs.startAngle(id) : arcs.endAngle(id);\n\n        if (\n        arc.startAngle < Math.PI &&\n        arc.endAngle < Math.PI &&\n        angle < Math.PI ||\n        arc.startAngle >= Math.PI &&\n        arc.endAngle >= Math.PI &&\n        angle >= Math.PI)\n        {\n          if (i === 2) {\n            arc.endAngle = angle;\n            arc.arc.endAngle(angle);\n          } else if (i === 3) {\n            arc.startAngle = angle;\n            arc.arc.startAngle(angle);\n          }\n        }\n\n        drawStrum(arc, i - 2);\n      }).\n      on('dragend', onDragEnd());\n\n      circles.\n      enter().\n      append('circle').\n      attr('id', 'arc-' + id).\n      attr('class', 'arc');\n\n      circles.\n      attr('cx', function (d) {\n        return d[0];\n      }).\n      attr('cy', function (d) {\n        return d[1];\n      }).\n      attr('r', 5).\n      style('opacity', function (d, i) {\n        return activePoint !== undefined && i === activePoint ? 0.8 : 0;\n      }).\n      on('mouseover', function () {\n        d3.select(this).style('opacity', 0.8);\n      }).\n      on('mouseout', function () {\n        d3.select(this).style('opacity', 0);\n      }).\n      call(drag);\n    }\n\n    function dimensionsForPoint(p) {\n      var dims = { i: -1, left: undefined, right: undefined };\n      __.dimensions.some(function (dim, i) {\n        if (xscale(dim) < p[0]) {\n          var next = __.dimensions[i + 1];\n          dims.i = i;\n          dims.left = dim;\n          dims.right = next;\n          return false;\n        }\n        return true;\n      });\n\n      if (dims.left === undefined) {\n        // Event on the left side of the first axis.\n        dims.i = 0;\n        dims.left = __.dimensions[0];\n        dims.right = __.dimensions[1];\n      } else if (dims.right === undefined) {\n        // Event on the right side of the last axis\n        dims.i = __.dimensions.length - 1;\n        dims.right = dims.left;\n        dims.left = __.dimensions[__.dimensions.length - 2];\n      }\n\n      return dims;\n    }\n\n    function onDragStart() {\n      // First we need to determine between which two axes the arc was started.\n      // This will determine the freedom of movement, because a arc can\n      // logically only happen between two axes, so no movement outside these axes\n      // should be allowed.\n      return function () {\n        var p = d3.mouse(strumRect[0][0]),\n        dims,\n        arc;\n\n        p[0] = p[0] - __.margin.left;\n        p[1] = p[1] - __.margin.top;\n\n        dims = dimensionsForPoint(p),\n        arc = {\n          p1: p,\n          dims: dims,\n          minX: xscale(dims.left),\n          maxX: xscale(dims.right),\n          minY: 0,\n          maxY: h(),\n          startAngle: undefined,\n          endAngle: undefined,\n          arc: d3.svg.arc().innerRadius(0) };\n\n\n        arcs[dims.i] = arc;\n        arcs.active = dims.i;\n\n        // Make sure that the point is within the bounds\n        arc.p1[0] = Math.min(Math.max(arc.minX, p[0]), arc.maxX);\n        arc.p2 = arc.p1.slice();\n        arc.p3 = arc.p1.slice();\n      };\n    }\n\n    function onDrag() {\n      return function () {\n        var ev = d3.event,\n        arc = arcs[arcs.active];\n\n        // Make sure that the point is within the bounds\n        arc.p2[0] = Math.min(\n        Math.max(arc.minX + 1, ev.x - __.margin.left),\n        arc.maxX);\n\n        arc.p2[1] = Math.min(\n        Math.max(arc.minY, ev.y - __.margin.top),\n        arc.maxY);\n\n        arc.p3 = arc.p2.slice();\n        drawStrum(arc, 1);\n      };\n    }\n\n    // some helper functions\n    function hypothenuse(a, b) {\n      return Math.sqrt(a * a + b * b);\n    }\n\n    var rad = function () {\n      var c = Math.PI / 180;\n      return function (angle) {\n        return angle * c;\n      };\n    }();\n\n    var deg = function () {\n      var c = 180 / Math.PI;\n      return function (angle) {\n        return angle * c;\n      };\n    }();\n\n    // [0, 2*PI] -> [-PI/2, PI/2]\n    var signedAngle = function (angle) {\n      var ret = angle;\n      if (angle > Math.PI) {\n        ret = angle - 1.5 * Math.PI;\n        ret = angle - 1.5 * Math.PI;\n      } else {\n        ret = angle - 0.5 * Math.PI;\n        ret = angle - 0.5 * Math.PI;\n      }\n      return -ret;\n    };\n\n    /**\n     * angles are stored in radians from in [0, 2*PI], where 0 in 12 o'clock.\n     * However, one can only select lines from 0 to PI, so we compute the\n     * 'signed' angle, where 0 is the horizontal line (3 o'clock), and +/- PI/2\n     * are 12 and 6 o'clock respectively.\n     */\n    function containmentTest(arc) {\n      var startAngle = signedAngle(arc.startAngle);\n      var endAngle = signedAngle(arc.endAngle);\n\n      if (startAngle > endAngle) {\n        var tmp = startAngle;\n        startAngle = endAngle;\n        endAngle = tmp;\n      }\n\n      // test if segment angle is contained in angle interval\n      return function (a) {\n        if (a >= startAngle && a <= endAngle) {\n          return true;\n        }\n\n        return false;\n      };\n    }\n\n    function selected() {\n      var ids = Object.getOwnPropertyNames(arcs),\n      brushed = __.data;\n\n      // Get the ids of the currently active arcs.\n      ids = ids.filter(function (d) {\n        return !isNaN(d);\n      });\n\n      function crossesStrum(d, id) {\n        var arc = arcs[id],\n        test = containmentTest(arc),\n        d1 = arc.dims.left,\n        d2 = arc.dims.right,\n        y1 = yscale[d1],\n        y2 = yscale[d2],\n        a = arcs.width(id),\n        b = y1(d[d1]) - y2(d[d2]),\n        c = hypothenuse(a, b),\n        angle = Math.asin(b / c); // rad in [-PI/2, PI/2]\n        return test(angle);\n      }\n\n      if (ids.length === 0) {\n        return brushed;\n      }\n\n      return brushed.filter(function (d) {\n        switch (brush.predicate) {\n          case 'AND':\n            return ids.every(function (id) {\n              return crossesStrum(d, id);\n            });\n          case 'OR':\n            return ids.some(function (id) {\n              return crossesStrum(d, id);\n            });\n          default:\n            throw 'Unknown brush predicate ' + __.brushPredicate;}\n\n      });\n    }\n\n    function removeStrum() {\n      var arc = arcs[arcs.active],\n      svg = pc.selection.select('svg').select('g#arcs');\n\n      delete arcs[arcs.active];\n      arcs.active = undefined;\n      svg.selectAll('line#arc-' + arc.dims.i).remove();\n      svg.selectAll('circle#arc-' + arc.dims.i).remove();\n      svg.selectAll('path#arc-' + arc.dims.i).remove();\n    }\n\n    function onDragEnd() {\n      return function () {\n        var brushed = __.data,\n        arc = arcs[arcs.active];\n\n        // Okay, somewhat unexpected, but not totally unsurprising, a mousclick is\n        // considered a drag without move. So we have to deal with that case\n        if (arc && arc.p1[0] === arc.p2[0] && arc.p1[1] === arc.p2[1]) {\n          removeStrum(arcs);\n        }\n\n        if (arc) {\n          var angle = arcs.startAngle(arcs.active);\n\n          arc.startAngle = angle;\n          arc.endAngle = angle;\n          arc.arc.\n          outerRadius(arcs.length(arcs.active)).\n          startAngle(angle).\n          endAngle(angle);\n        }\n\n        brushed = selected(arcs);\n        arcs.active = undefined;\n        __.brushed = brushed;\n        pc.renderBrushed();\n        events.brushend.call(pc, __.brushed);\n      };\n    }\n\n    function brushReset(arcs) {\n      return function () {\n        var ids = Object.getOwnPropertyNames(arcs).filter(function (d) {\n          return !isNaN(d);\n        });\n\n        ids.forEach(function (d) {\n          arcs.active = d;\n          removeStrum(arcs);\n        });\n        onDragEnd(arcs)();\n      };\n    }\n\n    function install() {\n      var drag = d3.behavior.drag();\n\n      // Map of current arcs. arcs are stored per segment of the PC. A segment,\n      // being the area between two axes. The left most area is indexed at 0.\n      arcs.active = undefined;\n      // Returns the width of the PC segment where currently a arc is being\n      // placed. NOTE: even though they are evenly spaced in our current\n      // implementation, we keep for when non-even spaced segments are supported as\n      // well.\n      arcs.width = function (id) {\n        var arc = arcs[id];\n\n        if (arc === undefined) {\n          return undefined;\n        }\n\n        return arc.maxX - arc.minX;\n      };\n\n      // returns angles in [-PI/2, PI/2]\n      angle = function (p1, p2) {\n        var a = p1[0] - p2[0],\n        b = p1[1] - p2[1],\n        c = hypothenuse(a, b);\n\n        return Math.asin(b / c);\n      };\n\n      // returns angles in [0, 2 * PI]\n      arcs.endAngle = function (id) {\n        var arc = arcs[id];\n        if (arc === undefined) {\n          return undefined;\n        }\n        var sAngle = angle(arc.p1, arc.p2),\n        uAngle = -sAngle + Math.PI / 2;\n\n        if (arc.p1[0] > arc.p2[0]) {\n          uAngle = 2 * Math.PI - uAngle;\n        }\n\n        return uAngle;\n      };\n\n      arcs.startAngle = function (id) {\n        var arc = arcs[id];\n        if (arc === undefined) {\n          return undefined;\n        }\n\n        var sAngle = angle(arc.p1, arc.p3),\n        uAngle = -sAngle + Math.PI / 2;\n\n        if (arc.p1[0] > arc.p3[0]) {\n          uAngle = 2 * Math.PI - uAngle;\n        }\n\n        return uAngle;\n      };\n\n      arcs.length = function (id) {\n        var arc = arcs[id];\n\n        if (arc === undefined) {\n          return undefined;\n        }\n\n        var a = arc.p1[0] - arc.p2[0],\n        b = arc.p1[1] - arc.p2[1],\n        c = hypothenuse(a, b);\n\n        return c;\n      };\n\n      pc.on('axesreorder.arcs', function () {\n        var ids = Object.getOwnPropertyNames(arcs).filter(function (d) {\n          return !isNaN(d);\n        });\n\n        // Checks if the first dimension is directly left of the second dimension.\n        function consecutive(first, second) {\n          var length = __.dimensions.length;\n          return __.dimensions.some(function (d, i) {\n            return d === first ?\n            i + i < length && __.dimensions[i + 1] === second :\n            false;\n          });\n        }\n\n        if (ids.length > 0) {\n          // We have some arcs, which might need to be removed.\n          ids.forEach(function (d) {\n            var dims = arcs[d].dims;\n            arcs.active = d;\n            // If the two dimensions of the current arc are not next to each other\n            // any more, than we'll need to remove the arc. Otherwise we keep it.\n            if (!consecutive(dims.left, dims.right)) {\n              removeStrum(arcs);\n            }\n          });\n          onDragEnd(arcs)();\n        }\n      });\n\n      // Add a new svg group in which we draw the arcs.\n      pc.selection.\n      select('svg').\n      append('g').\n      attr('id', 'arcs').\n      attr(\n      'transform',\n      'translate(' + __.margin.left + ',' + __.margin.top + ')');\n\n\n      // Install the required brushReset function\n      pc.brushReset = brushReset(arcs);\n\n      drag.\n      on('dragstart', onDragStart(arcs)).\n      on('drag', onDrag(arcs)).\n      on('dragend', onDragEnd(arcs));\n\n      // NOTE: The styling needs to be done here and not in the css. This is because\n      //       for 1D brushing, the canvas layers should not listen to\n      //       pointer-events.\n      strumRect = pc.selection.\n      select('svg').\n      insert('rect', 'g#arcs').\n      attr('id', 'arc-events').\n      attr('x', __.margin.left).\n      attr('y', __.margin.top).\n      attr('width', w()).\n      attr('height', h() + 2).\n      style('opacity', 0).\n      call(drag);\n    }\n\n    brush.modes['angular'] = {\n      install: install,\n      uninstall: function () {\n        pc.selection.select('svg').select('g#arcs').remove();\n        pc.selection.select('svg').select('rect#arc-events').remove();\n        pc.on('axesreorder.arcs', undefined);\n        delete pc.brushReset;\n\n        strumRect = undefined;\n      },\n      selected: selected,\n      brushState: function () {\n        return arcs;\n      } };\n\n  })();\n\n  pc.interactive = function () {\n    flags.interactive = true;\n    return this;\n  };\n\n  // expose a few objects\n  pc.xscale = xscale;\n  pc.yscale = yscale;\n  pc.ctx = ctx;\n  pc.canvas = canvas;\n  pc.g = function () {\n    return g;\n  };\n\n  // rescale for height, width and margins\n  // TODO currently assumes chart is brushable, and destroys old brushes\n  pc.resize = function () {\n    // selection size\n    pc.selection.\n    select('svg').\n    attr('width', __.width).\n    attr('height', __.height);\n    pc.svg.attr(\n    'transform',\n    'translate(' + __.margin.left + ',' + __.margin.top + ')');\n\n\n    // FIXME: the current brush state should pass through\n    if (flags.brushable) pc.brushReset();\n\n    // scales\n    pc.autoscale();\n\n    // axes, destroys old brushes.\n    if (g) pc.createAxes();\n    if (flags.brushable) pc.brushable();\n    if (flags.reorderable) pc.reorderable();\n\n    events.resize.call(this, {\n      width: __.width,\n      height: __.height,\n      margin: __.margin });\n\n    return this;\n  };\n\n  // highlight an array of data\n  pc.highlight = function (data) {\n    if (arguments.length === 0) {\n      return __.highlighted;\n    }\n\n    __.highlighted = data;\n    pc.clear('highlight');\n    d3.selectAll([canvas.foreground, canvas.brushed]).classed('faded', true);\n    data.forEach(path_highlight);\n    events.highlight.call(this, data);\n    return this;\n  };\n\n  // clear highlighting\n  pc.unhighlight = function () {\n    __.highlighted = [];\n    pc.clear('highlight');\n    d3.selectAll([canvas.foreground, canvas.brushed]).classed('faded', false);\n    return this;\n  };\n\n  // calculate 2d intersection of line a->b with line c->d\n  // points are objects with x and y properties\n  pc.intersection = function (a, b, c, d) {\n    return {\n      x:\n      ((a.x * b.y - a.y * b.x) * (c.x - d.x) -\n      (a.x - b.x) * (c.x * d.y - c.y * d.x)) / (\n      (a.x - b.x) * (c.y - d.y) - (a.y - b.y) * (c.x - d.x)),\n      y:\n      ((a.x * b.y - a.y * b.x) * (c.y - d.y) -\n      (a.y - b.y) * (c.x * d.y - c.y * d.x)) / (\n      (a.x - b.x) * (c.y - d.y) - (a.y - b.y) * (c.x - d.x)) };\n\n  };\n\n  function position(d) {\n    var v = dragging[d];\n    return v == null ? xscale(d) : v;\n  }\n  pc.version = '0.7.0';\n  // this descriptive text should live with other introspective methods\n  pc.toString = function () {\n    return (\n      'Parallel Coordinates: ' +\n      __.dimensions.length +\n      ' dimensions (' +\n      d3.keys(__.data[0]).length +\n      ' total) , ' +\n      __.data.length +\n      ' rows');\n\n  };\n\n  return pc;\n}; /* [LICENSE TBD] */ /* eslint-disable *//* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_default);\n\nd3.renderQueue = function (func) {\n  var _queue = [], // data to be rendered\n  _rate = 10, // number of calls per frame\n  _clear = function () {}, // clearing function\n  _i = 0; // current iteration\n\n  var rq = function (data) {\n    if (data) rq.data(data);\n    rq.invalidate();\n    _clear();\n    rq.render();\n  };\n\n  rq.render = function () {\n    _i = 0;\n    var valid = true;\n    rq.invalidate = function () {\n      valid = false;\n    };\n\n    function doFrame() {\n      if (!valid) return true;\n      if (_i > _queue.length) return true;\n\n      // Typical d3 behavior is to pass a data item *and* its index. As the\n      // render queue splits the original data set, we'll have to be slightly\n      // more carefull about passing the correct index with the data item.\n      var end = Math.min(_i + _rate, _queue.length);\n      for (var i = _i; i < end; i += 1) {\n        func(_queue[i], i);\n      }\n      _i += _rate;\n    }\n\n    d3.timer(doFrame);\n  };\n\n  rq.data = function (data) {\n    rq.invalidate();\n    _queue = data.slice(0);\n    return rq;\n  };\n\n  rq.rate = function (value) {\n    if (!arguments.length) return _rate;\n    _rate = value;\n    return rq;\n  };\n\n  rq.remaining = function () {\n    return _queue.length - _i;\n  };\n\n  // clear the canvas\n  rq.clear = function (func) {\n    if (!arguments.length) {\n      _clear();\n      return rq;\n    }\n    _clear = func;\n    return rq;\n  };\n\n  rq.invalidate = function () {};\n\n  return rq;\n};;(function () {var reactHotLoader = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default : undefined;if (!reactHotLoader) {return;}reactHotLoader.register(_default, \"default\", \"/app/superset-frontend/plugins/legacy-plugin-chart-parallel-coordinates/src/vendor/parcoords/d3.parcoords.js\");})();;(function () {var leaveModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.leaveModule : undefined;leaveModule && leaveModule(module);})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9wbHVnaW5zL2xlZ2FjeS1wbHVnaW4tY2hhcnQtcGFyYWxsZWwtY29vcmRpbmF0ZXMvc3JjL3ZlbmRvci9wYXJjb29yZHMvZDMucGFyY29vcmRzLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc3VwZXJzZXQvLi9wbHVnaW5zL2xlZ2FjeS1wbHVnaW4tY2hhcnQtcGFyYWxsZWwtY29vcmRpbmF0ZXMvc3JjL3ZlbmRvci9wYXJjb29yZHMvZDMucGFyY29vcmRzLmpzP2I2NGEiXSwic291cmNlc0NvbnRlbnQiOlsiLyogW0xJQ0VOU0UgVEJEXSAqL1xuLyogZXNsaW50LWRpc2FibGUgKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIChjb25maWcpIHtcbiAgdmFyIF9fID0ge1xuICAgIGRhdGE6IFtdLFxuICAgIGhpZ2hsaWdodGVkOiBbXSxcbiAgICBkaW1lbnNpb25zOiBbXSxcbiAgICBkaW1lbnNpb25UaXRsZXM6IHt9LFxuICAgIGRpbWVuc2lvblRpdGxlUm90YXRpb246IDAsXG4gICAgdHlwZXM6IHt9LFxuICAgIGJydXNoZWQ6IGZhbHNlLFxuICAgIGJydXNoZWRDb2xvcjogbnVsbCxcbiAgICBhbHBoYU9uQnJ1c2hlZDogMC4wLFxuICAgIG1vZGU6ICdkZWZhdWx0JyxcbiAgICByYXRlOiAyMCxcbiAgICB3aWR0aDogNjAwLFxuICAgIGhlaWdodDogMzAwLFxuICAgIG1hcmdpbjogeyB0b3A6IDI0LCByaWdodDogMCwgYm90dG9tOiAxMiwgbGVmdDogMCB9LFxuICAgIG51bGxWYWx1ZVNlcGFyYXRvcjogJ3VuZGVmaW5lZCcsIC8vIHNldCB0byBcInRvcFwiIG9yIFwiYm90dG9tXCJcbiAgICBudWxsVmFsdWVTZXBhcmF0b3JQYWRkaW5nOiB7IHRvcDogOCwgcmlnaHQ6IDAsIGJvdHRvbTogOCwgbGVmdDogMCB9LFxuICAgIGNvbG9yOiAnIzA2OScsXG4gICAgY29tcG9zaXRlOiAnc291cmNlLW92ZXInLFxuICAgIGFscGhhOiAwLjcsXG4gICAgYnVuZGxpbmdTdHJlbmd0aDogMC41LFxuICAgIGJ1bmRsZURpbWVuc2lvbjogbnVsbCxcbiAgICBzbW9vdGhuZXNzOiAwLjAsXG4gICAgc2hvd0NvbnRyb2xQb2ludHM6IGZhbHNlLFxuICAgIGhpZGVBeGlzOiBbXSxcbiAgfTtcblxuICBleHRlbmQoX18sIGNvbmZpZyk7XG5cbiAgdmFyIHBjID0gZnVuY3Rpb24gKHNlbGVjdGlvbikge1xuICAgIHNlbGVjdGlvbiA9IHBjLnNlbGVjdGlvbiA9IGQzLnNlbGVjdChzZWxlY3Rpb24pO1xuXG4gICAgX18ud2lkdGggPSBzZWxlY3Rpb25bMF1bMF0uY2xpZW50V2lkdGg7XG4gICAgX18uaGVpZ2h0ID0gc2VsZWN0aW9uWzBdWzBdLmNsaWVudEhlaWdodDtcblxuICAgIC8vIGNhbnZhcyBkYXRhIGxheWVyc1xuICAgIFsnbWFya3MnLCAnZm9yZWdyb3VuZCcsICdicnVzaGVkJywgJ2hpZ2hsaWdodCddLmZvckVhY2goZnVuY3Rpb24gKGxheWVyKSB7XG4gICAgICBjYW52YXNbbGF5ZXJdID0gc2VsZWN0aW9uLmFwcGVuZCgnY2FudmFzJykuYXR0cignY2xhc3MnLCBsYXllcilbMF1bMF07XG4gICAgICBjdHhbbGF5ZXJdID0gY2FudmFzW2xheWVyXS5nZXRDb250ZXh0KCcyZCcpO1xuICAgIH0pO1xuXG4gICAgLy8gc3ZnIHRpY2sgYW5kIGJydXNoIGxheWVyc1xuICAgIHBjLnN2ZyA9IHNlbGVjdGlvblxuICAgICAgLmFwcGVuZCgnc3ZnJylcbiAgICAgIC5hdHRyKCd3aWR0aCcsIF9fLndpZHRoKVxuICAgICAgLmF0dHIoJ2hlaWdodCcsIF9fLmhlaWdodClcbiAgICAgIC5hcHBlbmQoJ3N2ZzpnJylcbiAgICAgIC5hdHRyKFxuICAgICAgICAndHJhbnNmb3JtJyxcbiAgICAgICAgJ3RyYW5zbGF0ZSgnICsgX18ubWFyZ2luLmxlZnQgKyAnLCcgKyBfXy5tYXJnaW4udG9wICsgJyknLFxuICAgICAgKTtcblxuICAgIHJldHVybiBwYztcbiAgfTtcbiAgdmFyIGV2ZW50cyA9IGQzLmRpc3BhdGNoLmFwcGx5KFxuICAgICAgdGhpcyxcbiAgICAgIFtcbiAgICAgICAgJ3JlbmRlcicsXG4gICAgICAgICdyZXNpemUnLFxuICAgICAgICAnaGlnaGxpZ2h0JyxcbiAgICAgICAgJ2JydXNoJyxcbiAgICAgICAgJ2JydXNoZW5kJyxcbiAgICAgICAgJ2F4ZXNyZW9yZGVyJyxcbiAgICAgIF0uY29uY2F0KGQzLmtleXMoX18pKSxcbiAgICApLFxuICAgIHcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gX18ud2lkdGggLSBfXy5tYXJnaW4ucmlnaHQgLSBfXy5tYXJnaW4ubGVmdDtcbiAgICB9LFxuICAgIGggPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gX18uaGVpZ2h0IC0gX18ubWFyZ2luLnRvcCAtIF9fLm1hcmdpbi5ib3R0b207XG4gICAgfSxcbiAgICBmbGFncyA9IHtcbiAgICAgIGJydXNoYWJsZTogZmFsc2UsXG4gICAgICByZW9yZGVyYWJsZTogZmFsc2UsXG4gICAgICBheGVzOiBmYWxzZSxcbiAgICAgIGludGVyYWN0aXZlOiBmYWxzZSxcbiAgICAgIGRlYnVnOiBmYWxzZSxcbiAgICB9LFxuICAgIHhzY2FsZSA9IGQzLnNjYWxlLm9yZGluYWwoKSxcbiAgICB5c2NhbGUgPSB7fSxcbiAgICBkcmFnZ2luZyA9IHt9LFxuICAgIGxpbmUgPSBkMy5zdmcubGluZSgpLFxuICAgIGF4aXMgPSBkMy5zdmcuYXhpcygpLm9yaWVudCgnbGVmdCcpLnRpY2tzKDUpLFxuICAgIGcsIC8vIGdyb3VwcyBmb3IgYXhlcywgYnJ1c2hlc1xuICAgIGN0eCA9IHt9LFxuICAgIGNhbnZhcyA9IHt9LFxuICAgIGNsdXN0ZXJDZW50cm9pZHMgPSBbXTtcblxuICAvLyBzaWRlIGVmZmVjdHMgZm9yIHNldHRlcnNcbiAgdmFyIHNpZGVfZWZmZWN0cyA9IGQzLmRpc3BhdGNoXG4gICAgLmFwcGx5KHRoaXMsIGQzLmtleXMoX18pKVxuICAgIC5vbignY29tcG9zaXRlJywgZnVuY3Rpb24gKGQpIHtcbiAgICAgIGN0eC5mb3JlZ3JvdW5kLmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9IGQudmFsdWU7XG4gICAgICBjdHguYnJ1c2hlZC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSBkLnZhbHVlO1xuICAgIH0pXG4gICAgLm9uKCdhbHBoYScsIGZ1bmN0aW9uIChkKSB7XG4gICAgICBjdHguZm9yZWdyb3VuZC5nbG9iYWxBbHBoYSA9IGQudmFsdWU7XG4gICAgICBjdHguYnJ1c2hlZC5nbG9iYWxBbHBoYSA9IGQudmFsdWU7XG4gICAgfSlcbiAgICAub24oJ2JydXNoZWRDb2xvcicsIGZ1bmN0aW9uIChkKSB7XG4gICAgICBjdHguYnJ1c2hlZC5zdHJva2VTdHlsZSA9IGQudmFsdWU7XG4gICAgfSlcbiAgICAub24oJ3dpZHRoJywgZnVuY3Rpb24gKGQpIHtcbiAgICAgIHBjLnJlc2l6ZSgpO1xuICAgIH0pXG4gICAgLm9uKCdoZWlnaHQnLCBmdW5jdGlvbiAoZCkge1xuICAgICAgcGMucmVzaXplKCk7XG4gICAgfSlcbiAgICAub24oJ21hcmdpbicsIGZ1bmN0aW9uIChkKSB7XG4gICAgICBwYy5yZXNpemUoKTtcbiAgICB9KVxuICAgIC5vbigncmF0ZScsIGZ1bmN0aW9uIChkKSB7XG4gICAgICBicnVzaGVkUXVldWUucmF0ZShkLnZhbHVlKTtcbiAgICAgIGZvcmVncm91bmRRdWV1ZS5yYXRlKGQudmFsdWUpO1xuICAgIH0pXG4gICAgLm9uKCdkaW1lbnNpb25zJywgZnVuY3Rpb24gKGQpIHtcbiAgICAgIHhzY2FsZS5kb21haW4oX18uZGltZW5zaW9ucyk7XG4gICAgICBpZiAoZmxhZ3MuaW50ZXJhY3RpdmUpIHtcbiAgICAgICAgcGMucmVuZGVyKCkudXBkYXRlQXhlcygpO1xuICAgICAgfVxuICAgIH0pXG4gICAgLm9uKCdidW5kbGVEaW1lbnNpb24nLCBmdW5jdGlvbiAoZCkge1xuICAgICAgaWYgKCFfXy5kaW1lbnNpb25zLmxlbmd0aCkgcGMuZGV0ZWN0RGltZW5zaW9ucygpO1xuICAgICAgaWYgKCEoX18uZGltZW5zaW9uc1swXSBpbiB5c2NhbGUpKSBwYy5hdXRvc2NhbGUoKTtcbiAgICAgIGlmICh0eXBlb2YgZC52YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgaWYgKGQudmFsdWUgPCBfXy5kaW1lbnNpb25zLmxlbmd0aCkge1xuICAgICAgICAgIF9fLmJ1bmRsZURpbWVuc2lvbiA9IF9fLmRpbWVuc2lvbnNbZC52YWx1ZV07XG4gICAgICAgIH0gZWxzZSBpZiAoZC52YWx1ZSA8IF9fLmhpZGVBeGlzLmxlbmd0aCkge1xuICAgICAgICAgIF9fLmJ1bmRsZURpbWVuc2lvbiA9IF9fLmhpZGVBeGlzW2QudmFsdWVdO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfXy5idW5kbGVEaW1lbnNpb24gPSBkLnZhbHVlO1xuICAgICAgfVxuXG4gICAgICBfXy5jbHVzdGVyQ2VudHJvaWRzID0gY29tcHV0ZV9jbHVzdGVyX2NlbnRyb2lkcyhfXy5idW5kbGVEaW1lbnNpb24pO1xuICAgIH0pXG4gICAgLm9uKCdoaWRlQXhpcycsIGZ1bmN0aW9uIChkKSB7XG4gICAgICBpZiAoIV9fLmRpbWVuc2lvbnMubGVuZ3RoKSBwYy5kZXRlY3REaW1lbnNpb25zKCk7XG4gICAgICBwYy5kaW1lbnNpb25zKHdpdGhvdXQoX18uZGltZW5zaW9ucywgZC52YWx1ZSkpO1xuICAgIH0pO1xuXG4gIC8vIGV4cG9zZSB0aGUgc3RhdGUgb2YgdGhlIGNoYXJ0XG4gIHBjLnN0YXRlID0gX187XG4gIHBjLmZsYWdzID0gZmxhZ3M7XG5cbiAgLy8gY3JlYXRlIGdldHRlci9zZXR0ZXJzXG4gIGdldHNldChwYywgX18sIGV2ZW50cyk7XG5cbiAgLy8gZXhwb3NlIGV2ZW50c1xuICBkMy5yZWJpbmQocGMsIGV2ZW50cywgJ29uJyk7XG5cbiAgLy8gZ2V0dGVyL3NldHRlciB3aXRoIGV2ZW50IGZpcmluZ1xuICBmdW5jdGlvbiBnZXRzZXQob2JqLCBzdGF0ZSwgZXZlbnRzKSB7XG4gICAgZDMua2V5cyhzdGF0ZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICBvYmpba2V5XSA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICAgIHJldHVybiBzdGF0ZVtrZXldO1xuICAgICAgICB9XG4gICAgICAgIHZhciBvbGQgPSBzdGF0ZVtrZXldO1xuICAgICAgICBzdGF0ZVtrZXldID0geDtcbiAgICAgICAgc2lkZV9lZmZlY3RzW2tleV0uY2FsbChwYywgeyB2YWx1ZTogeCwgcHJldmlvdXM6IG9sZCB9KTtcbiAgICAgICAgZXZlbnRzW2tleV0uY2FsbChwYywgeyB2YWx1ZTogeCwgcHJldmlvdXM6IG9sZCB9KTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgIH07XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBleHRlbmQodGFyZ2V0LCBzb3VyY2UpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG4gICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgIH1cbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9XG5cbiAgZnVuY3Rpb24gd2l0aG91dChhcnIsIGl0ZW0pIHtcbiAgICByZXR1cm4gYXJyLmZpbHRlcihmdW5jdGlvbiAoZWxlbSkge1xuICAgICAgcmV0dXJuIGl0ZW0uaW5kZXhPZihlbGVtKSA9PT0gLTE7XG4gICAgfSk7XG4gIH1cbiAgLyoqIGFkanVzdHMgYW4gYXhpcycgZGVmYXVsdCByYW5nZSBbaCgpKzEsIDFdIGlmIGEgTnVsbFZhbHVlU2VwYXJhdG9yIGlzIHNldCAqL1xuICBmdW5jdGlvbiBnZXRSYW5nZSgpIHtcbiAgICBpZiAoX18ubnVsbFZhbHVlU2VwYXJhdG9yID09ICdib3R0b20nKSB7XG4gICAgICByZXR1cm4gW1xuICAgICAgICBoKCkgK1xuICAgICAgICAgIDEgLVxuICAgICAgICAgIF9fLm51bGxWYWx1ZVNlcGFyYXRvclBhZGRpbmcuYm90dG9tIC1cbiAgICAgICAgICBfXy5udWxsVmFsdWVTZXBhcmF0b3JQYWRkaW5nLnRvcCxcbiAgICAgICAgMSxcbiAgICAgIF07XG4gICAgfSBlbHNlIGlmIChfXy5udWxsVmFsdWVTZXBhcmF0b3IgPT0gJ3RvcCcpIHtcbiAgICAgIHJldHVybiBbXG4gICAgICAgIGgoKSArIDEsXG4gICAgICAgIDEgK1xuICAgICAgICAgIF9fLm51bGxWYWx1ZVNlcGFyYXRvclBhZGRpbmcuYm90dG9tICtcbiAgICAgICAgICBfXy5udWxsVmFsdWVTZXBhcmF0b3JQYWRkaW5nLnRvcCxcbiAgICAgIF07XG4gICAgfVxuICAgIHJldHVybiBbaCgpICsgMSwgMV07XG4gIH1cblxuICBwYy5hdXRvc2NhbGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgLy8geXNjYWxlXG4gICAgdmFyIGRlZmF1bHRTY2FsZXMgPSB7XG4gICAgICBkYXRlOiBmdW5jdGlvbiAoaykge1xuICAgICAgICB2YXIgZXh0ZW50ID0gZDMuZXh0ZW50KF9fLmRhdGEsIGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgcmV0dXJuIGRba10gPyBkW2tdLmdldFRpbWUoKSA6IG51bGw7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIHNwZWNpYWwgY2FzZSBpZiBzaW5nbGUgdmFsdWVcbiAgICAgICAgaWYgKGV4dGVudFswXSA9PT0gZXh0ZW50WzFdKSB7XG4gICAgICAgICAgcmV0dXJuIGQzLnNjYWxlLm9yZGluYWwoKS5kb21haW4oW2V4dGVudFswXV0pLnJhbmdlUG9pbnRzKGdldFJhbmdlKCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGQzLnRpbWUuc2NhbGUoKS5kb21haW4oZXh0ZW50KS5yYW5nZShnZXRSYW5nZSgpKTtcbiAgICAgIH0sXG4gICAgICBudW1iZXI6IGZ1bmN0aW9uIChrKSB7XG4gICAgICAgIHZhciBleHRlbnQgPSBkMy5leHRlbnQoX18uZGF0YSwgZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICByZXR1cm4gK2Rba107XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIHNwZWNpYWwgY2FzZSBpZiBzaW5nbGUgdmFsdWVcbiAgICAgICAgaWYgKGV4dGVudFswXSA9PT0gZXh0ZW50WzFdKSB7XG4gICAgICAgICAgcmV0dXJuIGQzLnNjYWxlLm9yZGluYWwoKS5kb21haW4oW2V4dGVudFswXV0pLnJhbmdlUG9pbnRzKGdldFJhbmdlKCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGQzLnNjYWxlLmxpbmVhcigpLmRvbWFpbihleHRlbnQpLnJhbmdlKGdldFJhbmdlKCkpO1xuICAgICAgfSxcbiAgICAgIHN0cmluZzogZnVuY3Rpb24gKGspIHtcbiAgICAgICAgdmFyIGNvdW50cyA9IHt9LFxuICAgICAgICAgIGRvbWFpbiA9IFtdO1xuXG4gICAgICAgIC8vIExldCdzIGdldCB0aGUgY291bnQgZm9yIGVhY2ggdmFsdWUgc28gdGhhdCB3ZSBjYW4gc29ydCB0aGUgZG9tYWluIGJhc2VkXG4gICAgICAgIC8vIG9uIHRoZSBudW1iZXIgb2YgaXRlbXMgZm9yIGVhY2ggdmFsdWUuXG4gICAgICAgIF9fLmRhdGEubWFwKGZ1bmN0aW9uIChwKSB7XG4gICAgICAgICAgaWYgKHBba10gPT09IHVuZGVmaW5lZCAmJiBfXy5udWxsVmFsdWVTZXBhcmF0b3IgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICByZXR1cm47IC8vIG51bGwgdmFsdWVzIHdpbGwgYmUgZHJhd24gYmV5b25kIHRoZSBob3Jpem9udGFsIG51bGwgdmFsdWUgc2VwYXJhdG9yIVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY291bnRzW3Bba11dID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvdW50c1twW2tdXSA9IDE7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvdW50c1twW2tdXSA9IGNvdW50c1twW2tdXSArIDE7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBkb21haW4gPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhjb3VudHMpLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICByZXR1cm4gY291bnRzW2FdIC0gY291bnRzW2JdO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gZDMuc2NhbGUub3JkaW5hbCgpLmRvbWFpbihkb21haW4pLnJhbmdlUG9pbnRzKGdldFJhbmdlKCkpO1xuICAgICAgfSxcbiAgICB9O1xuXG4gICAgX18uZGltZW5zaW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7XG4gICAgICB5c2NhbGVba10gPSBkZWZhdWx0U2NhbGVzW19fLnR5cGVzW2tdXShrKTtcbiAgICB9KTtcblxuICAgIF9fLmhpZGVBeGlzLmZvckVhY2goZnVuY3Rpb24gKGspIHtcbiAgICAgIHlzY2FsZVtrXSA9IGRlZmF1bHRTY2FsZXNbX18udHlwZXNba11dKGspO1xuICAgIH0pO1xuXG4gICAgLy8geHNjYWxlXG4gICAgeHNjYWxlLnJhbmdlUG9pbnRzKFswLCB3KCldLCAxKTtcblxuICAgIC8vIGNhbnZhcyBzaXplc1xuICAgIHBjLnNlbGVjdGlvblxuICAgICAgLnNlbGVjdEFsbCgnY2FudmFzJylcbiAgICAgIC5zdHlsZSgnbWFyZ2luLXRvcCcsIF9fLm1hcmdpbi50b3AgKyAncHgnKVxuICAgICAgLnN0eWxlKCdtYXJnaW4tbGVmdCcsIF9fLm1hcmdpbi5sZWZ0ICsgJ3B4JylcbiAgICAgIC5hdHRyKCd3aWR0aCcsIHcoKSArIDIpXG4gICAgICAuYXR0cignaGVpZ2h0JywgaCgpICsgMik7XG5cbiAgICAvLyBkZWZhdWx0IHN0eWxlcywgbmVlZHMgdG8gYmUgc2V0IHdoZW4gY2FudmFzIHdpZHRoIGNoYW5nZXNcbiAgICBjdHguZm9yZWdyb3VuZC5zdHJva2VTdHlsZSA9IF9fLmNvbG9yO1xuICAgIGN0eC5mb3JlZ3JvdW5kLmxpbmVXaWR0aCA9IDEuNDtcbiAgICBjdHguZm9yZWdyb3VuZC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSBfXy5jb21wb3NpdGU7XG4gICAgY3R4LmZvcmVncm91bmQuZ2xvYmFsQWxwaGEgPSBfXy5hbHBoYTtcbiAgICBjdHguYnJ1c2hlZC5zdHJva2VTdHlsZSA9IF9fLmJydXNoZWRDb2xvcjtcbiAgICBjdHguYnJ1c2hlZC5saW5lV2lkdGggPSAxLjQ7XG4gICAgY3R4LmJydXNoZWQuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gX18uY29tcG9zaXRlO1xuICAgIGN0eC5icnVzaGVkLmdsb2JhbEFscGhhID0gX18uYWxwaGE7XG4gICAgY3R4LmhpZ2hsaWdodC5saW5lV2lkdGggPSAzO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgcGMuc2NhbGUgPSBmdW5jdGlvbiAoZCwgZG9tYWluKSB7XG4gICAgeXNjYWxlW2RdLmRvbWFpbihkb21haW4pO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgcGMuZmxpcCA9IGZ1bmN0aW9uIChkKSB7XG4gICAgLy95c2NhbGVbZF0uZG9tYWluKCkucmV2ZXJzZSgpOyAgICAgICAgIC8vIGRvZXMgbm90IHdvcmtcbiAgICB5c2NhbGVbZF0uZG9tYWluKHlzY2FsZVtkXS5kb21haW4oKS5yZXZlcnNlKCkpOyAvLyB3b3Jrc1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgcGMuY29tbW9uU2NhbGUgPSBmdW5jdGlvbiAoZ2xvYmFsLCB0eXBlKSB7XG4gICAgdmFyIHQgPSB0eXBlIHx8ICdudW1iZXInO1xuICAgIGlmICh0eXBlb2YgZ2xvYmFsID09PSAndW5kZWZpbmVkJykge1xuICAgICAgZ2xvYmFsID0gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBzY2FsZXMgb2YgdGhlIHNhbWUgdHlwZVxuICAgIHZhciBzY2FsZXMgPSBfXy5kaW1lbnNpb25zLmNvbmNhdChfXy5oaWRlQXhpcykuZmlsdGVyKGZ1bmN0aW9uIChwKSB7XG4gICAgICByZXR1cm4gX18udHlwZXNbcF0gPT0gdDtcbiAgICB9KTtcblxuICAgIGlmIChnbG9iYWwpIHtcbiAgICAgIHZhciBleHRlbnQgPSBkMy5leHRlbnQoXG4gICAgICAgIHNjYWxlc1xuICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKHAsIGkpIHtcbiAgICAgICAgICAgIHJldHVybiB5c2NhbGVbcF0uZG9tYWluKCk7XG4gICAgICAgICAgfSlcbiAgICAgICAgICAucmVkdWNlKGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgICByZXR1cm4gYS5jb25jYXQoYik7XG4gICAgICAgICAgfSksXG4gICAgICApO1xuXG4gICAgICBzY2FsZXMuZm9yRWFjaChmdW5jdGlvbiAoZCkge1xuICAgICAgICB5c2NhbGVbZF0uZG9tYWluKGV4dGVudCk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2NhbGVzLmZvckVhY2goZnVuY3Rpb24gKGspIHtcbiAgICAgICAgeXNjYWxlW2tdLmRvbWFpbihcbiAgICAgICAgICBkMy5leHRlbnQoX18uZGF0YSwgZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICAgIHJldHVybiArZFtrXTtcbiAgICAgICAgICB9KSxcbiAgICAgICAgKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIHVwZGF0ZSBjZW50cm9pZHNcbiAgICBpZiAoX18uYnVuZGxlRGltZW5zaW9uICE9PSBudWxsKSB7XG4gICAgICBwYy5idW5kbGVEaW1lbnNpb24oX18uYnVuZGxlRGltZW5zaW9uKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgcGMuZGV0ZWN0RGltZW5zaW9ucyA9IGZ1bmN0aW9uICgpIHtcbiAgICBwYy50eXBlcyhwYy5kZXRlY3REaW1lbnNpb25UeXBlcyhfXy5kYXRhKSk7XG4gICAgcGMuZGltZW5zaW9ucyhkMy5rZXlzKHBjLnR5cGVzKCkpKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvLyBhIGJldHRlciBcInR5cGVvZlwiIGZyb20gdGhpcyBwb3N0OiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzczOTA0MjYvYmV0dGVyLXdheS10by1nZXQtdHlwZS1vZi1hLWphdmFzY3JpcHQtdmFyaWFibGVcbiAgcGMudG9UeXBlID0gZnVuY3Rpb24gKHYpIHtcbiAgICByZXR1cm4ge30udG9TdHJpbmdcbiAgICAgIC5jYWxsKHYpXG4gICAgICAubWF0Y2goL1xccyhbYS16QS1aXSspLylbMV1cbiAgICAgIC50b0xvd2VyQ2FzZSgpO1xuICB9O1xuXG4gIC8vIHRyeSB0byBjb2VyY2UgdG8gbnVtYmVyIGJlZm9yZSByZXR1cm5pbmcgdHlwZVxuICBwYy50b1R5cGVDb2VyY2VOdW1iZXJzID0gZnVuY3Rpb24gKHYpIHtcbiAgICBpZiAocGFyc2VGbG9hdCh2KSA9PSB2ICYmIHYgIT0gbnVsbCkge1xuICAgICAgcmV0dXJuICdudW1iZXInO1xuICAgIH1cbiAgICByZXR1cm4gcGMudG9UeXBlKHYpO1xuICB9O1xuXG4gIC8vIGF0dGVtcHQgdG8gZGV0ZXJtaW5lIHR5cGVzIG9mIGVhY2ggZGltZW5zaW9uIGJhc2VkIG9uIGZpcnN0IHJvdyBvZiBkYXRhXG4gIHBjLmRldGVjdERpbWVuc2lvblR5cGVzID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICB2YXIgdHlwZXMgPSB7fTtcbiAgICBkMy5rZXlzKGRhdGFbMF0pLmZvckVhY2goZnVuY3Rpb24gKGNvbCkge1xuICAgICAgdHlwZXNbY29sXSA9IHBjLnRvVHlwZUNvZXJjZU51bWJlcnMoZGF0YVswXVtjb2xdKTtcbiAgICB9KTtcbiAgICByZXR1cm4gdHlwZXM7XG4gIH07XG4gIHBjLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAvLyB0cnkgdG8gYXV0b2RldGVjdCBkaW1lbnNpb25zIGFuZCBjcmVhdGUgc2NhbGVzXG4gICAgaWYgKCFfXy5kaW1lbnNpb25zLmxlbmd0aCkgcGMuZGV0ZWN0RGltZW5zaW9ucygpO1xuICAgIGlmICghKF9fLmRpbWVuc2lvbnNbMF0gaW4geXNjYWxlKSkgcGMuYXV0b3NjYWxlKCk7XG5cbiAgICBwYy5yZW5kZXJbX18ubW9kZV0oKTtcblxuICAgIGV2ZW50cy5yZW5kZXIuY2FsbCh0aGlzKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBwYy5yZW5kZXJCcnVzaGVkID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICghX18uZGltZW5zaW9ucy5sZW5ndGgpIHBjLmRldGVjdERpbWVuc2lvbnMoKTtcbiAgICBpZiAoIShfXy5kaW1lbnNpb25zWzBdIGluIHlzY2FsZSkpIHBjLmF1dG9zY2FsZSgpO1xuXG4gICAgcGMucmVuZGVyQnJ1c2hlZFtfXy5tb2RlXSgpO1xuXG4gICAgZXZlbnRzLnJlbmRlci5jYWxsKHRoaXMpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIGZ1bmN0aW9uIGlzQnJ1c2hlZCgpIHtcbiAgICBpZiAoX18uYnJ1c2hlZCAmJiBfXy5icnVzaGVkLmxlbmd0aCAhPT0gX18uZGF0YS5sZW5ndGgpIHJldHVybiB0cnVlO1xuXG4gICAgdmFyIG9iamVjdCA9IGJydXNoLmN1cnJlbnRNb2RlKCkuYnJ1c2hTdGF0ZSgpO1xuXG4gICAgZm9yICh2YXIga2V5IGluIG9iamVjdCkge1xuICAgICAgaWYgKG9iamVjdC5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBwYy5yZW5kZXIuZGVmYXVsdCA9IGZ1bmN0aW9uICgpIHtcbiAgICBwYy5jbGVhcignZm9yZWdyb3VuZCcpO1xuICAgIHBjLmNsZWFyKCdoaWdobGlnaHQnKTtcblxuICAgIHBjLnJlbmRlckJydXNoZWQuZGVmYXVsdCgpO1xuXG4gICAgX18uZGF0YS5mb3JFYWNoKHBhdGhfZm9yZWdyb3VuZCk7XG4gIH07XG5cbiAgdmFyIGZvcmVncm91bmRRdWV1ZSA9IGQzXG4gICAgLnJlbmRlclF1ZXVlKHBhdGhfZm9yZWdyb3VuZClcbiAgICAucmF0ZSg1MClcbiAgICAuY2xlYXIoZnVuY3Rpb24gKCkge1xuICAgICAgcGMuY2xlYXIoJ2ZvcmVncm91bmQnKTtcbiAgICAgIHBjLmNsZWFyKCdoaWdobGlnaHQnKTtcbiAgICB9KTtcblxuICBwYy5yZW5kZXIucXVldWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgcGMucmVuZGVyQnJ1c2hlZC5xdWV1ZSgpO1xuXG4gICAgZm9yZWdyb3VuZFF1ZXVlKF9fLmRhdGEpO1xuICB9O1xuXG4gIHBjLnJlbmRlckJydXNoZWQuZGVmYXVsdCA9IGZ1bmN0aW9uICgpIHtcbiAgICBwYy5jbGVhcignYnJ1c2hlZCcpO1xuXG4gICAgaWYgKGlzQnJ1c2hlZCgpKSB7XG4gICAgICBfXy5icnVzaGVkLmZvckVhY2gocGF0aF9icnVzaGVkKTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIGJydXNoZWRRdWV1ZSA9IGQzXG4gICAgLnJlbmRlclF1ZXVlKHBhdGhfYnJ1c2hlZClcbiAgICAucmF0ZSg1MClcbiAgICAuY2xlYXIoZnVuY3Rpb24gKCkge1xuICAgICAgcGMuY2xlYXIoJ2JydXNoZWQnKTtcbiAgICB9KTtcblxuICBwYy5yZW5kZXJCcnVzaGVkLnF1ZXVlID0gZnVuY3Rpb24gKCkge1xuICAgIGlmIChpc0JydXNoZWQoKSkge1xuICAgICAgYnJ1c2hlZFF1ZXVlKF9fLmJydXNoZWQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBicnVzaGVkUXVldWUoW10pOyAvLyBUaGlzIGlzIG5lZWRlZCB0byBjbGVhciB0aGUgY3VycmVudGx5IGJydXNoZWQgaXRlbXNcbiAgICB9XG4gIH07XG4gIGZ1bmN0aW9uIGNvbXB1dGVfY2x1c3Rlcl9jZW50cm9pZHMoZCkge1xuICAgIHZhciBjbHVzdGVyQ2VudHJvaWRzID0gZDMubWFwKCk7XG4gICAgdmFyIGNsdXN0ZXJDb3VudHMgPSBkMy5tYXAoKTtcbiAgICAvLyBkZXRlcm1pbmUgY2x1c3RlckNvdW50c1xuICAgIF9fLmRhdGEuZm9yRWFjaChmdW5jdGlvbiAocm93KSB7XG4gICAgICB2YXIgc2NhbGVkID0geXNjYWxlW2RdKHJvd1tkXSk7XG4gICAgICBpZiAoIWNsdXN0ZXJDb3VudHMuaGFzKHNjYWxlZCkpIHtcbiAgICAgICAgY2x1c3RlckNvdW50cy5zZXQoc2NhbGVkLCAwKTtcbiAgICAgIH1cbiAgICAgIHZhciBjb3VudCA9IGNsdXN0ZXJDb3VudHMuZ2V0KHNjYWxlZCk7XG4gICAgICBjbHVzdGVyQ291bnRzLnNldChzY2FsZWQsIGNvdW50ICsgMSk7XG4gICAgfSk7XG5cbiAgICBfXy5kYXRhLmZvckVhY2goZnVuY3Rpb24gKHJvdykge1xuICAgICAgX18uZGltZW5zaW9ucy5tYXAoZnVuY3Rpb24gKHAsIGkpIHtcbiAgICAgICAgdmFyIHNjYWxlZCA9IHlzY2FsZVtkXShyb3dbZF0pO1xuICAgICAgICBpZiAoIWNsdXN0ZXJDZW50cm9pZHMuaGFzKHNjYWxlZCkpIHtcbiAgICAgICAgICB2YXIgbWFwID0gZDMubWFwKCk7XG4gICAgICAgICAgY2x1c3RlckNlbnRyb2lkcy5zZXQoc2NhbGVkLCBtYXApO1xuICAgICAgICB9XG4gICAgICAgIGlmICghY2x1c3RlckNlbnRyb2lkcy5nZXQoc2NhbGVkKS5oYXMocCkpIHtcbiAgICAgICAgICBjbHVzdGVyQ2VudHJvaWRzLmdldChzY2FsZWQpLnNldChwLCAwKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdmFsdWUgPSBjbHVzdGVyQ2VudHJvaWRzLmdldChzY2FsZWQpLmdldChwKTtcbiAgICAgICAgdmFsdWUgKz0geXNjYWxlW3BdKHJvd1twXSkgLyBjbHVzdGVyQ291bnRzLmdldChzY2FsZWQpO1xuICAgICAgICBjbHVzdGVyQ2VudHJvaWRzLmdldChzY2FsZWQpLnNldChwLCB2YWx1ZSk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIHJldHVybiBjbHVzdGVyQ2VudHJvaWRzO1xuICB9XG5cbiAgZnVuY3Rpb24gY29tcHV0ZV9jZW50cm9pZHMocm93KSB7XG4gICAgdmFyIGNlbnRyb2lkcyA9IFtdO1xuXG4gICAgdmFyIHAgPSBfXy5kaW1lbnNpb25zO1xuICAgIHZhciBjb2xzID0gcC5sZW5ndGg7XG4gICAgdmFyIGEgPSAwLjU7IC8vIGNlbnRlciBiZXR3ZWVuIGF4ZXNcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbHM7ICsraSkge1xuICAgICAgLy8gY2VudHJvaWRzIG9uICdyZWFsJyBheGVzXG4gICAgICB2YXIgeCA9IHBvc2l0aW9uKHBbaV0pO1xuICAgICAgdmFyIHkgPSB5c2NhbGVbcFtpXV0ocm93W3BbaV1dKTtcbiAgICAgIGNlbnRyb2lkcy5wdXNoKCRWKFt4LCB5XSkpO1xuXG4gICAgICAvLyBjZW50cm9pZHMgb24gJ3ZpcnR1YWwnIGF4ZXNcbiAgICAgIGlmIChpIDwgY29scyAtIDEpIHtcbiAgICAgICAgdmFyIGN4ID0geCArIGEgKiAocG9zaXRpb24ocFtpICsgMV0pIC0geCk7XG4gICAgICAgIHZhciBjeSA9IHkgKyBhICogKHlzY2FsZVtwW2kgKyAxXV0ocm93W3BbaSArIDFdXSkgLSB5KTtcbiAgICAgICAgaWYgKF9fLmJ1bmRsZURpbWVuc2lvbiAhPT0gbnVsbCkge1xuICAgICAgICAgIHZhciBsZWZ0Q2VudHJvaWQgPSBfXy5jbHVzdGVyQ2VudHJvaWRzXG4gICAgICAgICAgICAuZ2V0KHlzY2FsZVtfXy5idW5kbGVEaW1lbnNpb25dKHJvd1tfXy5idW5kbGVEaW1lbnNpb25dKSlcbiAgICAgICAgICAgIC5nZXQocFtpXSk7XG4gICAgICAgICAgdmFyIHJpZ2h0Q2VudHJvaWQgPSBfXy5jbHVzdGVyQ2VudHJvaWRzXG4gICAgICAgICAgICAuZ2V0KHlzY2FsZVtfXy5idW5kbGVEaW1lbnNpb25dKHJvd1tfXy5idW5kbGVEaW1lbnNpb25dKSlcbiAgICAgICAgICAgIC5nZXQocFtpICsgMV0pO1xuICAgICAgICAgIHZhciBjZW50cm9pZCA9IDAuNSAqIChsZWZ0Q2VudHJvaWQgKyByaWdodENlbnRyb2lkKTtcbiAgICAgICAgICBjeSA9IGNlbnRyb2lkICsgKDEgLSBfXy5idW5kbGluZ1N0cmVuZ3RoKSAqIChjeSAtIGNlbnRyb2lkKTtcbiAgICAgICAgfVxuICAgICAgICBjZW50cm9pZHMucHVzaCgkVihbY3gsIGN5XSkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBjZW50cm9pZHM7XG4gIH1cblxuICBmdW5jdGlvbiBjb21wdXRlX2NvbnRyb2xfcG9pbnRzKGNlbnRyb2lkcykge1xuICAgIHZhciBjb2xzID0gY2VudHJvaWRzLmxlbmd0aDtcbiAgICB2YXIgYSA9IF9fLnNtb290aG5lc3M7XG4gICAgdmFyIGNwcyA9IFtdO1xuXG4gICAgY3BzLnB1c2goY2VudHJvaWRzWzBdKTtcbiAgICBjcHMucHVzaChcbiAgICAgICRWKFtcbiAgICAgICAgY2VudHJvaWRzWzBdLmUoMSkgKyBhICogMiAqIChjZW50cm9pZHNbMV0uZSgxKSAtIGNlbnRyb2lkc1swXS5lKDEpKSxcbiAgICAgICAgY2VudHJvaWRzWzBdLmUoMiksXG4gICAgICBdKSxcbiAgICApO1xuICAgIGZvciAodmFyIGNvbCA9IDE7IGNvbCA8IGNvbHMgLSAxOyArK2NvbCkge1xuICAgICAgdmFyIG1pZCA9IGNlbnRyb2lkc1tjb2xdO1xuICAgICAgdmFyIGxlZnQgPSBjZW50cm9pZHNbY29sIC0gMV07XG4gICAgICB2YXIgcmlnaHQgPSBjZW50cm9pZHNbY29sICsgMV07XG5cbiAgICAgIHZhciBkaWZmID0gbGVmdC5zdWJ0cmFjdChyaWdodCk7XG4gICAgICBjcHMucHVzaChtaWQuYWRkKGRpZmYueChhKSkpO1xuICAgICAgY3BzLnB1c2gobWlkKTtcbiAgICAgIGNwcy5wdXNoKG1pZC5zdWJ0cmFjdChkaWZmLngoYSkpKTtcbiAgICB9XG4gICAgY3BzLnB1c2goXG4gICAgICAkVihbXG4gICAgICAgIGNlbnRyb2lkc1tjb2xzIC0gMV0uZSgxKSArXG4gICAgICAgICAgYSAqIDIgKiAoY2VudHJvaWRzW2NvbHMgLSAyXS5lKDEpIC0gY2VudHJvaWRzW2NvbHMgLSAxXS5lKDEpKSxcbiAgICAgICAgY2VudHJvaWRzW2NvbHMgLSAxXS5lKDIpLFxuICAgICAgXSksXG4gICAgKTtcbiAgICBjcHMucHVzaChjZW50cm9pZHNbY29scyAtIDFdKTtcblxuICAgIHJldHVybiBjcHM7XG4gIH1cblxuICBwYy5zaGFkb3dzID0gZnVuY3Rpb24gKCkge1xuICAgIGZsYWdzLnNoYWRvd3MgPSB0cnVlO1xuICAgIHBjLmFscGhhT25CcnVzaGVkKDAuMSk7XG4gICAgcGMucmVuZGVyKCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLy8gZHJhdyBkb3RzIHdpdGggcmFkaXVzIHIgb24gdGhlIGF4aXMgbGluZSB3aGVyZSBkYXRhIGludGVyc2VjdHNcbiAgcGMuYXhpc0RvdHMgPSBmdW5jdGlvbiAocikge1xuICAgIHZhciByID0gciB8fCAwLjE7XG4gICAgdmFyIGN0eCA9IHBjLmN0eC5tYXJrcztcbiAgICB2YXIgc3RhcnRBbmdsZSA9IDA7XG4gICAgdmFyIGVuZEFuZ2xlID0gMiAqIE1hdGguUEk7XG4gICAgY3R4Lmdsb2JhbEFscGhhID0gZDMubWluKFsxIC8gTWF0aC5wb3coX18uZGF0YS5sZW5ndGgsIDEgLyAyKSwgMV0pO1xuICAgIF9fLmRhdGEuZm9yRWFjaChmdW5jdGlvbiAoZCkge1xuICAgICAgX18uZGltZW5zaW9ucy5tYXAoZnVuY3Rpb24gKHAsIGkpIHtcbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICBjdHguYXJjKHBvc2l0aW9uKHApLCB5c2NhbGVbcF0oZFtwXSksIHIsIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlKTtcbiAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgICBjdHguZmlsbCgpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLy8gZHJhdyBzaW5nbGUgY3ViaWMgYmV6aWVyIGN1cnZlXG4gIGZ1bmN0aW9uIHNpbmdsZV9jdXJ2ZShkLCBjdHgpIHtcbiAgICB2YXIgY2VudHJvaWRzID0gY29tcHV0ZV9jZW50cm9pZHMoZCk7XG4gICAgdmFyIGNwcyA9IGNvbXB1dGVfY29udHJvbF9wb2ludHMoY2VudHJvaWRzKTtcblxuICAgIGN0eC5tb3ZlVG8oY3BzWzBdLmUoMSksIGNwc1swXS5lKDIpKTtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IGNwcy5sZW5ndGg7IGkgKz0gMykge1xuICAgICAgaWYgKF9fLnNob3dDb250cm9sUG9pbnRzKSB7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgMzsgaiArPSAxKSB7XG4gICAgICAgICAgY3R4LmZpbGxSZWN0KGNwc1tpICsgal0uZSgxKSwgY3BzW2kgKyBqXS5lKDIpLCAyLCAyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY3R4LmJlemllckN1cnZlVG8oXG4gICAgICAgIGNwc1tpXS5lKDEpLFxuICAgICAgICBjcHNbaV0uZSgyKSxcbiAgICAgICAgY3BzW2kgKyAxXS5lKDEpLFxuICAgICAgICBjcHNbaSArIDFdLmUoMiksXG4gICAgICAgIGNwc1tpICsgMl0uZSgxKSxcbiAgICAgICAgY3BzW2kgKyAyXS5lKDIpLFxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICAvLyBkcmF3IHNpbmdsZSBwb2x5bGluZVxuICBmdW5jdGlvbiBjb2xvcl9wYXRoKGQsIGN0eCkge1xuICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICBpZiAoXG4gICAgICAoX18uYnVuZGxlRGltZW5zaW9uICE9PSBudWxsICYmIF9fLmJ1bmRsaW5nU3RyZW5ndGggPiAwKSB8fFxuICAgICAgX18uc21vb3RobmVzcyA+IDBcbiAgICApIHtcbiAgICAgIHNpbmdsZV9jdXJ2ZShkLCBjdHgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzaW5nbGVfcGF0aChkLCBjdHgpO1xuICAgIH1cbiAgICBjdHguc3Ryb2tlKCk7XG4gIH1cblxuICAvLyBkcmF3IG1hbnkgcG9seWxpbmVzIG9mIHRoZSBzYW1lIGNvbG9yXG4gIGZ1bmN0aW9uIHBhdGhzKGRhdGEsIGN0eCkge1xuICAgIGN0eC5jbGVhclJlY3QoLTEsIC0xLCB3KCkgKyAyLCBoKCkgKyAyKTtcbiAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgZGF0YS5mb3JFYWNoKGZ1bmN0aW9uIChkKSB7XG4gICAgICBpZiAoXG4gICAgICAgIChfXy5idW5kbGVEaW1lbnNpb24gIT09IG51bGwgJiYgX18uYnVuZGxpbmdTdHJlbmd0aCA+IDApIHx8XG4gICAgICAgIF9fLnNtb290aG5lc3MgPiAwXG4gICAgICApIHtcbiAgICAgICAgc2luZ2xlX2N1cnZlKGQsIGN0eCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzaW5nbGVfcGF0aChkLCBjdHgpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGN0eC5zdHJva2UoKTtcbiAgfVxuXG4gIC8vIHJldHVybnMgdGhlIHktcG9zaXRpb24ganVzdCBiZXlvbmQgdGhlIHNlcGFyYXRpbmcgbnVsbCB2YWx1ZSBsaW5lXG4gIGZ1bmN0aW9uIGdldE51bGxQb3NpdGlvbigpIHtcbiAgICBpZiAoX18ubnVsbFZhbHVlU2VwYXJhdG9yID09ICdib3R0b20nKSB7XG4gICAgICByZXR1cm4gaCgpICsgMTtcbiAgICB9IGVsc2UgaWYgKF9fLm51bGxWYWx1ZVNlcGFyYXRvciA9PSAndG9wJykge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnNvbGUubG9nKFxuICAgICAgICBcIkEgdmFsdWUgaXMgTlVMTCwgYnV0IG51bGxWYWx1ZVNlcGFyYXRvciBpcyBub3Qgc2V0OyBzZXQgaXQgdG8gJ2JvdHRvbScgb3IgJ3RvcCcuXCIsXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gaCgpICsgMTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNpbmdsZV9wYXRoKGQsIGN0eCkge1xuICAgIF9fLmRpbWVuc2lvbnMubWFwKGZ1bmN0aW9uIChwLCBpKSB7XG4gICAgICBpZiAoaSA9PSAwKSB7XG4gICAgICAgIGN0eC5tb3ZlVG8oXG4gICAgICAgICAgcG9zaXRpb24ocCksXG4gICAgICAgICAgdHlwZW9mIGRbcF0gPT0gJ3VuZGVmaW5lZCcgPyBnZXROdWxsUG9zaXRpb24oKSA6IHlzY2FsZVtwXShkW3BdKSxcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGN0eC5saW5lVG8oXG4gICAgICAgICAgcG9zaXRpb24ocCksXG4gICAgICAgICAgdHlwZW9mIGRbcF0gPT0gJ3VuZGVmaW5lZCcgPyBnZXROdWxsUG9zaXRpb24oKSA6IHlzY2FsZVtwXShkW3BdKSxcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhdGhfYnJ1c2hlZChkLCBpKSB7XG4gICAgaWYgKF9fLmJydXNoZWRDb2xvciAhPT0gbnVsbCkge1xuICAgICAgY3R4LmJydXNoZWQuc3Ryb2tlU3R5bGUgPSBkMy5mdW5jdG9yKF9fLmJydXNoZWRDb2xvcikoZCwgaSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGN0eC5icnVzaGVkLnN0cm9rZVN0eWxlID0gZDMuZnVuY3RvcihfXy5jb2xvcikoZCwgaSk7XG4gICAgfVxuICAgIHJldHVybiBjb2xvcl9wYXRoKGQsIGN0eC5icnVzaGVkKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhdGhfZm9yZWdyb3VuZChkLCBpKSB7XG4gICAgY3R4LmZvcmVncm91bmQuc3Ryb2tlU3R5bGUgPSBkMy5mdW5jdG9yKF9fLmNvbG9yKShkLCBpKTtcbiAgICByZXR1cm4gY29sb3JfcGF0aChkLCBjdHguZm9yZWdyb3VuZCk7XG4gIH1cblxuICBmdW5jdGlvbiBwYXRoX2hpZ2hsaWdodChkLCBpKSB7XG4gICAgY3R4LmhpZ2hsaWdodC5zdHJva2VTdHlsZSA9IGQzLmZ1bmN0b3IoX18uY29sb3IpKGQsIGkpO1xuICAgIHJldHVybiBjb2xvcl9wYXRoKGQsIGN0eC5oaWdobGlnaHQpO1xuICB9XG4gIHBjLmNsZWFyID0gZnVuY3Rpb24gKGxheWVyKSB7XG4gICAgY3R4W2xheWVyXS5jbGVhclJlY3QoMCwgMCwgdygpICsgMiwgaCgpICsgMik7XG5cbiAgICAvLyBUaGlzIHdpbGwgbWFrZSBzdXJlIHRoYXQgdGhlIGZvcmVncm91bmQgaXRlbXMgYXJlIHRyYW5zcGFyZW50XG4gICAgLy8gd2l0aG91dCB0aGUgbmVlZCBmb3IgY2hhbmdpbmcgdGhlIG9wYWNpdHkgc3R5bGUgb2YgdGhlIGZvcmVncm91bmQgY2FudmFzXG4gICAgLy8gYXMgdGhpcyB3b3VsZCBzdG9wIHRoZSBjc3Mgc3R5bGluZyBmcm9tIHdvcmtpbmdcbiAgICBpZiAobGF5ZXIgPT09ICdicnVzaGVkJyAmJiBpc0JydXNoZWQoKSkge1xuICAgICAgY3R4LmJydXNoZWQuZmlsbFN0eWxlID0gcGMuc2VsZWN0aW9uLnN0eWxlKCdiYWNrZ3JvdW5kLWNvbG9yJyk7XG4gICAgICBjdHguYnJ1c2hlZC5nbG9iYWxBbHBoYSA9IDEgLSBfXy5hbHBoYU9uQnJ1c2hlZDtcbiAgICAgIGN0eC5icnVzaGVkLmZpbGxSZWN0KDAsIDAsIHcoKSArIDIsIGgoKSArIDIpO1xuICAgICAgY3R4LmJydXNoZWQuZ2xvYmFsQWxwaGEgPSBfXy5hbHBoYTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgZDMucmViaW5kKFxuICAgIHBjLFxuICAgIGF4aXMsXG4gICAgJ3RpY2tzJyxcbiAgICAnb3JpZW50JyxcbiAgICAndGlja1ZhbHVlcycsXG4gICAgJ3RpY2tTdWJkaXZpZGUnLFxuICAgICd0aWNrU2l6ZScsXG4gICAgJ3RpY2tQYWRkaW5nJyxcbiAgICAndGlja0Zvcm1hdCcsXG4gICk7XG5cbiAgZnVuY3Rpb24gZmxpcEF4aXNBbmRVcGRhdGVQQ1AoZGltZW5zaW9uKSB7XG4gICAgdmFyIGcgPSBwYy5zdmcuc2VsZWN0QWxsKCcuZGltZW5zaW9uJyk7XG5cbiAgICBwYy5mbGlwKGRpbWVuc2lvbik7XG5cbiAgICBkMy5zZWxlY3QodGhpcy5wYXJlbnRFbGVtZW50KVxuICAgICAgLnRyYW5zaXRpb24oKVxuICAgICAgLmR1cmF0aW9uKDExMDApXG4gICAgICAuY2FsbChheGlzLnNjYWxlKHlzY2FsZVtkaW1lbnNpb25dKSk7XG5cbiAgICBwYy5yZW5kZXIoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJvdGF0ZUxhYmVscygpIHtcbiAgICB2YXIgZGVsdGEgPSBkMy5ldmVudC5kZWx0YVk7XG4gICAgZGVsdGEgPSBkZWx0YSA8IDAgPyAtNSA6IGRlbHRhO1xuICAgIGRlbHRhID0gZGVsdGEgPiAwID8gNSA6IGRlbHRhO1xuXG4gICAgX18uZGltZW5zaW9uVGl0bGVSb3RhdGlvbiArPSBkZWx0YTtcbiAgICBwYy5zdmdcbiAgICAgIC5zZWxlY3RBbGwoJ3RleHQubGFiZWwnKVxuICAgICAgLmF0dHIoXG4gICAgICAgICd0cmFuc2Zvcm0nLFxuICAgICAgICAndHJhbnNsYXRlKDAsLTUpIHJvdGF0ZSgnICsgX18uZGltZW5zaW9uVGl0bGVSb3RhdGlvbiArICcpJyxcbiAgICAgICk7XG4gICAgZDMuZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRpbWVuc2lvbkxhYmVscyhkKSB7XG4gICAgcmV0dXJuIGQgaW4gX18uZGltZW5zaW9uVGl0bGVzID8gX18uZGltZW5zaW9uVGl0bGVzW2RdIDogZDsgLy8gZGltZW5zaW9uIGRpc3BsYXkgbmFtZXNcbiAgfVxuXG4gIHBjLmNyZWF0ZUF4ZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGcpIHBjLnJlbW92ZUF4ZXMoKTtcblxuICAgIC8vIEFkZCBhIGdyb3VwIGVsZW1lbnQgZm9yIGVhY2ggZGltZW5zaW9uLlxuICAgIGcgPSBwYy5zdmdcbiAgICAgIC5zZWxlY3RBbGwoJy5kaW1lbnNpb24nKVxuICAgICAgLmRhdGEoX18uZGltZW5zaW9ucywgZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgcmV0dXJuIGQ7XG4gICAgICB9KVxuICAgICAgLmVudGVyKClcbiAgICAgIC5hcHBlbmQoJ3N2ZzpnJylcbiAgICAgIC5hdHRyKCdjbGFzcycsICdkaW1lbnNpb24nKVxuICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsIGZ1bmN0aW9uIChkKSB7XG4gICAgICAgIHJldHVybiAndHJhbnNsYXRlKCcgKyB4c2NhbGUoZCkgKyAnKSc7XG4gICAgICB9KTtcblxuICAgIC8vIEFkZCBhbiBheGlzIGFuZCB0aXRsZS5cbiAgICBnLmFwcGVuZCgnc3ZnOmcnKVxuICAgICAgLmF0dHIoJ2NsYXNzJywgJ2F4aXMnKVxuICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoMCwwKScpXG4gICAgICAuZWFjaChmdW5jdGlvbiAoZCkge1xuICAgICAgICBkMy5zZWxlY3QodGhpcykuY2FsbChheGlzLnNjYWxlKHlzY2FsZVtkXSkpO1xuICAgICAgfSlcbiAgICAgIC5hcHBlbmQoJ3N2Zzp0ZXh0JylcbiAgICAgIC5hdHRyKHtcbiAgICAgICAgJ3RleHQtYW5jaG9yJzogJ21pZGRsZScsXG4gICAgICAgIHk6IDAsXG4gICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZSgwLC01KSByb3RhdGUoJyArIF9fLmRpbWVuc2lvblRpdGxlUm90YXRpb24gKyAnKScsXG4gICAgICAgIHg6IDAsXG4gICAgICAgIGNsYXNzOiAnbGFiZWwnLFxuICAgICAgfSlcbiAgICAgIC50ZXh0KGRpbWVuc2lvbkxhYmVscylcbiAgICAgIC5vbignZGJsY2xpY2snLCBmbGlwQXhpc0FuZFVwZGF0ZVBDUClcbiAgICAgIC5vbignd2hlZWwnLCByb3RhdGVMYWJlbHMpO1xuXG4gICAgaWYgKF9fLm51bGxWYWx1ZVNlcGFyYXRvciA9PSAndG9wJykge1xuICAgICAgcGMuc3ZnXG4gICAgICAgIC5hcHBlbmQoJ2xpbmUnKVxuICAgICAgICAuYXR0cigneDEnLCAwKVxuICAgICAgICAuYXR0cigneTEnLCAxICsgX18ubnVsbFZhbHVlU2VwYXJhdG9yUGFkZGluZy50b3ApXG4gICAgICAgIC5hdHRyKCd4MicsIHcoKSlcbiAgICAgICAgLmF0dHIoJ3kyJywgMSArIF9fLm51bGxWYWx1ZVNlcGFyYXRvclBhZGRpbmcudG9wKVxuICAgICAgICAuYXR0cignc3Ryb2tlLXdpZHRoJywgMSlcbiAgICAgICAgLmF0dHIoJ3N0cm9rZScsICcjNzc3JylcbiAgICAgICAgLmF0dHIoJ2ZpbGwnLCAnbm9uZScpXG4gICAgICAgIC5hdHRyKCdzaGFwZS1yZW5kZXJpbmcnLCAnY3Jpc3BFZGdlcycpO1xuICAgIH0gZWxzZSBpZiAoX18ubnVsbFZhbHVlU2VwYXJhdG9yID09ICdib3R0b20nKSB7XG4gICAgICBwYy5zdmdcbiAgICAgICAgLmFwcGVuZCgnbGluZScpXG4gICAgICAgIC5hdHRyKCd4MScsIDApXG4gICAgICAgIC5hdHRyKCd5MScsIGgoKSArIDEgLSBfXy5udWxsVmFsdWVTZXBhcmF0b3JQYWRkaW5nLmJvdHRvbSlcbiAgICAgICAgLmF0dHIoJ3gyJywgdygpKVxuICAgICAgICAuYXR0cigneTInLCBoKCkgKyAxIC0gX18ubnVsbFZhbHVlU2VwYXJhdG9yUGFkZGluZy5ib3R0b20pXG4gICAgICAgIC5hdHRyKCdzdHJva2Utd2lkdGgnLCAxKVxuICAgICAgICAuYXR0cignc3Ryb2tlJywgJyM3NzcnKVxuICAgICAgICAuYXR0cignZmlsbCcsICdub25lJylcbiAgICAgICAgLmF0dHIoJ3NoYXBlLXJlbmRlcmluZycsICdjcmlzcEVkZ2VzJyk7XG4gICAgfVxuXG4gICAgZmxhZ3MuYXhlcyA9IHRydWU7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgcGMucmVtb3ZlQXhlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICBnLnJlbW92ZSgpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIHBjLnVwZGF0ZUF4ZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGdfZGF0YSA9IHBjLnN2Zy5zZWxlY3RBbGwoJy5kaW1lbnNpb24nKS5kYXRhKF9fLmRpbWVuc2lvbnMpO1xuXG4gICAgLy8gRW50ZXJcbiAgICBnX2RhdGFcbiAgICAgIC5lbnRlcigpXG4gICAgICAuYXBwZW5kKCdzdmc6ZycpXG4gICAgICAuYXR0cignY2xhc3MnLCAnZGltZW5zaW9uJylcbiAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCBmdW5jdGlvbiAocCkge1xuICAgICAgICByZXR1cm4gJ3RyYW5zbGF0ZSgnICsgcG9zaXRpb24ocCkgKyAnKSc7XG4gICAgICB9KVxuICAgICAgLnN0eWxlKCdvcGFjaXR5JywgMClcbiAgICAgIC5hcHBlbmQoJ3N2ZzpnJylcbiAgICAgIC5hdHRyKCdjbGFzcycsICdheGlzJylcbiAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKDAsMCknKVxuICAgICAgLmVhY2goZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgZDMuc2VsZWN0KHRoaXMpLmNhbGwoYXhpcy5zY2FsZSh5c2NhbGVbZF0pKTtcbiAgICAgIH0pXG4gICAgICAuYXBwZW5kKCdzdmc6dGV4dCcpXG4gICAgICAuYXR0cih7XG4gICAgICAgICd0ZXh0LWFuY2hvcic6ICdtaWRkbGUnLFxuICAgICAgICB5OiAwLFxuICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUoMCwtNSkgcm90YXRlKCcgKyBfXy5kaW1lbnNpb25UaXRsZVJvdGF0aW9uICsgJyknLFxuICAgICAgICB4OiAwLFxuICAgICAgICBjbGFzczogJ2xhYmVsJyxcbiAgICAgIH0pXG4gICAgICAudGV4dChkaW1lbnNpb25MYWJlbHMpXG4gICAgICAub24oJ2RibGNsaWNrJywgZmxpcEF4aXNBbmRVcGRhdGVQQ1ApXG4gICAgICAub24oJ3doZWVsJywgcm90YXRlTGFiZWxzKTtcblxuICAgIC8vIFVwZGF0ZVxuICAgIGdfZGF0YS5hdHRyKCdvcGFjaXR5JywgMCk7XG4gICAgZ19kYXRhXG4gICAgICAuc2VsZWN0KCcuYXhpcycpXG4gICAgICAudHJhbnNpdGlvbigpXG4gICAgICAuZHVyYXRpb24oMTEwMClcbiAgICAgIC5lYWNoKGZ1bmN0aW9uIChkKSB7XG4gICAgICAgIGQzLnNlbGVjdCh0aGlzKS5jYWxsKGF4aXMuc2NhbGUoeXNjYWxlW2RdKSk7XG4gICAgICB9KTtcbiAgICBnX2RhdGFcbiAgICAgIC5zZWxlY3QoJy5sYWJlbCcpXG4gICAgICAudHJhbnNpdGlvbigpXG4gICAgICAuZHVyYXRpb24oMTEwMClcbiAgICAgIC50ZXh0KGRpbWVuc2lvbkxhYmVscylcbiAgICAgIC5hdHRyKFxuICAgICAgICAndHJhbnNmb3JtJyxcbiAgICAgICAgJ3RyYW5zbGF0ZSgwLC01KSByb3RhdGUoJyArIF9fLmRpbWVuc2lvblRpdGxlUm90YXRpb24gKyAnKScsXG4gICAgICApO1xuXG4gICAgLy8gRXhpdFxuICAgIGdfZGF0YS5leGl0KCkucmVtb3ZlKCk7XG5cbiAgICBnID0gcGMuc3ZnLnNlbGVjdEFsbCgnLmRpbWVuc2lvbicpO1xuICAgIGcudHJhbnNpdGlvbigpXG4gICAgICAuZHVyYXRpb24oMTEwMClcbiAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCBmdW5jdGlvbiAocCkge1xuICAgICAgICByZXR1cm4gJ3RyYW5zbGF0ZSgnICsgcG9zaXRpb24ocCkgKyAnKSc7XG4gICAgICB9KVxuICAgICAgLnN0eWxlKCdvcGFjaXR5JywgMSk7XG5cbiAgICBwYy5zdmdcbiAgICAgIC5zZWxlY3RBbGwoJy5heGlzJylcbiAgICAgIC50cmFuc2l0aW9uKClcbiAgICAgIC5kdXJhdGlvbigxMTAwKVxuICAgICAgLmVhY2goZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgZDMuc2VsZWN0KHRoaXMpLmNhbGwoYXhpcy5zY2FsZSh5c2NhbGVbZF0pKTtcbiAgICAgIH0pO1xuXG4gICAgaWYgKGZsYWdzLmJydXNoYWJsZSkgcGMuYnJ1c2hhYmxlKCk7XG4gICAgaWYgKGZsYWdzLnJlb3JkZXJhYmxlKSBwYy5yZW9yZGVyYWJsZSgpO1xuICAgIGlmIChwYy5icnVzaE1vZGUoKSAhPT0gJ05vbmUnKSB7XG4gICAgICB2YXIgbW9kZSA9IHBjLmJydXNoTW9kZSgpO1xuICAgICAgcGMuYnJ1c2hNb2RlKCdOb25lJyk7XG4gICAgICBwYy5icnVzaE1vZGUobW9kZSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8vIEphc29uIERhdmllcywgaHR0cDovL2JsLm9ja3Mub3JnLzEzNDEyODFcbiAgcGMucmVvcmRlcmFibGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFnKSBwYy5jcmVhdGVBeGVzKCk7XG5cbiAgICBnLnN0eWxlKCdjdXJzb3InLCAnbW92ZScpLmNhbGwoXG4gICAgICBkMy5iZWhhdmlvclxuICAgICAgICAuZHJhZygpXG4gICAgICAgIC5vbignZHJhZ3N0YXJ0JywgZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICBkcmFnZ2luZ1tkXSA9IHRoaXMuX19vcmlnaW5fXyA9IHhzY2FsZShkKTtcbiAgICAgICAgfSlcbiAgICAgICAgLm9uKCdkcmFnJywgZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICBkcmFnZ2luZ1tkXSA9IE1hdGgubWluKFxuICAgICAgICAgICAgdygpLFxuICAgICAgICAgICAgTWF0aC5tYXgoMCwgKHRoaXMuX19vcmlnaW5fXyArPSBkMy5ldmVudC5keCkpLFxuICAgICAgICAgICk7XG4gICAgICAgICAgX18uZGltZW5zaW9ucy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgICByZXR1cm4gcG9zaXRpb24oYSkgLSBwb3NpdGlvbihiKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB4c2NhbGUuZG9tYWluKF9fLmRpbWVuc2lvbnMpO1xuICAgICAgICAgIHBjLnJlbmRlcigpO1xuICAgICAgICAgIGcuYXR0cigndHJhbnNmb3JtJywgZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICAgIHJldHVybiAndHJhbnNsYXRlKCcgKyBwb3NpdGlvbihkKSArICcpJztcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSlcbiAgICAgICAgLm9uKCdkcmFnZW5kJywgZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICAvLyBMZXQncyBzZWUgaWYgdGhlIG9yZGVyIGhhcyBjaGFuZ2VkIGFuZCBzZW5kIG91dCBhbiBldmVudCBpZiBzby5cbiAgICAgICAgICB2YXIgaSA9IDAsXG4gICAgICAgICAgICBqID0gX18uZGltZW5zaW9ucy5pbmRleE9mKGQpLFxuICAgICAgICAgICAgZWxlbSA9IHRoaXMsXG4gICAgICAgICAgICBwYXJlbnQgPSB0aGlzLnBhcmVudEVsZW1lbnQ7XG5cbiAgICAgICAgICB3aGlsZSAoKGVsZW0gPSBlbGVtLnByZXZpb3VzRWxlbWVudFNpYmxpbmcpICE9IG51bGwpICsraTtcbiAgICAgICAgICBpZiAoaSAhPT0gaikge1xuICAgICAgICAgICAgZXZlbnRzLmF4ZXNyZW9yZGVyLmNhbGwocGMsIF9fLmRpbWVuc2lvbnMpO1xuICAgICAgICAgICAgLy8gV2Ugbm93IGFsc28gd2FudCB0byByZW9yZGVyIHRoZSBhY3R1YWwgZG9tIGVsZW1lbnRzIHRoYXQgcmVwcmVzZW50XG4gICAgICAgICAgICAvLyB0aGUgYXhlcy4gVGhhdCBpcywgdGhlIGcuZGltZW5zaW9uIGVsZW1lbnRzLiBJZiB3ZSBkb24ndCBkbyB0aGlzLFxuICAgICAgICAgICAgLy8gd2UgZ2V0IGEgd2VpcmQgYW5kIGNvbmZ1c2luZyB0cmFuc2l0aW9uIHdoZW4gdXBkYXRlQXhlcyBpcyBjYWxsZWQuXG4gICAgICAgICAgICAvLyBUaGlzIGlzIGR1ZSB0byB0aGUgZmFjdCB0aGF0LCBpbml0aWFsbHkgdGhlIG50aCBnLmRpbWVuc2lvbiBlbGVtZW50XG4gICAgICAgICAgICAvLyByZXByZXNlbnRzIHRoZSBudGggYXhpcy4gSG93ZXZlciwgYWZ0ZXIgYSBtYW51YWwgcmVvcmRlcmluZyxcbiAgICAgICAgICAgIC8vIHdpdGhvdXQgcmVvcmRlcmluZyB0aGUgZG9tIGVsZW1lbnRzLCB0aGUgbnRoIGRvbSBlbGVtZW50cyBubyBsb25nZXJcbiAgICAgICAgICAgIC8vIG5lY2Vzc2FyaWx5IHJlcHJlc2VudHMgdGhlIG50aCBheGlzLlxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIGkgaXMgdGhlIG9yaWdpbmFsIGluZGV4IG9mIHRoZSBkb20gZWxlbWVudFxuICAgICAgICAgICAgLy8gaiBpcyB0aGUgbmV3IGluZGV4IG9mIHRoZSBkb20gZWxlbWVudFxuICAgICAgICAgICAgaWYgKGkgPiBqKSB7XG4gICAgICAgICAgICAgIC8vIEVsZW1lbnQgbW92ZWQgbGVmdFxuICAgICAgICAgICAgICBwYXJlbnQuaW5zZXJ0QmVmb3JlKHRoaXMsIHBhcmVudC5jaGlsZHJlbltqIC0gMV0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gRWxlbWVudCBtb3ZlZCByaWdodFxuICAgICAgICAgICAgICBpZiAoaiArIDEgPCBwYXJlbnQuY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcGFyZW50Lmluc2VydEJlZm9yZSh0aGlzLCBwYXJlbnQuY2hpbGRyZW5baiArIDFdKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwYXJlbnQuYXBwZW5kQ2hpbGQodGhpcyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBkZWxldGUgdGhpcy5fX29yaWdpbl9fO1xuICAgICAgICAgIGRlbGV0ZSBkcmFnZ2luZ1tkXTtcbiAgICAgICAgICBkMy5zZWxlY3QodGhpcylcbiAgICAgICAgICAgIC50cmFuc2l0aW9uKClcbiAgICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKCcgKyB4c2NhbGUoZCkgKyAnKScpO1xuICAgICAgICAgIHBjLnJlbmRlcigpO1xuICAgICAgICB9KSxcbiAgICApO1xuICAgIGZsYWdzLnJlb3JkZXJhYmxlID0gdHJ1ZTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvLyBSZW9yZGVyIGRpbWVuc2lvbnMsIHN1Y2ggdGhhdCB0aGUgaGlnaGVzdCB2YWx1ZSAodmlzdWFsbHkpIGlzIG9uIHRoZSBsZWZ0IGFuZFxuICAvLyB0aGUgbG93ZXN0IG9uIHRoZSByaWdodC4gVmlzdWFsIHZhbHVlcyBhcmUgZGV0ZXJtaW5lZCBieSB0aGUgZGF0YSB2YWx1ZXMgaW5cbiAgLy8gdGhlIGdpdmVuIHJvdy5cbiAgcGMucmVvcmRlciA9IGZ1bmN0aW9uIChyb3dkYXRhKSB7XG4gICAgdmFyIGRpbXMgPSBfXy5kaW1lbnNpb25zLnNsaWNlKDApO1xuICAgIF9fLmRpbWVuc2lvbnMuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgdmFyIHBpeGVsRGlmZmVyZW5jZSA9IHlzY2FsZVthXShyb3dkYXRhW2FdKSAtIHlzY2FsZVtiXShyb3dkYXRhW2JdKTtcblxuICAgICAgLy8gQXJyYXkuc29ydCBpcyBub3QgbmVjZXNzYXJpbHkgc3RhYmxlLCB0aGlzIG1lYW5zIHRoYXQgaWYgcGl4ZWxEaWZmZXJlbmNlIGlzIHplcm9cbiAgICAgIC8vIHRoZSBvcmRlcmluZyBvZiBkaW1lbnNpb25zIG1pZ2h0IGNoYW5nZSB1bmV4cGVjdGVkbHkuIFRoaXMgaXMgc29sdmVkIGJ5IHNvcnRpbmcgb25cbiAgICAgIC8vIHZhcmlhYmxlIG5hbWUgaW4gdGhhdCBjYXNlLlxuICAgICAgaWYgKHBpeGVsRGlmZmVyZW5jZSA9PT0gMCkge1xuICAgICAgICByZXR1cm4gYS5sb2NhbGVDb21wYXJlKGIpO1xuICAgICAgfSAvLyBlbHNlXG4gICAgICByZXR1cm4gcGl4ZWxEaWZmZXJlbmNlO1xuICAgIH0pO1xuXG4gICAgLy8gTk9URTogdGhpcyBpcyByZWxhdGl2ZWx5IGNoZWFwIGdpdmVuIHRoYXQ6XG4gICAgLy8gbnVtYmVyIG9mIGRpbWVuc2lvbnMgPCBudW1iZXIgb2YgZGF0YSBpdGVtc1xuICAgIC8vIFRodXMgd2UgY2hlY2sgZXF1YWxpdHkgb2Ygb3JkZXIgdG8gcHJldmVudCByZXJlbmRlcmluZyB3aGVuIHRoaXMgaXMgdGhlIGNhc2UuXG4gICAgdmFyIHJlb3JkZXJlZCA9IGZhbHNlO1xuICAgIGRpbXMuc29tZShmdW5jdGlvbiAodmFsLCBpbmRleCkge1xuICAgICAgcmVvcmRlcmVkID0gdmFsICE9PSBfXy5kaW1lbnNpb25zW2luZGV4XTtcbiAgICAgIHJldHVybiByZW9yZGVyZWQ7XG4gICAgfSk7XG5cbiAgICBpZiAocmVvcmRlcmVkKSB7XG4gICAgICB4c2NhbGUuZG9tYWluKF9fLmRpbWVuc2lvbnMpO1xuICAgICAgdmFyIGhpZ2hsaWdodGVkID0gX18uaGlnaGxpZ2h0ZWQuc2xpY2UoMCk7XG4gICAgICBwYy51bmhpZ2hsaWdodCgpO1xuXG4gICAgICBnLnRyYW5zaXRpb24oKVxuICAgICAgICAuZHVyYXRpb24oMTUwMClcbiAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsIGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgcmV0dXJuICd0cmFuc2xhdGUoJyArIHhzY2FsZShkKSArICcpJztcbiAgICAgICAgfSk7XG4gICAgICBwYy5yZW5kZXIoKTtcblxuICAgICAgLy8gcGMuaGlnaGxpZ2h0KCkgZG9lcyBub3QgY2hlY2sgd2hldGhlciBoaWdobGlnaHRlZCBpcyBsZW5ndGggemVybywgc28gd2UgZG8gdGhhdCBoZXJlLlxuICAgICAgaWYgKGhpZ2hsaWdodGVkLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICBwYy5oaWdobGlnaHQoaGlnaGxpZ2h0ZWQpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvLyBwYWlycyBvZiBhZGphY2VudCBkaW1lbnNpb25zXG4gIHBjLmFkamFjZW50X3BhaXJzID0gZnVuY3Rpb24gKGFycikge1xuICAgIHZhciByZXQgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGggLSAxOyBpICs9IDEpIHtcbiAgICAgIHJldC5wdXNoKFthcnJbaV0sIGFycltpICsgMV1dKTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfTtcblxuICB2YXIgYnJ1c2ggPSB7XG4gICAgbW9kZXM6IHtcbiAgICAgIE5vbmU6IHtcbiAgICAgICAgaW5zdGFsbDogZnVuY3Rpb24gKHBjKSB7fSwgLy8gTm90aGluZyB0byBiZSBkb25lLlxuICAgICAgICB1bmluc3RhbGw6IGZ1bmN0aW9uIChwYykge30sIC8vIE5vdGhpbmcgdG8gYmUgZG9uZS5cbiAgICAgICAgc2VsZWN0ZWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH0sIC8vIE5vdGhpbmcgdG8gcmV0dXJuXG4gICAgICAgIGJydXNoU3RhdGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4ge307XG4gICAgICAgIH0sXG4gICAgICB9LFxuICAgIH0sXG4gICAgbW9kZTogJ05vbmUnLFxuICAgIHByZWRpY2F0ZTogJ0FORCcsXG4gICAgY3VycmVudE1vZGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLm1vZGVzW3RoaXMubW9kZV07XG4gICAgfSxcbiAgfTtcblxuICAvLyBUaGlzIGZ1bmN0aW9uIGNhbiBiZSB1c2VkIGZvciAnbGl2ZScgdXBkYXRlcyBvZiBicnVzaGVzLiBUaGF0IGlzLCBkdXJpbmcgdGhlXG4gIC8vIHNwZWNpZmljYXRpb24gb2YgYSBicnVzaCwgdGhpcyBtZXRob2QgY2FuIGJlIGNhbGxlZCB0byB1cGRhdGUgdGhlIHZpZXcuXG4gIC8vXG4gIC8vIEBwYXJhbSBuZXdTZWxlY3Rpb24gLSBUaGUgbmV3IHNldCBvZiBkYXRhIGl0ZW1zIHRoYXQgaXMgY3VycmVudGx5IGNvbnRhaW5lZFxuICAvLyAgICAgICAgICAgICAgICAgICAgICAgYnkgdGhlIGJydXNoZXNcbiAgZnVuY3Rpb24gYnJ1c2hVcGRhdGVkKG5ld1NlbGVjdGlvbikge1xuICAgIF9fLmJydXNoZWQgPSBuZXdTZWxlY3Rpb247XG4gICAgZXZlbnRzLmJydXNoLmNhbGwocGMsIF9fLmJydXNoZWQpO1xuICAgIHBjLnJlbmRlckJydXNoZWQoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGJydXNoUHJlZGljYXRlKHByZWRpY2F0ZSkge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGJydXNoLnByZWRpY2F0ZTtcbiAgICB9XG5cbiAgICBwcmVkaWNhdGUgPSBTdHJpbmcocHJlZGljYXRlKS50b1VwcGVyQ2FzZSgpO1xuICAgIGlmIChwcmVkaWNhdGUgIT09ICdBTkQnICYmIHByZWRpY2F0ZSAhPT0gJ09SJykge1xuICAgICAgdGhyb3cgJ0ludmFsaWQgcHJlZGljYXRlICcgKyBwcmVkaWNhdGU7XG4gICAgfVxuXG4gICAgYnJ1c2gucHJlZGljYXRlID0gcHJlZGljYXRlO1xuICAgIF9fLmJydXNoZWQgPSBicnVzaC5jdXJyZW50TW9kZSgpLnNlbGVjdGVkKCk7XG4gICAgcGMucmVuZGVyQnJ1c2hlZCgpO1xuICAgIHJldHVybiBwYztcbiAgfVxuXG4gIHBjLmJydXNoTW9kZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGJydXNoLm1vZGVzKTtcbiAgfTtcblxuICBwYy5icnVzaE1vZGUgPSBmdW5jdGlvbiAobW9kZSkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gYnJ1c2gubW9kZTtcbiAgICB9XG5cbiAgICBpZiAocGMuYnJ1c2hNb2RlcygpLmluZGV4T2YobW9kZSkgPT09IC0xKSB7XG4gICAgICB0aHJvdyAncGMuYnJ1c2htb2RlOiBVbnN1cHBvcnRlZCBicnVzaCBtb2RlOiAnICsgbW9kZTtcbiAgICB9XG5cbiAgICAvLyBNYWtlIHN1cmUgdGhhdCB3ZSBkb24ndCB0cmlnZ2VyIHVubmVjZXNzYXJ5IGV2ZW50cyBieSBjaGVja2luZyBpZiB0aGUgbW9kZVxuICAgIC8vIGFjdHVhbGx5IGNoYW5nZXMuXG4gICAgaWYgKG1vZGUgIT09IGJydXNoLm1vZGUpIHtcbiAgICAgIC8vIFdoZW4gY2hhbmdpbmcgYnJ1c2ggbW9kZXMsIHRoZSBmaXJzdCB0aGluZyB3ZSBuZWVkIHRvIGRvIGlzIGNsZWFyaW5nIGFueVxuICAgICAgLy8gYnJ1c2hlcyBmcm9tIHRoZSBjdXJyZW50IG1vZGUsIGlmIGFueS5cbiAgICAgIGlmIChicnVzaC5tb2RlICE9PSAnTm9uZScpIHtcbiAgICAgICAgcGMuYnJ1c2hSZXNldCgpO1xuICAgICAgfVxuXG4gICAgICAvLyBOZXh0LCB3ZSBuZWVkIHRvICd1bmluc3RhbGwnIHRoZSBjdXJyZW50IGJydXNoTW9kZS5cbiAgICAgIGJydXNoLm1vZGVzW2JydXNoLm1vZGVdLnVuaW5zdGFsbChwYyk7XG4gICAgICAvLyBGaW5hbGx5LCB3ZSBjYW4gaW5zdGFsbCB0aGUgcmVxdWVzdGVkIG9uZS5cbiAgICAgIGJydXNoLm1vZGUgPSBtb2RlO1xuICAgICAgYnJ1c2gubW9kZXNbYnJ1c2gubW9kZV0uaW5zdGFsbCgpO1xuICAgICAgaWYgKG1vZGUgPT09ICdOb25lJykge1xuICAgICAgICBkZWxldGUgcGMuYnJ1c2hQcmVkaWNhdGU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYy5icnVzaFByZWRpY2F0ZSA9IGJydXNoUHJlZGljYXRlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBwYztcbiAgfTtcblxuICAvLyBicnVzaCBtb2RlOiAxRC1BeGVzXG5cbiAgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgYnJ1c2hlcyA9IHt9O1xuXG4gICAgZnVuY3Rpb24gaXNfYnJ1c2hlZChwKSB7XG4gICAgICByZXR1cm4gIWJydXNoZXNbcF0uZW1wdHkoKTtcbiAgICB9XG5cbiAgICAvLyBkYXRhIHdpdGhpbiBleHRlbnRzXG4gICAgZnVuY3Rpb24gc2VsZWN0ZWQoKSB7XG4gICAgICB2YXIgYWN0aXZlcyA9IF9fLmRpbWVuc2lvbnMuZmlsdGVyKGlzX2JydXNoZWQpLFxuICAgICAgICBleHRlbnRzID0gYWN0aXZlcy5tYXAoZnVuY3Rpb24gKHApIHtcbiAgICAgICAgICByZXR1cm4gYnJ1c2hlc1twXS5leHRlbnQoKTtcbiAgICAgICAgfSk7XG5cbiAgICAgIC8vIFdlIGRvbid0IHdhbnQgdG8gcmV0dXJuIHRoZSBmdWxsIGRhdGEgc2V0IHdoZW4gdGhlcmUgYXJlIG5vIGF4ZXMgYnJ1c2hlZC5cbiAgICAgIC8vIEFjdHVhbGx5LCB3aGVuIHRoZXJlIGFyZSBubyBheGVzIGJydXNoZWQsIGJ5IGRlZmluaXRpb24sIG5vIGl0ZW1zIGFyZVxuICAgICAgLy8gc2VsZWN0ZWQuIFNvLCBsZXQncyBhdm9pZCB0aGUgZmlsdGVyaW5nIGFuZCBqdXN0IHJldHVybiBmYWxzZS5cbiAgICAgIC8vaWYgKGFjdGl2ZXMubGVuZ3RoID09PSAwKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgIC8vIFJlc29sdmVzIGJyb2tlbiBleGFtcGxlcyBmb3Igbm93LiBUaGV5IGV4cGVjdCB0byBnZXQgdGhlIGZ1bGwgZGF0YXNldCBiYWNrIGZyb20gZW1wdHkgYnJ1c2hlc1xuICAgICAgaWYgKGFjdGl2ZXMubGVuZ3RoID09PSAwKSByZXR1cm4gX18uZGF0YTtcblxuICAgICAgLy8gdGVzdCBpZiB3aXRoaW4gcmFuZ2VcbiAgICAgIHZhciB3aXRoaW4gPSB7XG4gICAgICAgIGRhdGU6IGZ1bmN0aW9uIChkLCBwLCBkaW1lbnNpb24pIHtcbiAgICAgICAgICBpZiAodHlwZW9mIHlzY2FsZVtwXS5yYW5nZVBvaW50cyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgLy8gaWYgaXQgaXMgb3JkaW5hbFxuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgZXh0ZW50c1tkaW1lbnNpb25dWzBdIDw9IHlzY2FsZVtwXShkW3BdKSAmJlxuICAgICAgICAgICAgICB5c2NhbGVbcF0oZFtwXSkgPD0gZXh0ZW50c1tkaW1lbnNpb25dWzFdXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICBleHRlbnRzW2RpbWVuc2lvbl1bMF0gPD0gZFtwXSAmJiBkW3BdIDw9IGV4dGVudHNbZGltZW5zaW9uXVsxXVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIG51bWJlcjogZnVuY3Rpb24gKGQsIHAsIGRpbWVuc2lvbikge1xuICAgICAgICAgIGlmICh0eXBlb2YgeXNjYWxlW3BdLnJhbmdlUG9pbnRzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAvLyBpZiBpdCBpcyBvcmRpbmFsXG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICBleHRlbnRzW2RpbWVuc2lvbl1bMF0gPD0geXNjYWxlW3BdKGRbcF0pICYmXG4gICAgICAgICAgICAgIHlzY2FsZVtwXShkW3BdKSA8PSBleHRlbnRzW2RpbWVuc2lvbl1bMV1cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgIGV4dGVudHNbZGltZW5zaW9uXVswXSA8PSBkW3BdICYmIGRbcF0gPD0gZXh0ZW50c1tkaW1lbnNpb25dWzFdXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgc3RyaW5nOiBmdW5jdGlvbiAoZCwgcCwgZGltZW5zaW9uKSB7XG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIGV4dGVudHNbZGltZW5zaW9uXVswXSA8PSB5c2NhbGVbcF0oZFtwXSkgJiZcbiAgICAgICAgICAgIHlzY2FsZVtwXShkW3BdKSA8PSBleHRlbnRzW2RpbWVuc2lvbl1bMV1cbiAgICAgICAgICApO1xuICAgICAgICB9LFxuICAgICAgfTtcblxuICAgICAgcmV0dXJuIF9fLmRhdGEuZmlsdGVyKGZ1bmN0aW9uIChkKSB7XG4gICAgICAgIHN3aXRjaCAoYnJ1c2gucHJlZGljYXRlKSB7XG4gICAgICAgICAgY2FzZSAnQU5EJzpcbiAgICAgICAgICAgIHJldHVybiBhY3RpdmVzLmV2ZXJ5KGZ1bmN0aW9uIChwLCBkaW1lbnNpb24pIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHdpdGhpbltfXy50eXBlc1twXV0oZCwgcCwgZGltZW5zaW9uKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIGNhc2UgJ09SJzpcbiAgICAgICAgICAgIHJldHVybiBhY3RpdmVzLnNvbWUoZnVuY3Rpb24gKHAsIGRpbWVuc2lvbikge1xuICAgICAgICAgICAgICByZXR1cm4gd2l0aGluW19fLnR5cGVzW3BdXShkLCBwLCBkaW1lbnNpb24pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93ICdVbmtub3duIGJydXNoIHByZWRpY2F0ZSAnICsgX18uYnJ1c2hQcmVkaWNhdGU7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGJydXNoRXh0ZW50cyhleHRlbnRzKSB7XG4gICAgICBpZiAodHlwZW9mIGV4dGVudHMgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHZhciBleHRlbnRzID0ge307XG4gICAgICAgIF9fLmRpbWVuc2lvbnMuZm9yRWFjaChmdW5jdGlvbiAoZCkge1xuICAgICAgICAgIHZhciBicnVzaCA9IGJydXNoZXNbZF07XG4gICAgICAgICAgaWYgKGJydXNoICE9PSB1bmRlZmluZWQgJiYgIWJydXNoLmVtcHR5KCkpIHtcbiAgICAgICAgICAgIHZhciBleHRlbnQgPSBicnVzaC5leHRlbnQoKTtcbiAgICAgICAgICAgIGV4dGVudC5zb3J0KGQzLmFzY2VuZGluZyk7XG4gICAgICAgICAgICBleHRlbnRzW2RdID0gZXh0ZW50O1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBleHRlbnRzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy9maXJzdCBnZXQgYWxsIHRoZSBicnVzaCBzZWxlY3Rpb25zXG4gICAgICAgIHZhciBicnVzaFNlbGVjdGlvbnMgPSB7fTtcbiAgICAgICAgZy5zZWxlY3RBbGwoJy5icnVzaCcpLmVhY2goZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICBicnVzaFNlbGVjdGlvbnNbZF0gPSBkMy5zZWxlY3QodGhpcyk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIGxvb3Agb3ZlciBlYWNoIGRpbWVuc2lvbiBhbmQgdXBkYXRlIGFwcHJvcHJpYXRlbHkgKGlmIGl0IHdhcyBwYXNzZWQgaW4gdGhyb3VnaCBleHRlbnRzKVxuICAgICAgICBfXy5kaW1lbnNpb25zLmZvckVhY2goZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICBpZiAoZXh0ZW50c1tkXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIGJydXNoID0gYnJ1c2hlc1tkXTtcbiAgICAgICAgICBpZiAoYnJ1c2ggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgLy91cGRhdGUgdGhlIGV4dGVudFxuICAgICAgICAgICAgYnJ1c2guZXh0ZW50KGV4dGVudHNbZF0pO1xuXG4gICAgICAgICAgICAvL3JlZHJhdyB0aGUgYnJ1c2hcbiAgICAgICAgICAgIGJydXNoKGJydXNoU2VsZWN0aW9uc1tkXSk7XG5cbiAgICAgICAgICAgIC8vZmlyZSBzb21lIGV2ZW50c1xuICAgICAgICAgICAgYnJ1c2guZXZlbnQoYnJ1c2hTZWxlY3Rpb25zW2RdKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vcmVkcmF3IHRoZSBjaGFydFxuICAgICAgICBwYy5yZW5kZXJCcnVzaGVkKCk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGJydXNoRm9yKGF4aXMpIHtcbiAgICAgIHZhciBicnVzaCA9IGQzLnN2Zy5icnVzaCgpO1xuXG4gICAgICBicnVzaFxuICAgICAgICAueSh5c2NhbGVbYXhpc10pXG4gICAgICAgIC5vbignYnJ1c2hzdGFydCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAoZDMuZXZlbnQuc291cmNlRXZlbnQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGQzLmV2ZW50LnNvdXJjZUV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICAgLm9uKCdicnVzaCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBicnVzaFVwZGF0ZWQoc2VsZWN0ZWQoKSk7XG4gICAgICAgIH0pXG4gICAgICAgIC5vbignYnJ1c2hlbmQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgZXZlbnRzLmJydXNoZW5kLmNhbGwocGMsIF9fLmJydXNoZWQpO1xuICAgICAgICB9KTtcblxuICAgICAgYnJ1c2hlc1theGlzXSA9IGJydXNoO1xuICAgICAgcmV0dXJuIGJydXNoO1xuICAgIH1cbiAgICBmdW5jdGlvbiBicnVzaFJlc2V0KGRpbWVuc2lvbikge1xuICAgICAgX18uYnJ1c2hlZCA9IGZhbHNlO1xuICAgICAgaWYgKGcpIHtcbiAgICAgICAgZy5zZWxlY3RBbGwoJy5icnVzaCcpLmVhY2goZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICBkMy5zZWxlY3QodGhpcykuY2FsbChicnVzaGVzW2RdLmNsZWFyKCkpO1xuICAgICAgICB9KTtcbiAgICAgICAgcGMucmVuZGVyQnJ1c2hlZCgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbCgpIHtcbiAgICAgIGlmICghZykgcGMuY3JlYXRlQXhlcygpO1xuXG4gICAgICAvLyBBZGQgYW5kIHN0b3JlIGEgYnJ1c2ggZm9yIGVhY2ggYXhpcy5cbiAgICAgIGcuYXBwZW5kKCdzdmc6ZycpXG4gICAgICAgIC5hdHRyKCdjbGFzcycsICdicnVzaCcpXG4gICAgICAgIC5lYWNoKGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgZDMuc2VsZWN0KHRoaXMpLmNhbGwoYnJ1c2hGb3IoZCkpO1xuICAgICAgICB9KVxuICAgICAgICAuc2VsZWN0QWxsKCdyZWN0JylcbiAgICAgICAgLnN0eWxlKCd2aXNpYmlsaXR5JywgbnVsbClcbiAgICAgICAgLmF0dHIoJ3gnLCAtMTUpXG4gICAgICAgIC5hdHRyKCd3aWR0aCcsIDMwKTtcblxuICAgICAgcGMuYnJ1c2hFeHRlbnRzID0gYnJ1c2hFeHRlbnRzO1xuICAgICAgcGMuYnJ1c2hSZXNldCA9IGJydXNoUmVzZXQ7XG4gICAgICByZXR1cm4gcGM7XG4gICAgfVxuXG4gICAgYnJ1c2gubW9kZXNbJzFELWF4ZXMnXSA9IHtcbiAgICAgIGluc3RhbGw6IGluc3RhbGwsXG4gICAgICB1bmluc3RhbGw6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZy5zZWxlY3RBbGwoJy5icnVzaCcpLnJlbW92ZSgpO1xuICAgICAgICBicnVzaGVzID0ge307XG4gICAgICAgIGRlbGV0ZSBwYy5icnVzaEV4dGVudHM7XG4gICAgICAgIGRlbGV0ZSBwYy5icnVzaFJlc2V0O1xuICAgICAgfSxcbiAgICAgIHNlbGVjdGVkOiBzZWxlY3RlZCxcbiAgICAgIGJydXNoU3RhdGU6IGJydXNoRXh0ZW50cyxcbiAgICB9O1xuICB9KSgpO1xuICAvLyBicnVzaCBtb2RlOiAyRC1zdHJ1bXNcbiAgLy8gYmwub2Nrcy5vcmcvc3ludGFnbWF0aWMvNTQ0MTAyMlxuXG4gIChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHN0cnVtcyA9IHt9LFxuICAgICAgc3RydW1SZWN0O1xuXG4gICAgZnVuY3Rpb24gZHJhd1N0cnVtKHN0cnVtLCBhY3RpdmVQb2ludCkge1xuICAgICAgdmFyIHN2ZyA9IHBjLnNlbGVjdGlvbi5zZWxlY3QoJ3N2ZycpLnNlbGVjdCgnZyNzdHJ1bXMnKSxcbiAgICAgICAgaWQgPSBzdHJ1bS5kaW1zLmksXG4gICAgICAgIHBvaW50cyA9IFtzdHJ1bS5wMSwgc3RydW0ucDJdLFxuICAgICAgICBsaW5lID0gc3ZnLnNlbGVjdEFsbCgnbGluZSNzdHJ1bS0nICsgaWQpLmRhdGEoW3N0cnVtXSksXG4gICAgICAgIGNpcmNsZXMgPSBzdmcuc2VsZWN0QWxsKCdjaXJjbGUjc3RydW0tJyArIGlkKS5kYXRhKHBvaW50cyksXG4gICAgICAgIGRyYWcgPSBkMy5iZWhhdmlvci5kcmFnKCk7XG5cbiAgICAgIGxpbmVcbiAgICAgICAgLmVudGVyKClcbiAgICAgICAgLmFwcGVuZCgnbGluZScpXG4gICAgICAgIC5hdHRyKCdpZCcsICdzdHJ1bS0nICsgaWQpXG4gICAgICAgIC5hdHRyKCdjbGFzcycsICdzdHJ1bScpO1xuXG4gICAgICBsaW5lXG4gICAgICAgIC5hdHRyKCd4MScsIGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgcmV0dXJuIGQucDFbMF07XG4gICAgICAgIH0pXG4gICAgICAgIC5hdHRyKCd5MScsIGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgcmV0dXJuIGQucDFbMV07XG4gICAgICAgIH0pXG4gICAgICAgIC5hdHRyKCd4MicsIGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgcmV0dXJuIGQucDJbMF07XG4gICAgICAgIH0pXG4gICAgICAgIC5hdHRyKCd5MicsIGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgcmV0dXJuIGQucDJbMV07XG4gICAgICAgIH0pXG4gICAgICAgIC5hdHRyKCdzdHJva2UnLCAnYmxhY2snKVxuICAgICAgICAuYXR0cignc3Ryb2tlLXdpZHRoJywgMik7XG5cbiAgICAgIGRyYWdcbiAgICAgICAgLm9uKCdkcmFnJywgZnVuY3Rpb24gKGQsIGkpIHtcbiAgICAgICAgICB2YXIgZXYgPSBkMy5ldmVudDtcbiAgICAgICAgICBpID0gaSArIDE7XG4gICAgICAgICAgc3RydW1bJ3AnICsgaV1bMF0gPSBNYXRoLm1pbihcbiAgICAgICAgICAgIE1hdGgubWF4KHN0cnVtLm1pblggKyAxLCBldi54KSxcbiAgICAgICAgICAgIHN0cnVtLm1heFgsXG4gICAgICAgICAgKTtcbiAgICAgICAgICBzdHJ1bVsncCcgKyBpXVsxXSA9IE1hdGgubWluKE1hdGgubWF4KHN0cnVtLm1pblksIGV2LnkpLCBzdHJ1bS5tYXhZKTtcbiAgICAgICAgICBkcmF3U3RydW0oc3RydW0sIGkgLSAxKTtcbiAgICAgICAgfSlcbiAgICAgICAgLm9uKCdkcmFnZW5kJywgb25EcmFnRW5kKCkpO1xuXG4gICAgICBjaXJjbGVzXG4gICAgICAgIC5lbnRlcigpXG4gICAgICAgIC5hcHBlbmQoJ2NpcmNsZScpXG4gICAgICAgIC5hdHRyKCdpZCcsICdzdHJ1bS0nICsgaWQpXG4gICAgICAgIC5hdHRyKCdjbGFzcycsICdzdHJ1bScpO1xuXG4gICAgICBjaXJjbGVzXG4gICAgICAgIC5hdHRyKCdjeCcsIGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgcmV0dXJuIGRbMF07XG4gICAgICAgIH0pXG4gICAgICAgIC5hdHRyKCdjeScsIGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgcmV0dXJuIGRbMV07XG4gICAgICAgIH0pXG4gICAgICAgIC5hdHRyKCdyJywgNSlcbiAgICAgICAgLnN0eWxlKCdvcGFjaXR5JywgZnVuY3Rpb24gKGQsIGkpIHtcbiAgICAgICAgICByZXR1cm4gYWN0aXZlUG9pbnQgIT09IHVuZGVmaW5lZCAmJiBpID09PSBhY3RpdmVQb2ludCA/IDAuOCA6IDA7XG4gICAgICAgIH0pXG4gICAgICAgIC5vbignbW91c2VvdmVyJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGQzLnNlbGVjdCh0aGlzKS5zdHlsZSgnb3BhY2l0eScsIDAuOCk7XG4gICAgICAgIH0pXG4gICAgICAgIC5vbignbW91c2VvdXQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgZDMuc2VsZWN0KHRoaXMpLnN0eWxlKCdvcGFjaXR5JywgMCk7XG4gICAgICAgIH0pXG4gICAgICAgIC5jYWxsKGRyYWcpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRpbWVuc2lvbnNGb3JQb2ludChwKSB7XG4gICAgICB2YXIgZGltcyA9IHsgaTogLTEsIGxlZnQ6IHVuZGVmaW5lZCwgcmlnaHQ6IHVuZGVmaW5lZCB9O1xuICAgICAgX18uZGltZW5zaW9ucy5zb21lKGZ1bmN0aW9uIChkaW0sIGkpIHtcbiAgICAgICAgaWYgKHhzY2FsZShkaW0pIDwgcFswXSkge1xuICAgICAgICAgIHZhciBuZXh0ID0gX18uZGltZW5zaW9uc1tpICsgMV07XG4gICAgICAgICAgZGltcy5pID0gaTtcbiAgICAgICAgICBkaW1zLmxlZnQgPSBkaW07XG4gICAgICAgICAgZGltcy5yaWdodCA9IG5leHQ7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSk7XG5cbiAgICAgIGlmIChkaW1zLmxlZnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyBFdmVudCBvbiB0aGUgbGVmdCBzaWRlIG9mIHRoZSBmaXJzdCBheGlzLlxuICAgICAgICBkaW1zLmkgPSAwO1xuICAgICAgICBkaW1zLmxlZnQgPSBfXy5kaW1lbnNpb25zWzBdO1xuICAgICAgICBkaW1zLnJpZ2h0ID0gX18uZGltZW5zaW9uc1sxXTtcbiAgICAgIH0gZWxzZSBpZiAoZGltcy5yaWdodCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIEV2ZW50IG9uIHRoZSByaWdodCBzaWRlIG9mIHRoZSBsYXN0IGF4aXNcbiAgICAgICAgZGltcy5pID0gX18uZGltZW5zaW9ucy5sZW5ndGggLSAxO1xuICAgICAgICBkaW1zLnJpZ2h0ID0gZGltcy5sZWZ0O1xuICAgICAgICBkaW1zLmxlZnQgPSBfXy5kaW1lbnNpb25zW19fLmRpbWVuc2lvbnMubGVuZ3RoIC0gMl07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBkaW1zO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG9uRHJhZ1N0YXJ0KCkge1xuICAgICAgLy8gRmlyc3Qgd2UgbmVlZCB0byBkZXRlcm1pbmUgYmV0d2VlbiB3aGljaCB0d28gYXhlcyB0aGUgc3R1cm0gd2FzIHN0YXJ0ZWQuXG4gICAgICAvLyBUaGlzIHdpbGwgZGV0ZXJtaW5lIHRoZSBmcmVlZG9tIG9mIG1vdmVtZW50LCBiZWNhdXNlIGEgc3RydW0gY2FuXG4gICAgICAvLyBsb2dpY2FsbHkgb25seSBoYXBwZW4gYmV0d2VlbiB0d28gYXhlcywgc28gbm8gbW92ZW1lbnQgb3V0c2lkZSB0aGVzZSBheGVzXG4gICAgICAvLyBzaG91bGQgYmUgYWxsb3dlZC5cbiAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBwID0gZDMubW91c2Uoc3RydW1SZWN0WzBdWzBdKSxcbiAgICAgICAgICBkaW1zLFxuICAgICAgICAgIHN0cnVtO1xuXG4gICAgICAgIHBbMF0gPSBwWzBdIC0gX18ubWFyZ2luLmxlZnQ7XG4gICAgICAgIHBbMV0gPSBwWzFdIC0gX18ubWFyZ2luLnRvcDtcblxuICAgICAgICAoZGltcyA9IGRpbWVuc2lvbnNGb3JQb2ludChwKSksXG4gICAgICAgICAgKHN0cnVtID0ge1xuICAgICAgICAgICAgcDE6IHAsXG4gICAgICAgICAgICBkaW1zOiBkaW1zLFxuICAgICAgICAgICAgbWluWDogeHNjYWxlKGRpbXMubGVmdCksXG4gICAgICAgICAgICBtYXhYOiB4c2NhbGUoZGltcy5yaWdodCksXG4gICAgICAgICAgICBtaW5ZOiAwLFxuICAgICAgICAgICAgbWF4WTogaCgpLFxuICAgICAgICAgIH0pO1xuXG4gICAgICAgIHN0cnVtc1tkaW1zLmldID0gc3RydW07XG4gICAgICAgIHN0cnVtcy5hY3RpdmUgPSBkaW1zLmk7XG5cbiAgICAgICAgLy8gTWFrZSBzdXJlIHRoYXQgdGhlIHBvaW50IGlzIHdpdGhpbiB0aGUgYm91bmRzXG4gICAgICAgIHN0cnVtLnAxWzBdID0gTWF0aC5taW4oTWF0aC5tYXgoc3RydW0ubWluWCwgcFswXSksIHN0cnVtLm1heFgpO1xuICAgICAgICBzdHJ1bS5wMiA9IHN0cnVtLnAxLnNsaWNlKCk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG9uRHJhZygpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBldiA9IGQzLmV2ZW50LFxuICAgICAgICAgIHN0cnVtID0gc3RydW1zW3N0cnVtcy5hY3RpdmVdO1xuXG4gICAgICAgIC8vIE1ha2Ugc3VyZSB0aGF0IHRoZSBwb2ludCBpcyB3aXRoaW4gdGhlIGJvdW5kc1xuICAgICAgICBzdHJ1bS5wMlswXSA9IE1hdGgubWluKFxuICAgICAgICAgIE1hdGgubWF4KHN0cnVtLm1pblggKyAxLCBldi54IC0gX18ubWFyZ2luLmxlZnQpLFxuICAgICAgICAgIHN0cnVtLm1heFgsXG4gICAgICAgICk7XG4gICAgICAgIHN0cnVtLnAyWzFdID0gTWF0aC5taW4oXG4gICAgICAgICAgTWF0aC5tYXgoc3RydW0ubWluWSwgZXYueSAtIF9fLm1hcmdpbi50b3ApLFxuICAgICAgICAgIHN0cnVtLm1heFksXG4gICAgICAgICk7XG4gICAgICAgIGRyYXdTdHJ1bShzdHJ1bSwgMSk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNvbnRhaW5tZW50VGVzdChzdHJ1bSwgd2lkdGgpIHtcbiAgICAgIHZhciBwMSA9IFtzdHJ1bS5wMVswXSAtIHN0cnVtLm1pblgsIHN0cnVtLnAxWzFdIC0gc3RydW0ubWluWF0sXG4gICAgICAgIHAyID0gW3N0cnVtLnAyWzBdIC0gc3RydW0ubWluWCwgc3RydW0ucDJbMV0gLSBzdHJ1bS5taW5YXSxcbiAgICAgICAgbTEgPSAxIC0gd2lkdGggLyBwMVswXSxcbiAgICAgICAgYjEgPSBwMVsxXSAqICgxIC0gbTEpLFxuICAgICAgICBtMiA9IDEgLSB3aWR0aCAvIHAyWzBdLFxuICAgICAgICBiMiA9IHAyWzFdICogKDEgLSBtMik7XG5cbiAgICAgIC8vIHRlc3QgaWYgcG9pbnQgZmFsbHMgYmV0d2VlbiBsaW5lc1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChwKSB7XG4gICAgICAgIHZhciB4ID0gcFswXSxcbiAgICAgICAgICB5ID0gcFsxXSxcbiAgICAgICAgICB5MSA9IG0xICogeCArIGIxLFxuICAgICAgICAgIHkyID0gbTIgKiB4ICsgYjI7XG5cbiAgICAgICAgaWYgKHkgPiBNYXRoLm1pbih5MSwgeTIpICYmIHkgPCBNYXRoLm1heCh5MSwgeTIpKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNlbGVjdGVkKCkge1xuICAgICAgdmFyIGlkcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHN0cnVtcyksXG4gICAgICAgIGJydXNoZWQgPSBfXy5kYXRhO1xuXG4gICAgICAvLyBHZXQgdGhlIGlkcyBvZiB0aGUgY3VycmVudGx5IGFjdGl2ZSBzdHJ1bXMuXG4gICAgICBpZHMgPSBpZHMuZmlsdGVyKGZ1bmN0aW9uIChkKSB7XG4gICAgICAgIHJldHVybiAhaXNOYU4oZCk7XG4gICAgICB9KTtcblxuICAgICAgZnVuY3Rpb24gY3Jvc3Nlc1N0cnVtKGQsIGlkKSB7XG4gICAgICAgIHZhciBzdHJ1bSA9IHN0cnVtc1tpZF0sXG4gICAgICAgICAgdGVzdCA9IGNvbnRhaW5tZW50VGVzdChzdHJ1bSwgc3RydW1zLndpZHRoKGlkKSksXG4gICAgICAgICAgZDEgPSBzdHJ1bS5kaW1zLmxlZnQsXG4gICAgICAgICAgZDIgPSBzdHJ1bS5kaW1zLnJpZ2h0LFxuICAgICAgICAgIHkxID0geXNjYWxlW2QxXSxcbiAgICAgICAgICB5MiA9IHlzY2FsZVtkMl0sXG4gICAgICAgICAgcG9pbnQgPSBbeTEoZFtkMV0pIC0gc3RydW0ubWluWCwgeTIoZFtkMl0pIC0gc3RydW0ubWluWF07XG4gICAgICAgIHJldHVybiB0ZXN0KHBvaW50KTtcbiAgICAgIH1cblxuICAgICAgaWYgKGlkcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIGJydXNoZWQ7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBicnVzaGVkLmZpbHRlcihmdW5jdGlvbiAoZCkge1xuICAgICAgICBzd2l0Y2ggKGJydXNoLnByZWRpY2F0ZSkge1xuICAgICAgICAgIGNhc2UgJ0FORCc6XG4gICAgICAgICAgICByZXR1cm4gaWRzLmV2ZXJ5KGZ1bmN0aW9uIChpZCkge1xuICAgICAgICAgICAgICByZXR1cm4gY3Jvc3Nlc1N0cnVtKGQsIGlkKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIGNhc2UgJ09SJzpcbiAgICAgICAgICAgIHJldHVybiBpZHMuc29tZShmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGNyb3NzZXNTdHJ1bShkLCBpZCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgJ1Vua25vd24gYnJ1c2ggcHJlZGljYXRlICcgKyBfXy5icnVzaFByZWRpY2F0ZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVtb3ZlU3RydW0oKSB7XG4gICAgICB2YXIgc3RydW0gPSBzdHJ1bXNbc3RydW1zLmFjdGl2ZV0sXG4gICAgICAgIHN2ZyA9IHBjLnNlbGVjdGlvbi5zZWxlY3QoJ3N2ZycpLnNlbGVjdCgnZyNzdHJ1bXMnKTtcblxuICAgICAgZGVsZXRlIHN0cnVtc1tzdHJ1bXMuYWN0aXZlXTtcbiAgICAgIHN0cnVtcy5hY3RpdmUgPSB1bmRlZmluZWQ7XG4gICAgICBzdmcuc2VsZWN0QWxsKCdsaW5lI3N0cnVtLScgKyBzdHJ1bS5kaW1zLmkpLnJlbW92ZSgpO1xuICAgICAgc3ZnLnNlbGVjdEFsbCgnY2lyY2xlI3N0cnVtLScgKyBzdHJ1bS5kaW1zLmkpLnJlbW92ZSgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG9uRHJhZ0VuZCgpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBicnVzaGVkID0gX18uZGF0YSxcbiAgICAgICAgICBzdHJ1bSA9IHN0cnVtc1tzdHJ1bXMuYWN0aXZlXTtcblxuICAgICAgICAvLyBPa2F5LCBzb21ld2hhdCB1bmV4cGVjdGVkLCBidXQgbm90IHRvdGFsbHkgdW5zdXJwcmlzaW5nLCBhIG1vdXNjbGljayBpc1xuICAgICAgICAvLyBjb25zaWRlcmVkIGEgZHJhZyB3aXRob3V0IG1vdmUuIFNvIHdlIGhhdmUgdG8gZGVhbCB3aXRoIHRoYXQgY2FzZVxuICAgICAgICBpZiAoXG4gICAgICAgICAgc3RydW0gJiZcbiAgICAgICAgICBzdHJ1bS5wMVswXSA9PT0gc3RydW0ucDJbMF0gJiZcbiAgICAgICAgICBzdHJ1bS5wMVsxXSA9PT0gc3RydW0ucDJbMV1cbiAgICAgICAgKSB7XG4gICAgICAgICAgcmVtb3ZlU3RydW0oc3RydW1zKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGJydXNoZWQgPSBzZWxlY3RlZChzdHJ1bXMpO1xuICAgICAgICBzdHJ1bXMuYWN0aXZlID0gdW5kZWZpbmVkO1xuICAgICAgICBfXy5icnVzaGVkID0gYnJ1c2hlZDtcbiAgICAgICAgcGMucmVuZGVyQnJ1c2hlZCgpO1xuICAgICAgICBldmVudHMuYnJ1c2hlbmQuY2FsbChwYywgX18uYnJ1c2hlZCk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGJydXNoUmVzZXQoc3RydW1zKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgaWRzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoc3RydW1zKS5maWx0ZXIoZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICByZXR1cm4gIWlzTmFOKGQpO1xuICAgICAgICB9KTtcblxuICAgICAgICBpZHMuZm9yRWFjaChmdW5jdGlvbiAoZCkge1xuICAgICAgICAgIHN0cnVtcy5hY3RpdmUgPSBkO1xuICAgICAgICAgIHJlbW92ZVN0cnVtKHN0cnVtcyk7XG4gICAgICAgIH0pO1xuICAgICAgICBvbkRyYWdFbmQoc3RydW1zKSgpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsKCkge1xuICAgICAgdmFyIGRyYWcgPSBkMy5iZWhhdmlvci5kcmFnKCk7XG5cbiAgICAgIC8vIE1hcCBvZiBjdXJyZW50IHN0cnVtcy4gU3RydW1zIGFyZSBzdG9yZWQgcGVyIHNlZ21lbnQgb2YgdGhlIFBDLiBBIHNlZ21lbnQsXG4gICAgICAvLyBiZWluZyB0aGUgYXJlYSBiZXR3ZWVuIHR3byBheGVzLiBUaGUgbGVmdCBtb3N0IGFyZWEgaXMgaW5kZXhlZCBhdCAwLlxuICAgICAgc3RydW1zLmFjdGl2ZSA9IHVuZGVmaW5lZDtcbiAgICAgIC8vIFJldHVybnMgdGhlIHdpZHRoIG9mIHRoZSBQQyBzZWdtZW50IHdoZXJlIGN1cnJlbnRseSBhIHN0cnVtIGlzIGJlaW5nXG4gICAgICAvLyBwbGFjZWQuIE5PVEU6IGV2ZW4gdGhvdWdoIHRoZXkgYXJlIGV2ZW5seSBzcGFjZWQgaW4gb3VyIGN1cnJlbnRcbiAgICAgIC8vIGltcGxlbWVudGF0aW9uLCB3ZSBrZWVwIGZvciB3aGVuIG5vbi1ldmVuIHNwYWNlZCBzZWdtZW50cyBhcmUgc3VwcG9ydGVkIGFzXG4gICAgICAvLyB3ZWxsLlxuICAgICAgc3RydW1zLndpZHRoID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgIHZhciBzdHJ1bSA9IHN0cnVtc1tpZF07XG5cbiAgICAgICAgaWYgKHN0cnVtID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHN0cnVtLm1heFggLSBzdHJ1bS5taW5YO1xuICAgICAgfTtcblxuICAgICAgcGMub24oJ2F4ZXNyZW9yZGVyLnN0cnVtcycsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGlkcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHN0cnVtcykuZmlsdGVyKGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgcmV0dXJuICFpc05hTihkKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gQ2hlY2tzIGlmIHRoZSBmaXJzdCBkaW1lbnNpb24gaXMgZGlyZWN0bHkgbGVmdCBvZiB0aGUgc2Vjb25kIGRpbWVuc2lvbi5cbiAgICAgICAgZnVuY3Rpb24gY29uc2VjdXRpdmUoZmlyc3QsIHNlY29uZCkge1xuICAgICAgICAgIHZhciBsZW5ndGggPSBfXy5kaW1lbnNpb25zLmxlbmd0aDtcbiAgICAgICAgICByZXR1cm4gX18uZGltZW5zaW9ucy5zb21lKGZ1bmN0aW9uIChkLCBpKSB7XG4gICAgICAgICAgICByZXR1cm4gZCA9PT0gZmlyc3RcbiAgICAgICAgICAgICAgPyBpICsgaSA8IGxlbmd0aCAmJiBfXy5kaW1lbnNpb25zW2kgKyAxXSA9PT0gc2Vjb25kXG4gICAgICAgICAgICAgIDogZmFsc2U7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaWRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAvLyBXZSBoYXZlIHNvbWUgc3RydW1zLCB3aGljaCBtaWdodCBuZWVkIHRvIGJlIHJlbW92ZWQuXG4gICAgICAgICAgaWRzLmZvckVhY2goZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICAgIHZhciBkaW1zID0gc3RydW1zW2RdLmRpbXM7XG4gICAgICAgICAgICBzdHJ1bXMuYWN0aXZlID0gZDtcbiAgICAgICAgICAgIC8vIElmIHRoZSB0d28gZGltZW5zaW9ucyBvZiB0aGUgY3VycmVudCBzdHJ1bSBhcmUgbm90IG5leHQgdG8gZWFjaCBvdGhlclxuICAgICAgICAgICAgLy8gYW55IG1vcmUsIHRoYW4gd2UnbGwgbmVlZCB0byByZW1vdmUgdGhlIHN0cnVtLiBPdGhlcndpc2Ugd2Uga2VlcCBpdC5cbiAgICAgICAgICAgIGlmICghY29uc2VjdXRpdmUoZGltcy5sZWZ0LCBkaW1zLnJpZ2h0KSkge1xuICAgICAgICAgICAgICByZW1vdmVTdHJ1bShzdHJ1bXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIG9uRHJhZ0VuZChzdHJ1bXMpKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICAvLyBBZGQgYSBuZXcgc3ZnIGdyb3VwIGluIHdoaWNoIHdlIGRyYXcgdGhlIHN0cnVtcy5cbiAgICAgIHBjLnNlbGVjdGlvblxuICAgICAgICAuc2VsZWN0KCdzdmcnKVxuICAgICAgICAuYXBwZW5kKCdnJylcbiAgICAgICAgLmF0dHIoJ2lkJywgJ3N0cnVtcycpXG4gICAgICAgIC5hdHRyKFxuICAgICAgICAgICd0cmFuc2Zvcm0nLFxuICAgICAgICAgICd0cmFuc2xhdGUoJyArIF9fLm1hcmdpbi5sZWZ0ICsgJywnICsgX18ubWFyZ2luLnRvcCArICcpJyxcbiAgICAgICAgKTtcblxuICAgICAgLy8gSW5zdGFsbCB0aGUgcmVxdWlyZWQgYnJ1c2hSZXNldCBmdW5jdGlvblxuICAgICAgcGMuYnJ1c2hSZXNldCA9IGJydXNoUmVzZXQoc3RydW1zKTtcblxuICAgICAgZHJhZ1xuICAgICAgICAub24oJ2RyYWdzdGFydCcsIG9uRHJhZ1N0YXJ0KHN0cnVtcykpXG4gICAgICAgIC5vbignZHJhZycsIG9uRHJhZyhzdHJ1bXMpKVxuICAgICAgICAub24oJ2RyYWdlbmQnLCBvbkRyYWdFbmQoc3RydW1zKSk7XG5cbiAgICAgIC8vIE5PVEU6IFRoZSBzdHlsaW5nIG5lZWRzIHRvIGJlIGRvbmUgaGVyZSBhbmQgbm90IGluIHRoZSBjc3MuIFRoaXMgaXMgYmVjYXVzZVxuICAgICAgLy8gICAgICAgZm9yIDFEIGJydXNoaW5nLCB0aGUgY2FudmFzIGxheWVycyBzaG91bGQgbm90IGxpc3RlbiB0b1xuICAgICAgLy8gICAgICAgcG9pbnRlci1ldmVudHMuXG4gICAgICBzdHJ1bVJlY3QgPSBwYy5zZWxlY3Rpb25cbiAgICAgICAgLnNlbGVjdCgnc3ZnJylcbiAgICAgICAgLmluc2VydCgncmVjdCcsICdnI3N0cnVtcycpXG4gICAgICAgIC5hdHRyKCdpZCcsICdzdHJ1bS1ldmVudHMnKVxuICAgICAgICAuYXR0cigneCcsIF9fLm1hcmdpbi5sZWZ0KVxuICAgICAgICAuYXR0cigneScsIF9fLm1hcmdpbi50b3ApXG4gICAgICAgIC5hdHRyKCd3aWR0aCcsIHcoKSlcbiAgICAgICAgLmF0dHIoJ2hlaWdodCcsIGgoKSArIDIpXG4gICAgICAgIC5zdHlsZSgnb3BhY2l0eScsIDApXG4gICAgICAgIC5jYWxsKGRyYWcpO1xuICAgIH1cblxuICAgIGJydXNoLm1vZGVzWycyRC1zdHJ1bXMnXSA9IHtcbiAgICAgIGluc3RhbGw6IGluc3RhbGwsXG4gICAgICB1bmluc3RhbGw6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcGMuc2VsZWN0aW9uLnNlbGVjdCgnc3ZnJykuc2VsZWN0KCdnI3N0cnVtcycpLnJlbW92ZSgpO1xuICAgICAgICBwYy5zZWxlY3Rpb24uc2VsZWN0KCdzdmcnKS5zZWxlY3QoJ3JlY3Qjc3RydW0tZXZlbnRzJykucmVtb3ZlKCk7XG4gICAgICAgIHBjLm9uKCdheGVzcmVvcmRlci5zdHJ1bXMnLCB1bmRlZmluZWQpO1xuICAgICAgICBkZWxldGUgcGMuYnJ1c2hSZXNldDtcblxuICAgICAgICBzdHJ1bVJlY3QgPSB1bmRlZmluZWQ7XG4gICAgICB9LFxuICAgICAgc2VsZWN0ZWQ6IHNlbGVjdGVkLFxuICAgICAgYnJ1c2hTdGF0ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gc3RydW1zO1xuICAgICAgfSxcbiAgICB9O1xuICB9KSgpO1xuXG4gIC8vIGJydXNoIG1vZGU6IDFELUF4ZXMgd2l0aCBtdWx0aXBsZSBleHRlbnRzXG4gIC8vIHJlcXVpcmVzIGQzLnN2Zy5tdWx0aWJydXNoXG5cbiAgKGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodHlwZW9mIGQzLnN2Zy5tdWx0aWJydXNoICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBicnVzaGVzID0ge307XG5cbiAgICBmdW5jdGlvbiBpc19icnVzaGVkKHApIHtcbiAgICAgIHJldHVybiAhYnJ1c2hlc1twXS5lbXB0eSgpO1xuICAgIH1cblxuICAgIC8vIGRhdGEgd2l0aGluIGV4dGVudHNcbiAgICBmdW5jdGlvbiBzZWxlY3RlZCgpIHtcbiAgICAgIHZhciBhY3RpdmVzID0gX18uZGltZW5zaW9ucy5maWx0ZXIoaXNfYnJ1c2hlZCksXG4gICAgICAgIGV4dGVudHMgPSBhY3RpdmVzLm1hcChmdW5jdGlvbiAocCkge1xuICAgICAgICAgIHJldHVybiBicnVzaGVzW3BdLmV4dGVudCgpO1xuICAgICAgICB9KTtcblxuICAgICAgLy8gV2UgZG9uJ3Qgd2FudCB0byByZXR1cm4gdGhlIGZ1bGwgZGF0YSBzZXQgd2hlbiB0aGVyZSBhcmUgbm8gYXhlcyBicnVzaGVkLlxuICAgICAgLy8gQWN0dWFsbHksIHdoZW4gdGhlcmUgYXJlIG5vIGF4ZXMgYnJ1c2hlZCwgYnkgZGVmaW5pdGlvbiwgbm8gaXRlbXMgYXJlXG4gICAgICAvLyBzZWxlY3RlZC4gU28sIGxldCdzIGF2b2lkIHRoZSBmaWx0ZXJpbmcgYW5kIGp1c3QgcmV0dXJuIGZhbHNlLlxuICAgICAgLy9pZiAoYWN0aXZlcy5sZW5ndGggPT09IDApIHJldHVybiBmYWxzZTtcblxuICAgICAgLy8gUmVzb2x2ZXMgYnJva2VuIGV4YW1wbGVzIGZvciBub3cuIFRoZXkgZXhwZWN0IHRvIGdldCB0aGUgZnVsbCBkYXRhc2V0IGJhY2sgZnJvbSBlbXB0eSBicnVzaGVzXG4gICAgICBpZiAoYWN0aXZlcy5sZW5ndGggPT09IDApIHJldHVybiBfXy5kYXRhO1xuXG4gICAgICAvLyB0ZXN0IGlmIHdpdGhpbiByYW5nZVxuICAgICAgdmFyIHdpdGhpbiA9IHtcbiAgICAgICAgZGF0ZTogZnVuY3Rpb24gKGQsIHAsIGRpbWVuc2lvbiwgYikge1xuICAgICAgICAgIGlmICh0eXBlb2YgeXNjYWxlW3BdLnJhbmdlUG9pbnRzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAvLyBpZiBpdCBpcyBvcmRpbmFsXG4gICAgICAgICAgICByZXR1cm4gYlswXSA8PSB5c2NhbGVbcF0oZFtwXSkgJiYgeXNjYWxlW3BdKGRbcF0pIDw9IGJbMV07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBiWzBdIDw9IGRbcF0gJiYgZFtwXSA8PSBiWzFdO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgbnVtYmVyOiBmdW5jdGlvbiAoZCwgcCwgZGltZW5zaW9uLCBiKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiB5c2NhbGVbcF0ucmFuZ2VQb2ludHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIC8vIGlmIGl0IGlzIG9yZGluYWxcbiAgICAgICAgICAgIHJldHVybiBiWzBdIDw9IHlzY2FsZVtwXShkW3BdKSAmJiB5c2NhbGVbcF0oZFtwXSkgPD0gYlsxXTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGJbMF0gPD0gZFtwXSAmJiBkW3BdIDw9IGJbMV07XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBzdHJpbmc6IGZ1bmN0aW9uIChkLCBwLCBkaW1lbnNpb24sIGIpIHtcbiAgICAgICAgICByZXR1cm4gYlswXSA8PSB5c2NhbGVbcF0oZFtwXSkgJiYgeXNjYWxlW3BdKGRbcF0pIDw9IGJbMV07XG4gICAgICAgIH0sXG4gICAgICB9O1xuXG4gICAgICByZXR1cm4gX18uZGF0YS5maWx0ZXIoZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgc3dpdGNoIChicnVzaC5wcmVkaWNhdGUpIHtcbiAgICAgICAgICBjYXNlICdBTkQnOlxuICAgICAgICAgICAgcmV0dXJuIGFjdGl2ZXMuZXZlcnkoZnVuY3Rpb24gKHAsIGRpbWVuc2lvbikge1xuICAgICAgICAgICAgICByZXR1cm4gZXh0ZW50c1tkaW1lbnNpb25dLnNvbWUoZnVuY3Rpb24gKGIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gd2l0aGluW19fLnR5cGVzW3BdXShkLCBwLCBkaW1lbnNpb24sIGIpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIGNhc2UgJ09SJzpcbiAgICAgICAgICAgIHJldHVybiBhY3RpdmVzLnNvbWUoZnVuY3Rpb24gKHAsIGRpbWVuc2lvbikge1xuICAgICAgICAgICAgICByZXR1cm4gZXh0ZW50c1tkaW1lbnNpb25dLnNvbWUoZnVuY3Rpb24gKGIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gd2l0aGluW19fLnR5cGVzW3BdXShkLCBwLCBkaW1lbnNpb24sIGIpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyAnVW5rbm93biBicnVzaCBwcmVkaWNhdGUgJyArIF9fLmJydXNoUHJlZGljYXRlO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBicnVzaEV4dGVudHMoKSB7XG4gICAgICB2YXIgZXh0ZW50cyA9IHt9O1xuICAgICAgX18uZGltZW5zaW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChkKSB7XG4gICAgICAgIHZhciBicnVzaCA9IGJydXNoZXNbZF07XG4gICAgICAgIGlmIChicnVzaCAhPT0gdW5kZWZpbmVkICYmICFicnVzaC5lbXB0eSgpKSB7XG4gICAgICAgICAgdmFyIGV4dGVudCA9IGJydXNoLmV4dGVudCgpO1xuICAgICAgICAgIGV4dGVudHNbZF0gPSBleHRlbnQ7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGV4dGVudHM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYnJ1c2hGb3IoYXhpcykge1xuICAgICAgdmFyIGJydXNoID0gZDMuc3ZnLm11bHRpYnJ1c2goKTtcblxuICAgICAgYnJ1c2hcbiAgICAgICAgLnkoeXNjYWxlW2F4aXNdKVxuICAgICAgICAub24oJ2JydXNoc3RhcnQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKGQzLmV2ZW50LnNvdXJjZUV2ZW50ICE9PSBudWxsKSB7XG4gICAgICAgICAgICBkMy5ldmVudC5zb3VyY2VFdmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICAgIC5vbignYnJ1c2gnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgYnJ1c2hVcGRhdGVkKHNlbGVjdGVkKCkpO1xuICAgICAgICB9KVxuICAgICAgICAub24oJ2JydXNoZW5kJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIC8vIGQzLnN2Zy5tdWx0aWJydXNoIGNsZWFycyBleHRlbnRzIGp1c3QgYmVmb3JlIGNhbGxpbmcgJ2JydXNoZW5kJ1xuICAgICAgICAgIC8vIHNvIHdlIGhhdmUgdG8gdXBkYXRlIGhlcmUgYWdhaW4uXG4gICAgICAgICAgLy8gVGhpcyBmaXhlcyBpc3N1ZSAjMTAzIGZvciBub3csIGJ1dCBzaG91bGQgYmUgY2hhbmdlZCBpbiBkMy5zdmcubXVsdGlicnVzaFxuICAgICAgICAgIC8vIHRvIGF2b2lkIHVubmVjZXNzYXJ5IGNvbXB1dGF0aW9uLlxuICAgICAgICAgIGJydXNoVXBkYXRlZChzZWxlY3RlZCgpKTtcbiAgICAgICAgICBldmVudHMuYnJ1c2hlbmQuY2FsbChwYywgX18uYnJ1c2hlZCk7XG4gICAgICAgIH0pXG4gICAgICAgIC5leHRlbnRBZGFwdGlvbihmdW5jdGlvbiAoc2VsZWN0aW9uKSB7XG4gICAgICAgICAgc2VsZWN0aW9uLnN0eWxlKCd2aXNpYmlsaXR5JywgbnVsbCkuYXR0cigneCcsIC0xNSkuYXR0cignd2lkdGgnLCAzMCk7XG4gICAgICAgIH0pXG4gICAgICAgIC5yZXNpemVBZGFwdGlvbihmdW5jdGlvbiAoc2VsZWN0aW9uKSB7XG4gICAgICAgICAgc2VsZWN0aW9uLnNlbGVjdEFsbCgncmVjdCcpLmF0dHIoJ3gnLCAtMTUpLmF0dHIoJ3dpZHRoJywgMzApO1xuICAgICAgICB9KTtcblxuICAgICAgYnJ1c2hlc1theGlzXSA9IGJydXNoO1xuICAgICAgcmV0dXJuIGJydXNoO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGJydXNoUmVzZXQoZGltZW5zaW9uKSB7XG4gICAgICBfXy5icnVzaGVkID0gZmFsc2U7XG4gICAgICBpZiAoZykge1xuICAgICAgICBnLnNlbGVjdEFsbCgnLmJydXNoJykuZWFjaChmdW5jdGlvbiAoZCkge1xuICAgICAgICAgIGQzLnNlbGVjdCh0aGlzKS5jYWxsKGJydXNoZXNbZF0uY2xlYXIoKSk7XG4gICAgICAgIH0pO1xuICAgICAgICBwYy5yZW5kZXJCcnVzaGVkKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsKCkge1xuICAgICAgaWYgKCFnKSBwYy5jcmVhdGVBeGVzKCk7XG5cbiAgICAgIC8vIEFkZCBhbmQgc3RvcmUgYSBicnVzaCBmb3IgZWFjaCBheGlzLlxuICAgICAgZy5hcHBlbmQoJ3N2ZzpnJylcbiAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2JydXNoJylcbiAgICAgICAgLmVhY2goZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICBkMy5zZWxlY3QodGhpcykuY2FsbChicnVzaEZvcihkKSk7XG4gICAgICAgIH0pXG4gICAgICAgIC5zZWxlY3RBbGwoJ3JlY3QnKVxuICAgICAgICAuc3R5bGUoJ3Zpc2liaWxpdHknLCBudWxsKVxuICAgICAgICAuYXR0cigneCcsIC0xNSlcbiAgICAgICAgLmF0dHIoJ3dpZHRoJywgMzApO1xuXG4gICAgICBwYy5icnVzaEV4dGVudHMgPSBicnVzaEV4dGVudHM7XG4gICAgICBwYy5icnVzaFJlc2V0ID0gYnJ1c2hSZXNldDtcbiAgICAgIHJldHVybiBwYztcbiAgICB9XG5cbiAgICBicnVzaC5tb2Rlc1snMUQtYXhlcy1tdWx0aSddID0ge1xuICAgICAgaW5zdGFsbDogaW5zdGFsbCxcbiAgICAgIHVuaW5zdGFsbDogZnVuY3Rpb24gKCkge1xuICAgICAgICBnLnNlbGVjdEFsbCgnLmJydXNoJykucmVtb3ZlKCk7XG4gICAgICAgIGJydXNoZXMgPSB7fTtcbiAgICAgICAgZGVsZXRlIHBjLmJydXNoRXh0ZW50cztcbiAgICAgICAgZGVsZXRlIHBjLmJydXNoUmVzZXQ7XG4gICAgICB9LFxuICAgICAgc2VsZWN0ZWQ6IHNlbGVjdGVkLFxuICAgICAgYnJ1c2hTdGF0ZTogYnJ1c2hFeHRlbnRzLFxuICAgIH07XG4gIH0pKCk7XG4gIC8vIGJydXNoIG1vZGU6IGFuZ3VsYXJcbiAgLy8gY29kZSBiYXNlZCBvbiAyRC5zdHJ1bXMuanNcblxuICAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBhcmNzID0ge30sXG4gICAgICBzdHJ1bVJlY3Q7XG5cbiAgICBmdW5jdGlvbiBkcmF3U3RydW0oYXJjLCBhY3RpdmVQb2ludCkge1xuICAgICAgdmFyIHN2ZyA9IHBjLnNlbGVjdGlvbi5zZWxlY3QoJ3N2ZycpLnNlbGVjdCgnZyNhcmNzJyksXG4gICAgICAgIGlkID0gYXJjLmRpbXMuaSxcbiAgICAgICAgcG9pbnRzID0gW2FyYy5wMiwgYXJjLnAzXSxcbiAgICAgICAgbGluZSA9IHN2Zy5zZWxlY3RBbGwoJ2xpbmUjYXJjLScgKyBpZCkuZGF0YShbXG4gICAgICAgICAgeyBwMTogYXJjLnAxLCBwMjogYXJjLnAyIH0sXG4gICAgICAgICAgeyBwMTogYXJjLnAxLCBwMjogYXJjLnAzIH0sXG4gICAgICAgIF0pLFxuICAgICAgICBjaXJjbGVzID0gc3ZnLnNlbGVjdEFsbCgnY2lyY2xlI2FyYy0nICsgaWQpLmRhdGEocG9pbnRzKSxcbiAgICAgICAgZHJhZyA9IGQzLmJlaGF2aW9yLmRyYWcoKSxcbiAgICAgICAgcGF0aCA9IHN2Zy5zZWxlY3RBbGwoJ3BhdGgjYXJjLScgKyBpZCkuZGF0YShbYXJjXSk7XG5cbiAgICAgIHBhdGhcbiAgICAgICAgLmVudGVyKClcbiAgICAgICAgLmFwcGVuZCgncGF0aCcpXG4gICAgICAgIC5hdHRyKCdpZCcsICdhcmMtJyArIGlkKVxuICAgICAgICAuYXR0cignY2xhc3MnLCAnYXJjJylcbiAgICAgICAgLnN0eWxlKCdmaWxsJywgJ29yYW5nZScpXG4gICAgICAgIC5zdHlsZSgnb3BhY2l0eScsIDAuNSk7XG5cbiAgICAgIHBhdGhcbiAgICAgICAgLmF0dHIoJ2QnLCBhcmMuYXJjKVxuICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgnICsgYXJjLnAxWzBdICsgJywnICsgYXJjLnAxWzFdICsgJyknKTtcblxuICAgICAgbGluZVxuICAgICAgICAuZW50ZXIoKVxuICAgICAgICAuYXBwZW5kKCdsaW5lJylcbiAgICAgICAgLmF0dHIoJ2lkJywgJ2FyYy0nICsgaWQpXG4gICAgICAgIC5hdHRyKCdjbGFzcycsICdhcmMnKTtcblxuICAgICAgbGluZVxuICAgICAgICAuYXR0cigneDEnLCBmdW5jdGlvbiAoZCkge1xuICAgICAgICAgIHJldHVybiBkLnAxWzBdO1xuICAgICAgICB9KVxuICAgICAgICAuYXR0cigneTEnLCBmdW5jdGlvbiAoZCkge1xuICAgICAgICAgIHJldHVybiBkLnAxWzFdO1xuICAgICAgICB9KVxuICAgICAgICAuYXR0cigneDInLCBmdW5jdGlvbiAoZCkge1xuICAgICAgICAgIHJldHVybiBkLnAyWzBdO1xuICAgICAgICB9KVxuICAgICAgICAuYXR0cigneTInLCBmdW5jdGlvbiAoZCkge1xuICAgICAgICAgIHJldHVybiBkLnAyWzFdO1xuICAgICAgICB9KVxuICAgICAgICAuYXR0cignc3Ryb2tlJywgJ2JsYWNrJylcbiAgICAgICAgLmF0dHIoJ3N0cm9rZS13aWR0aCcsIDIpO1xuXG4gICAgICBkcmFnXG4gICAgICAgIC5vbignZHJhZycsIGZ1bmN0aW9uIChkLCBpKSB7XG4gICAgICAgICAgdmFyIGV2ID0gZDMuZXZlbnQsXG4gICAgICAgICAgICBhbmdsZSA9IDA7XG5cbiAgICAgICAgICBpID0gaSArIDI7XG5cbiAgICAgICAgICBhcmNbJ3AnICsgaV1bMF0gPSBNYXRoLm1pbihNYXRoLm1heChhcmMubWluWCArIDEsIGV2LngpLCBhcmMubWF4WCk7XG4gICAgICAgICAgYXJjWydwJyArIGldWzFdID0gTWF0aC5taW4oTWF0aC5tYXgoYXJjLm1pblksIGV2LnkpLCBhcmMubWF4WSk7XG5cbiAgICAgICAgICBhbmdsZSA9IGkgPT09IDMgPyBhcmNzLnN0YXJ0QW5nbGUoaWQpIDogYXJjcy5lbmRBbmdsZShpZCk7XG5cbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAoYXJjLnN0YXJ0QW5nbGUgPCBNYXRoLlBJICYmXG4gICAgICAgICAgICAgIGFyYy5lbmRBbmdsZSA8IE1hdGguUEkgJiZcbiAgICAgICAgICAgICAgYW5nbGUgPCBNYXRoLlBJKSB8fFxuICAgICAgICAgICAgKGFyYy5zdGFydEFuZ2xlID49IE1hdGguUEkgJiZcbiAgICAgICAgICAgICAgYXJjLmVuZEFuZ2xlID49IE1hdGguUEkgJiZcbiAgICAgICAgICAgICAgYW5nbGUgPj0gTWF0aC5QSSlcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIGlmIChpID09PSAyKSB7XG4gICAgICAgICAgICAgIGFyYy5lbmRBbmdsZSA9IGFuZ2xlO1xuICAgICAgICAgICAgICBhcmMuYXJjLmVuZEFuZ2xlKGFuZ2xlKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaSA9PT0gMykge1xuICAgICAgICAgICAgICBhcmMuc3RhcnRBbmdsZSA9IGFuZ2xlO1xuICAgICAgICAgICAgICBhcmMuYXJjLnN0YXJ0QW5nbGUoYW5nbGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGRyYXdTdHJ1bShhcmMsIGkgLSAyKTtcbiAgICAgICAgfSlcbiAgICAgICAgLm9uKCdkcmFnZW5kJywgb25EcmFnRW5kKCkpO1xuXG4gICAgICBjaXJjbGVzXG4gICAgICAgIC5lbnRlcigpXG4gICAgICAgIC5hcHBlbmQoJ2NpcmNsZScpXG4gICAgICAgIC5hdHRyKCdpZCcsICdhcmMtJyArIGlkKVxuICAgICAgICAuYXR0cignY2xhc3MnLCAnYXJjJyk7XG5cbiAgICAgIGNpcmNsZXNcbiAgICAgICAgLmF0dHIoJ2N4JywgZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICByZXR1cm4gZFswXTtcbiAgICAgICAgfSlcbiAgICAgICAgLmF0dHIoJ2N5JywgZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICByZXR1cm4gZFsxXTtcbiAgICAgICAgfSlcbiAgICAgICAgLmF0dHIoJ3InLCA1KVxuICAgICAgICAuc3R5bGUoJ29wYWNpdHknLCBmdW5jdGlvbiAoZCwgaSkge1xuICAgICAgICAgIHJldHVybiBhY3RpdmVQb2ludCAhPT0gdW5kZWZpbmVkICYmIGkgPT09IGFjdGl2ZVBvaW50ID8gMC44IDogMDtcbiAgICAgICAgfSlcbiAgICAgICAgLm9uKCdtb3VzZW92ZXInLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgZDMuc2VsZWN0KHRoaXMpLnN0eWxlKCdvcGFjaXR5JywgMC44KTtcbiAgICAgICAgfSlcbiAgICAgICAgLm9uKCdtb3VzZW91dCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBkMy5zZWxlY3QodGhpcykuc3R5bGUoJ29wYWNpdHknLCAwKTtcbiAgICAgICAgfSlcbiAgICAgICAgLmNhbGwoZHJhZyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGltZW5zaW9uc0ZvclBvaW50KHApIHtcbiAgICAgIHZhciBkaW1zID0geyBpOiAtMSwgbGVmdDogdW5kZWZpbmVkLCByaWdodDogdW5kZWZpbmVkIH07XG4gICAgICBfXy5kaW1lbnNpb25zLnNvbWUoZnVuY3Rpb24gKGRpbSwgaSkge1xuICAgICAgICBpZiAoeHNjYWxlKGRpbSkgPCBwWzBdKSB7XG4gICAgICAgICAgdmFyIG5leHQgPSBfXy5kaW1lbnNpb25zW2kgKyAxXTtcbiAgICAgICAgICBkaW1zLmkgPSBpO1xuICAgICAgICAgIGRpbXMubGVmdCA9IGRpbTtcbiAgICAgICAgICBkaW1zLnJpZ2h0ID0gbmV4dDtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9KTtcblxuICAgICAgaWYgKGRpbXMubGVmdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIEV2ZW50IG9uIHRoZSBsZWZ0IHNpZGUgb2YgdGhlIGZpcnN0IGF4aXMuXG4gICAgICAgIGRpbXMuaSA9IDA7XG4gICAgICAgIGRpbXMubGVmdCA9IF9fLmRpbWVuc2lvbnNbMF07XG4gICAgICAgIGRpbXMucmlnaHQgPSBfXy5kaW1lbnNpb25zWzFdO1xuICAgICAgfSBlbHNlIGlmIChkaW1zLnJpZ2h0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gRXZlbnQgb24gdGhlIHJpZ2h0IHNpZGUgb2YgdGhlIGxhc3QgYXhpc1xuICAgICAgICBkaW1zLmkgPSBfXy5kaW1lbnNpb25zLmxlbmd0aCAtIDE7XG4gICAgICAgIGRpbXMucmlnaHQgPSBkaW1zLmxlZnQ7XG4gICAgICAgIGRpbXMubGVmdCA9IF9fLmRpbWVuc2lvbnNbX18uZGltZW5zaW9ucy5sZW5ndGggLSAyXTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGRpbXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb25EcmFnU3RhcnQoKSB7XG4gICAgICAvLyBGaXJzdCB3ZSBuZWVkIHRvIGRldGVybWluZSBiZXR3ZWVuIHdoaWNoIHR3byBheGVzIHRoZSBhcmMgd2FzIHN0YXJ0ZWQuXG4gICAgICAvLyBUaGlzIHdpbGwgZGV0ZXJtaW5lIHRoZSBmcmVlZG9tIG9mIG1vdmVtZW50LCBiZWNhdXNlIGEgYXJjIGNhblxuICAgICAgLy8gbG9naWNhbGx5IG9ubHkgaGFwcGVuIGJldHdlZW4gdHdvIGF4ZXMsIHNvIG5vIG1vdmVtZW50IG91dHNpZGUgdGhlc2UgYXhlc1xuICAgICAgLy8gc2hvdWxkIGJlIGFsbG93ZWQuXG4gICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcCA9IGQzLm1vdXNlKHN0cnVtUmVjdFswXVswXSksXG4gICAgICAgICAgZGltcyxcbiAgICAgICAgICBhcmM7XG5cbiAgICAgICAgcFswXSA9IHBbMF0gLSBfXy5tYXJnaW4ubGVmdDtcbiAgICAgICAgcFsxXSA9IHBbMV0gLSBfXy5tYXJnaW4udG9wO1xuXG4gICAgICAgIChkaW1zID0gZGltZW5zaW9uc0ZvclBvaW50KHApKSxcbiAgICAgICAgICAoYXJjID0ge1xuICAgICAgICAgICAgcDE6IHAsXG4gICAgICAgICAgICBkaW1zOiBkaW1zLFxuICAgICAgICAgICAgbWluWDogeHNjYWxlKGRpbXMubGVmdCksXG4gICAgICAgICAgICBtYXhYOiB4c2NhbGUoZGltcy5yaWdodCksXG4gICAgICAgICAgICBtaW5ZOiAwLFxuICAgICAgICAgICAgbWF4WTogaCgpLFxuICAgICAgICAgICAgc3RhcnRBbmdsZTogdW5kZWZpbmVkLFxuICAgICAgICAgICAgZW5kQW5nbGU6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGFyYzogZDMuc3ZnLmFyYygpLmlubmVyUmFkaXVzKDApLFxuICAgICAgICAgIH0pO1xuXG4gICAgICAgIGFyY3NbZGltcy5pXSA9IGFyYztcbiAgICAgICAgYXJjcy5hY3RpdmUgPSBkaW1zLmk7XG5cbiAgICAgICAgLy8gTWFrZSBzdXJlIHRoYXQgdGhlIHBvaW50IGlzIHdpdGhpbiB0aGUgYm91bmRzXG4gICAgICAgIGFyYy5wMVswXSA9IE1hdGgubWluKE1hdGgubWF4KGFyYy5taW5YLCBwWzBdKSwgYXJjLm1heFgpO1xuICAgICAgICBhcmMucDIgPSBhcmMucDEuc2xpY2UoKTtcbiAgICAgICAgYXJjLnAzID0gYXJjLnAxLnNsaWNlKCk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG9uRHJhZygpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBldiA9IGQzLmV2ZW50LFxuICAgICAgICAgIGFyYyA9IGFyY3NbYXJjcy5hY3RpdmVdO1xuXG4gICAgICAgIC8vIE1ha2Ugc3VyZSB0aGF0IHRoZSBwb2ludCBpcyB3aXRoaW4gdGhlIGJvdW5kc1xuICAgICAgICBhcmMucDJbMF0gPSBNYXRoLm1pbihcbiAgICAgICAgICBNYXRoLm1heChhcmMubWluWCArIDEsIGV2LnggLSBfXy5tYXJnaW4ubGVmdCksXG4gICAgICAgICAgYXJjLm1heFgsXG4gICAgICAgICk7XG4gICAgICAgIGFyYy5wMlsxXSA9IE1hdGgubWluKFxuICAgICAgICAgIE1hdGgubWF4KGFyYy5taW5ZLCBldi55IC0gX18ubWFyZ2luLnRvcCksXG4gICAgICAgICAgYXJjLm1heFksXG4gICAgICAgICk7XG4gICAgICAgIGFyYy5wMyA9IGFyYy5wMi5zbGljZSgpO1xuICAgICAgICBkcmF3U3RydW0oYXJjLCAxKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gc29tZSBoZWxwZXIgZnVuY3Rpb25zXG4gICAgZnVuY3Rpb24gaHlwb3RoZW51c2UoYSwgYikge1xuICAgICAgcmV0dXJuIE1hdGguc3FydChhICogYSArIGIgKiBiKTtcbiAgICB9XG5cbiAgICB2YXIgcmFkID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBjID0gTWF0aC5QSSAvIDE4MDtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoYW5nbGUpIHtcbiAgICAgICAgcmV0dXJuIGFuZ2xlICogYztcbiAgICAgIH07XG4gICAgfSkoKTtcblxuICAgIHZhciBkZWcgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGMgPSAxODAgLyBNYXRoLlBJO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChhbmdsZSkge1xuICAgICAgICByZXR1cm4gYW5nbGUgKiBjO1xuICAgICAgfTtcbiAgICB9KSgpO1xuXG4gICAgLy8gWzAsIDIqUEldIC0+IFstUEkvMiwgUEkvMl1cbiAgICB2YXIgc2lnbmVkQW5nbGUgPSBmdW5jdGlvbiAoYW5nbGUpIHtcbiAgICAgIHZhciByZXQgPSBhbmdsZTtcbiAgICAgIGlmIChhbmdsZSA+IE1hdGguUEkpIHtcbiAgICAgICAgcmV0ID0gYW5nbGUgLSAxLjUgKiBNYXRoLlBJO1xuICAgICAgICByZXQgPSBhbmdsZSAtIDEuNSAqIE1hdGguUEk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXQgPSBhbmdsZSAtIDAuNSAqIE1hdGguUEk7XG4gICAgICAgIHJldCA9IGFuZ2xlIC0gMC41ICogTWF0aC5QSTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAtcmV0O1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBhbmdsZXMgYXJlIHN0b3JlZCBpbiByYWRpYW5zIGZyb20gaW4gWzAsIDIqUEldLCB3aGVyZSAwIGluIDEyIG8nY2xvY2suXG4gICAgICogSG93ZXZlciwgb25lIGNhbiBvbmx5IHNlbGVjdCBsaW5lcyBmcm9tIDAgdG8gUEksIHNvIHdlIGNvbXB1dGUgdGhlXG4gICAgICogJ3NpZ25lZCcgYW5nbGUsIHdoZXJlIDAgaXMgdGhlIGhvcml6b250YWwgbGluZSAoMyBvJ2Nsb2NrKSwgYW5kICsvLSBQSS8yXG4gICAgICogYXJlIDEyIGFuZCA2IG8nY2xvY2sgcmVzcGVjdGl2ZWx5LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNvbnRhaW5tZW50VGVzdChhcmMpIHtcbiAgICAgIHZhciBzdGFydEFuZ2xlID0gc2lnbmVkQW5nbGUoYXJjLnN0YXJ0QW5nbGUpO1xuICAgICAgdmFyIGVuZEFuZ2xlID0gc2lnbmVkQW5nbGUoYXJjLmVuZEFuZ2xlKTtcblxuICAgICAgaWYgKHN0YXJ0QW5nbGUgPiBlbmRBbmdsZSkge1xuICAgICAgICB2YXIgdG1wID0gc3RhcnRBbmdsZTtcbiAgICAgICAgc3RhcnRBbmdsZSA9IGVuZEFuZ2xlO1xuICAgICAgICBlbmRBbmdsZSA9IHRtcDtcbiAgICAgIH1cblxuICAgICAgLy8gdGVzdCBpZiBzZWdtZW50IGFuZ2xlIGlzIGNvbnRhaW5lZCBpbiBhbmdsZSBpbnRlcnZhbFxuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChhKSB7XG4gICAgICAgIGlmIChhID49IHN0YXJ0QW5nbGUgJiYgYSA8PSBlbmRBbmdsZSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZWxlY3RlZCgpIHtcbiAgICAgIHZhciBpZHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhhcmNzKSxcbiAgICAgICAgYnJ1c2hlZCA9IF9fLmRhdGE7XG5cbiAgICAgIC8vIEdldCB0aGUgaWRzIG9mIHRoZSBjdXJyZW50bHkgYWN0aXZlIGFyY3MuXG4gICAgICBpZHMgPSBpZHMuZmlsdGVyKGZ1bmN0aW9uIChkKSB7XG4gICAgICAgIHJldHVybiAhaXNOYU4oZCk7XG4gICAgICB9KTtcblxuICAgICAgZnVuY3Rpb24gY3Jvc3Nlc1N0cnVtKGQsIGlkKSB7XG4gICAgICAgIHZhciBhcmMgPSBhcmNzW2lkXSxcbiAgICAgICAgICB0ZXN0ID0gY29udGFpbm1lbnRUZXN0KGFyYyksXG4gICAgICAgICAgZDEgPSBhcmMuZGltcy5sZWZ0LFxuICAgICAgICAgIGQyID0gYXJjLmRpbXMucmlnaHQsXG4gICAgICAgICAgeTEgPSB5c2NhbGVbZDFdLFxuICAgICAgICAgIHkyID0geXNjYWxlW2QyXSxcbiAgICAgICAgICBhID0gYXJjcy53aWR0aChpZCksXG4gICAgICAgICAgYiA9IHkxKGRbZDFdKSAtIHkyKGRbZDJdKSxcbiAgICAgICAgICBjID0gaHlwb3RoZW51c2UoYSwgYiksXG4gICAgICAgICAgYW5nbGUgPSBNYXRoLmFzaW4oYiAvIGMpOyAvLyByYWQgaW4gWy1QSS8yLCBQSS8yXVxuICAgICAgICByZXR1cm4gdGVzdChhbmdsZSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChpZHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBicnVzaGVkO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYnJ1c2hlZC5maWx0ZXIoZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgc3dpdGNoIChicnVzaC5wcmVkaWNhdGUpIHtcbiAgICAgICAgICBjYXNlICdBTkQnOlxuICAgICAgICAgICAgcmV0dXJuIGlkcy5ldmVyeShmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGNyb3NzZXNTdHJ1bShkLCBpZCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICBjYXNlICdPUic6XG4gICAgICAgICAgICByZXR1cm4gaWRzLnNvbWUoZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgICAgICAgIHJldHVybiBjcm9zc2VzU3RydW0oZCwgaWQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93ICdVbmtub3duIGJydXNoIHByZWRpY2F0ZSAnICsgX18uYnJ1c2hQcmVkaWNhdGU7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlbW92ZVN0cnVtKCkge1xuICAgICAgdmFyIGFyYyA9IGFyY3NbYXJjcy5hY3RpdmVdLFxuICAgICAgICBzdmcgPSBwYy5zZWxlY3Rpb24uc2VsZWN0KCdzdmcnKS5zZWxlY3QoJ2cjYXJjcycpO1xuXG4gICAgICBkZWxldGUgYXJjc1thcmNzLmFjdGl2ZV07XG4gICAgICBhcmNzLmFjdGl2ZSA9IHVuZGVmaW5lZDtcbiAgICAgIHN2Zy5zZWxlY3RBbGwoJ2xpbmUjYXJjLScgKyBhcmMuZGltcy5pKS5yZW1vdmUoKTtcbiAgICAgIHN2Zy5zZWxlY3RBbGwoJ2NpcmNsZSNhcmMtJyArIGFyYy5kaW1zLmkpLnJlbW92ZSgpO1xuICAgICAgc3ZnLnNlbGVjdEFsbCgncGF0aCNhcmMtJyArIGFyYy5kaW1zLmkpLnJlbW92ZSgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG9uRHJhZ0VuZCgpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBicnVzaGVkID0gX18uZGF0YSxcbiAgICAgICAgICBhcmMgPSBhcmNzW2FyY3MuYWN0aXZlXTtcblxuICAgICAgICAvLyBPa2F5LCBzb21ld2hhdCB1bmV4cGVjdGVkLCBidXQgbm90IHRvdGFsbHkgdW5zdXJwcmlzaW5nLCBhIG1vdXNjbGljayBpc1xuICAgICAgICAvLyBjb25zaWRlcmVkIGEgZHJhZyB3aXRob3V0IG1vdmUuIFNvIHdlIGhhdmUgdG8gZGVhbCB3aXRoIHRoYXQgY2FzZVxuICAgICAgICBpZiAoYXJjICYmIGFyYy5wMVswXSA9PT0gYXJjLnAyWzBdICYmIGFyYy5wMVsxXSA9PT0gYXJjLnAyWzFdKSB7XG4gICAgICAgICAgcmVtb3ZlU3RydW0oYXJjcyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYXJjKSB7XG4gICAgICAgICAgdmFyIGFuZ2xlID0gYXJjcy5zdGFydEFuZ2xlKGFyY3MuYWN0aXZlKTtcblxuICAgICAgICAgIGFyYy5zdGFydEFuZ2xlID0gYW5nbGU7XG4gICAgICAgICAgYXJjLmVuZEFuZ2xlID0gYW5nbGU7XG4gICAgICAgICAgYXJjLmFyY1xuICAgICAgICAgICAgLm91dGVyUmFkaXVzKGFyY3MubGVuZ3RoKGFyY3MuYWN0aXZlKSlcbiAgICAgICAgICAgIC5zdGFydEFuZ2xlKGFuZ2xlKVxuICAgICAgICAgICAgLmVuZEFuZ2xlKGFuZ2xlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGJydXNoZWQgPSBzZWxlY3RlZChhcmNzKTtcbiAgICAgICAgYXJjcy5hY3RpdmUgPSB1bmRlZmluZWQ7XG4gICAgICAgIF9fLmJydXNoZWQgPSBicnVzaGVkO1xuICAgICAgICBwYy5yZW5kZXJCcnVzaGVkKCk7XG4gICAgICAgIGV2ZW50cy5icnVzaGVuZC5jYWxsKHBjLCBfXy5icnVzaGVkKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYnJ1c2hSZXNldChhcmNzKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgaWRzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoYXJjcykuZmlsdGVyKGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgcmV0dXJuICFpc05hTihkKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWRzLmZvckVhY2goZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICBhcmNzLmFjdGl2ZSA9IGQ7XG4gICAgICAgICAgcmVtb3ZlU3RydW0oYXJjcyk7XG4gICAgICAgIH0pO1xuICAgICAgICBvbkRyYWdFbmQoYXJjcykoKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbCgpIHtcbiAgICAgIHZhciBkcmFnID0gZDMuYmVoYXZpb3IuZHJhZygpO1xuXG4gICAgICAvLyBNYXAgb2YgY3VycmVudCBhcmNzLiBhcmNzIGFyZSBzdG9yZWQgcGVyIHNlZ21lbnQgb2YgdGhlIFBDLiBBIHNlZ21lbnQsXG4gICAgICAvLyBiZWluZyB0aGUgYXJlYSBiZXR3ZWVuIHR3byBheGVzLiBUaGUgbGVmdCBtb3N0IGFyZWEgaXMgaW5kZXhlZCBhdCAwLlxuICAgICAgYXJjcy5hY3RpdmUgPSB1bmRlZmluZWQ7XG4gICAgICAvLyBSZXR1cm5zIHRoZSB3aWR0aCBvZiB0aGUgUEMgc2VnbWVudCB3aGVyZSBjdXJyZW50bHkgYSBhcmMgaXMgYmVpbmdcbiAgICAgIC8vIHBsYWNlZC4gTk9URTogZXZlbiB0aG91Z2ggdGhleSBhcmUgZXZlbmx5IHNwYWNlZCBpbiBvdXIgY3VycmVudFxuICAgICAgLy8gaW1wbGVtZW50YXRpb24sIHdlIGtlZXAgZm9yIHdoZW4gbm9uLWV2ZW4gc3BhY2VkIHNlZ21lbnRzIGFyZSBzdXBwb3J0ZWQgYXNcbiAgICAgIC8vIHdlbGwuXG4gICAgICBhcmNzLndpZHRoID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgIHZhciBhcmMgPSBhcmNzW2lkXTtcblxuICAgICAgICBpZiAoYXJjID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGFyYy5tYXhYIC0gYXJjLm1pblg7XG4gICAgICB9O1xuXG4gICAgICAvLyByZXR1cm5zIGFuZ2xlcyBpbiBbLVBJLzIsIFBJLzJdXG4gICAgICBhbmdsZSA9IGZ1bmN0aW9uIChwMSwgcDIpIHtcbiAgICAgICAgdmFyIGEgPSBwMVswXSAtIHAyWzBdLFxuICAgICAgICAgIGIgPSBwMVsxXSAtIHAyWzFdLFxuICAgICAgICAgIGMgPSBoeXBvdGhlbnVzZShhLCBiKTtcblxuICAgICAgICByZXR1cm4gTWF0aC5hc2luKGIgLyBjKTtcbiAgICAgIH07XG5cbiAgICAgIC8vIHJldHVybnMgYW5nbGVzIGluIFswLCAyICogUEldXG4gICAgICBhcmNzLmVuZEFuZ2xlID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgIHZhciBhcmMgPSBhcmNzW2lkXTtcbiAgICAgICAgaWYgKGFyYyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc0FuZ2xlID0gYW5nbGUoYXJjLnAxLCBhcmMucDIpLFxuICAgICAgICAgIHVBbmdsZSA9IC1zQW5nbGUgKyBNYXRoLlBJIC8gMjtcblxuICAgICAgICBpZiAoYXJjLnAxWzBdID4gYXJjLnAyWzBdKSB7XG4gICAgICAgICAgdUFuZ2xlID0gMiAqIE1hdGguUEkgLSB1QW5nbGU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdUFuZ2xlO1xuICAgICAgfTtcblxuICAgICAgYXJjcy5zdGFydEFuZ2xlID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgIHZhciBhcmMgPSBhcmNzW2lkXTtcbiAgICAgICAgaWYgKGFyYyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzQW5nbGUgPSBhbmdsZShhcmMucDEsIGFyYy5wMyksXG4gICAgICAgICAgdUFuZ2xlID0gLXNBbmdsZSArIE1hdGguUEkgLyAyO1xuXG4gICAgICAgIGlmIChhcmMucDFbMF0gPiBhcmMucDNbMF0pIHtcbiAgICAgICAgICB1QW5nbGUgPSAyICogTWF0aC5QSSAtIHVBbmdsZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB1QW5nbGU7XG4gICAgICB9O1xuXG4gICAgICBhcmNzLmxlbmd0aCA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgICB2YXIgYXJjID0gYXJjc1tpZF07XG5cbiAgICAgICAgaWYgKGFyYyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBhID0gYXJjLnAxWzBdIC0gYXJjLnAyWzBdLFxuICAgICAgICAgIGIgPSBhcmMucDFbMV0gLSBhcmMucDJbMV0sXG4gICAgICAgICAgYyA9IGh5cG90aGVudXNlKGEsIGIpO1xuXG4gICAgICAgIHJldHVybiBjO1xuICAgICAgfTtcblxuICAgICAgcGMub24oJ2F4ZXNyZW9yZGVyLmFyY3MnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBpZHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhhcmNzKS5maWx0ZXIoZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICByZXR1cm4gIWlzTmFOKGQpO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBDaGVja3MgaWYgdGhlIGZpcnN0IGRpbWVuc2lvbiBpcyBkaXJlY3RseSBsZWZ0IG9mIHRoZSBzZWNvbmQgZGltZW5zaW9uLlxuICAgICAgICBmdW5jdGlvbiBjb25zZWN1dGl2ZShmaXJzdCwgc2Vjb25kKSB7XG4gICAgICAgICAgdmFyIGxlbmd0aCA9IF9fLmRpbWVuc2lvbnMubGVuZ3RoO1xuICAgICAgICAgIHJldHVybiBfXy5kaW1lbnNpb25zLnNvbWUoZnVuY3Rpb24gKGQsIGkpIHtcbiAgICAgICAgICAgIHJldHVybiBkID09PSBmaXJzdFxuICAgICAgICAgICAgICA/IGkgKyBpIDwgbGVuZ3RoICYmIF9fLmRpbWVuc2lvbnNbaSArIDFdID09PSBzZWNvbmRcbiAgICAgICAgICAgICAgOiBmYWxzZTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpZHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIC8vIFdlIGhhdmUgc29tZSBhcmNzLCB3aGljaCBtaWdodCBuZWVkIHRvIGJlIHJlbW92ZWQuXG4gICAgICAgICAgaWRzLmZvckVhY2goZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICAgIHZhciBkaW1zID0gYXJjc1tkXS5kaW1zO1xuICAgICAgICAgICAgYXJjcy5hY3RpdmUgPSBkO1xuICAgICAgICAgICAgLy8gSWYgdGhlIHR3byBkaW1lbnNpb25zIG9mIHRoZSBjdXJyZW50IGFyYyBhcmUgbm90IG5leHQgdG8gZWFjaCBvdGhlclxuICAgICAgICAgICAgLy8gYW55IG1vcmUsIHRoYW4gd2UnbGwgbmVlZCB0byByZW1vdmUgdGhlIGFyYy4gT3RoZXJ3aXNlIHdlIGtlZXAgaXQuXG4gICAgICAgICAgICBpZiAoIWNvbnNlY3V0aXZlKGRpbXMubGVmdCwgZGltcy5yaWdodCkpIHtcbiAgICAgICAgICAgICAgcmVtb3ZlU3RydW0oYXJjcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgb25EcmFnRW5kKGFyY3MpKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICAvLyBBZGQgYSBuZXcgc3ZnIGdyb3VwIGluIHdoaWNoIHdlIGRyYXcgdGhlIGFyY3MuXG4gICAgICBwYy5zZWxlY3Rpb25cbiAgICAgICAgLnNlbGVjdCgnc3ZnJylcbiAgICAgICAgLmFwcGVuZCgnZycpXG4gICAgICAgIC5hdHRyKCdpZCcsICdhcmNzJylcbiAgICAgICAgLmF0dHIoXG4gICAgICAgICAgJ3RyYW5zZm9ybScsXG4gICAgICAgICAgJ3RyYW5zbGF0ZSgnICsgX18ubWFyZ2luLmxlZnQgKyAnLCcgKyBfXy5tYXJnaW4udG9wICsgJyknLFxuICAgICAgICApO1xuXG4gICAgICAvLyBJbnN0YWxsIHRoZSByZXF1aXJlZCBicnVzaFJlc2V0IGZ1bmN0aW9uXG4gICAgICBwYy5icnVzaFJlc2V0ID0gYnJ1c2hSZXNldChhcmNzKTtcblxuICAgICAgZHJhZ1xuICAgICAgICAub24oJ2RyYWdzdGFydCcsIG9uRHJhZ1N0YXJ0KGFyY3MpKVxuICAgICAgICAub24oJ2RyYWcnLCBvbkRyYWcoYXJjcykpXG4gICAgICAgIC5vbignZHJhZ2VuZCcsIG9uRHJhZ0VuZChhcmNzKSk7XG5cbiAgICAgIC8vIE5PVEU6IFRoZSBzdHlsaW5nIG5lZWRzIHRvIGJlIGRvbmUgaGVyZSBhbmQgbm90IGluIHRoZSBjc3MuIFRoaXMgaXMgYmVjYXVzZVxuICAgICAgLy8gICAgICAgZm9yIDFEIGJydXNoaW5nLCB0aGUgY2FudmFzIGxheWVycyBzaG91bGQgbm90IGxpc3RlbiB0b1xuICAgICAgLy8gICAgICAgcG9pbnRlci1ldmVudHMuXG4gICAgICBzdHJ1bVJlY3QgPSBwYy5zZWxlY3Rpb25cbiAgICAgICAgLnNlbGVjdCgnc3ZnJylcbiAgICAgICAgLmluc2VydCgncmVjdCcsICdnI2FyY3MnKVxuICAgICAgICAuYXR0cignaWQnLCAnYXJjLWV2ZW50cycpXG4gICAgICAgIC5hdHRyKCd4JywgX18ubWFyZ2luLmxlZnQpXG4gICAgICAgIC5hdHRyKCd5JywgX18ubWFyZ2luLnRvcClcbiAgICAgICAgLmF0dHIoJ3dpZHRoJywgdygpKVxuICAgICAgICAuYXR0cignaGVpZ2h0JywgaCgpICsgMilcbiAgICAgICAgLnN0eWxlKCdvcGFjaXR5JywgMClcbiAgICAgICAgLmNhbGwoZHJhZyk7XG4gICAgfVxuXG4gICAgYnJ1c2gubW9kZXNbJ2FuZ3VsYXInXSA9IHtcbiAgICAgIGluc3RhbGw6IGluc3RhbGwsXG4gICAgICB1bmluc3RhbGw6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcGMuc2VsZWN0aW9uLnNlbGVjdCgnc3ZnJykuc2VsZWN0KCdnI2FyY3MnKS5yZW1vdmUoKTtcbiAgICAgICAgcGMuc2VsZWN0aW9uLnNlbGVjdCgnc3ZnJykuc2VsZWN0KCdyZWN0I2FyYy1ldmVudHMnKS5yZW1vdmUoKTtcbiAgICAgICAgcGMub24oJ2F4ZXNyZW9yZGVyLmFyY3MnLCB1bmRlZmluZWQpO1xuICAgICAgICBkZWxldGUgcGMuYnJ1c2hSZXNldDtcblxuICAgICAgICBzdHJ1bVJlY3QgPSB1bmRlZmluZWQ7XG4gICAgICB9LFxuICAgICAgc2VsZWN0ZWQ6IHNlbGVjdGVkLFxuICAgICAgYnJ1c2hTdGF0ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gYXJjcztcbiAgICAgIH0sXG4gICAgfTtcbiAgfSkoKTtcblxuICBwYy5pbnRlcmFjdGl2ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBmbGFncy5pbnRlcmFjdGl2ZSA9IHRydWU7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLy8gZXhwb3NlIGEgZmV3IG9iamVjdHNcbiAgcGMueHNjYWxlID0geHNjYWxlO1xuICBwYy55c2NhbGUgPSB5c2NhbGU7XG4gIHBjLmN0eCA9IGN0eDtcbiAgcGMuY2FudmFzID0gY2FudmFzO1xuICBwYy5nID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBnO1xuICB9O1xuXG4gIC8vIHJlc2NhbGUgZm9yIGhlaWdodCwgd2lkdGggYW5kIG1hcmdpbnNcbiAgLy8gVE9ETyBjdXJyZW50bHkgYXNzdW1lcyBjaGFydCBpcyBicnVzaGFibGUsIGFuZCBkZXN0cm95cyBvbGQgYnJ1c2hlc1xuICBwYy5yZXNpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgLy8gc2VsZWN0aW9uIHNpemVcbiAgICBwYy5zZWxlY3Rpb25cbiAgICAgIC5zZWxlY3QoJ3N2ZycpXG4gICAgICAuYXR0cignd2lkdGgnLCBfXy53aWR0aClcbiAgICAgIC5hdHRyKCdoZWlnaHQnLCBfXy5oZWlnaHQpO1xuICAgIHBjLnN2Zy5hdHRyKFxuICAgICAgJ3RyYW5zZm9ybScsXG4gICAgICAndHJhbnNsYXRlKCcgKyBfXy5tYXJnaW4ubGVmdCArICcsJyArIF9fLm1hcmdpbi50b3AgKyAnKScsXG4gICAgKTtcblxuICAgIC8vIEZJWE1FOiB0aGUgY3VycmVudCBicnVzaCBzdGF0ZSBzaG91bGQgcGFzcyB0aHJvdWdoXG4gICAgaWYgKGZsYWdzLmJydXNoYWJsZSkgcGMuYnJ1c2hSZXNldCgpO1xuXG4gICAgLy8gc2NhbGVzXG4gICAgcGMuYXV0b3NjYWxlKCk7XG5cbiAgICAvLyBheGVzLCBkZXN0cm95cyBvbGQgYnJ1c2hlcy5cbiAgICBpZiAoZykgcGMuY3JlYXRlQXhlcygpO1xuICAgIGlmIChmbGFncy5icnVzaGFibGUpIHBjLmJydXNoYWJsZSgpO1xuICAgIGlmIChmbGFncy5yZW9yZGVyYWJsZSkgcGMucmVvcmRlcmFibGUoKTtcblxuICAgIGV2ZW50cy5yZXNpemUuY2FsbCh0aGlzLCB7XG4gICAgICB3aWR0aDogX18ud2lkdGgsXG4gICAgICBoZWlnaHQ6IF9fLmhlaWdodCxcbiAgICAgIG1hcmdpbjogX18ubWFyZ2luLFxuICAgIH0pO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8vIGhpZ2hsaWdodCBhbiBhcnJheSBvZiBkYXRhXG4gIHBjLmhpZ2hsaWdodCA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBfXy5oaWdobGlnaHRlZDtcbiAgICB9XG5cbiAgICBfXy5oaWdobGlnaHRlZCA9IGRhdGE7XG4gICAgcGMuY2xlYXIoJ2hpZ2hsaWdodCcpO1xuICAgIGQzLnNlbGVjdEFsbChbY2FudmFzLmZvcmVncm91bmQsIGNhbnZhcy5icnVzaGVkXSkuY2xhc3NlZCgnZmFkZWQnLCB0cnVlKTtcbiAgICBkYXRhLmZvckVhY2gocGF0aF9oaWdobGlnaHQpO1xuICAgIGV2ZW50cy5oaWdobGlnaHQuY2FsbCh0aGlzLCBkYXRhKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvLyBjbGVhciBoaWdobGlnaHRpbmdcbiAgcGMudW5oaWdobGlnaHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgX18uaGlnaGxpZ2h0ZWQgPSBbXTtcbiAgICBwYy5jbGVhcignaGlnaGxpZ2h0Jyk7XG4gICAgZDMuc2VsZWN0QWxsKFtjYW52YXMuZm9yZWdyb3VuZCwgY2FudmFzLmJydXNoZWRdKS5jbGFzc2VkKCdmYWRlZCcsIGZhbHNlKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvLyBjYWxjdWxhdGUgMmQgaW50ZXJzZWN0aW9uIG9mIGxpbmUgYS0+YiB3aXRoIGxpbmUgYy0+ZFxuICAvLyBwb2ludHMgYXJlIG9iamVjdHMgd2l0aCB4IGFuZCB5IHByb3BlcnRpZXNcbiAgcGMuaW50ZXJzZWN0aW9uID0gZnVuY3Rpb24gKGEsIGIsIGMsIGQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgeDpcbiAgICAgICAgKChhLnggKiBiLnkgLSBhLnkgKiBiLngpICogKGMueCAtIGQueCkgLVxuICAgICAgICAgIChhLnggLSBiLngpICogKGMueCAqIGQueSAtIGMueSAqIGQueCkpIC9cbiAgICAgICAgKChhLnggLSBiLngpICogKGMueSAtIGQueSkgLSAoYS55IC0gYi55KSAqIChjLnggLSBkLngpKSxcbiAgICAgIHk6XG4gICAgICAgICgoYS54ICogYi55IC0gYS55ICogYi54KSAqIChjLnkgLSBkLnkpIC1cbiAgICAgICAgICAoYS55IC0gYi55KSAqIChjLnggKiBkLnkgLSBjLnkgKiBkLngpKSAvXG4gICAgICAgICgoYS54IC0gYi54KSAqIChjLnkgLSBkLnkpIC0gKGEueSAtIGIueSkgKiAoYy54IC0gZC54KSksXG4gICAgfTtcbiAgfTtcblxuICBmdW5jdGlvbiBwb3NpdGlvbihkKSB7XG4gICAgdmFyIHYgPSBkcmFnZ2luZ1tkXTtcbiAgICByZXR1cm4gdiA9PSBudWxsID8geHNjYWxlKGQpIDogdjtcbiAgfVxuICBwYy52ZXJzaW9uID0gJzAuNy4wJztcbiAgLy8gdGhpcyBkZXNjcmlwdGl2ZSB0ZXh0IHNob3VsZCBsaXZlIHdpdGggb3RoZXIgaW50cm9zcGVjdGl2ZSBtZXRob2RzXG4gIHBjLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAoXG4gICAgICAnUGFyYWxsZWwgQ29vcmRpbmF0ZXM6ICcgK1xuICAgICAgX18uZGltZW5zaW9ucy5sZW5ndGggK1xuICAgICAgJyBkaW1lbnNpb25zICgnICtcbiAgICAgIGQzLmtleXMoX18uZGF0YVswXSkubGVuZ3RoICtcbiAgICAgICcgdG90YWwpICwgJyArXG4gICAgICBfXy5kYXRhLmxlbmd0aCArXG4gICAgICAnIHJvd3MnXG4gICAgKTtcbiAgfTtcblxuICByZXR1cm4gcGM7XG59XG5cbmQzLnJlbmRlclF1ZXVlID0gZnVuY3Rpb24gKGZ1bmMpIHtcbiAgdmFyIF9xdWV1ZSA9IFtdLCAvLyBkYXRhIHRvIGJlIHJlbmRlcmVkXG4gICAgX3JhdGUgPSAxMCwgLy8gbnVtYmVyIG9mIGNhbGxzIHBlciBmcmFtZVxuICAgIF9jbGVhciA9IGZ1bmN0aW9uICgpIHt9LCAvLyBjbGVhcmluZyBmdW5jdGlvblxuICAgIF9pID0gMDsgLy8gY3VycmVudCBpdGVyYXRpb25cblxuICB2YXIgcnEgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgIGlmIChkYXRhKSBycS5kYXRhKGRhdGEpO1xuICAgIHJxLmludmFsaWRhdGUoKTtcbiAgICBfY2xlYXIoKTtcbiAgICBycS5yZW5kZXIoKTtcbiAgfTtcblxuICBycS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgX2kgPSAwO1xuICAgIHZhciB2YWxpZCA9IHRydWU7XG4gICAgcnEuaW52YWxpZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhbGlkID0gZmFsc2U7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGRvRnJhbWUoKSB7XG4gICAgICBpZiAoIXZhbGlkKSByZXR1cm4gdHJ1ZTtcbiAgICAgIGlmIChfaSA+IF9xdWV1ZS5sZW5ndGgpIHJldHVybiB0cnVlO1xuXG4gICAgICAvLyBUeXBpY2FsIGQzIGJlaGF2aW9yIGlzIHRvIHBhc3MgYSBkYXRhIGl0ZW0gKmFuZCogaXRzIGluZGV4LiBBcyB0aGVcbiAgICAgIC8vIHJlbmRlciBxdWV1ZSBzcGxpdHMgdGhlIG9yaWdpbmFsIGRhdGEgc2V0LCB3ZSdsbCBoYXZlIHRvIGJlIHNsaWdodGx5XG4gICAgICAvLyBtb3JlIGNhcmVmdWxsIGFib3V0IHBhc3NpbmcgdGhlIGNvcnJlY3QgaW5kZXggd2l0aCB0aGUgZGF0YSBpdGVtLlxuICAgICAgdmFyIGVuZCA9IE1hdGgubWluKF9pICsgX3JhdGUsIF9xdWV1ZS5sZW5ndGgpO1xuICAgICAgZm9yICh2YXIgaSA9IF9pOyBpIDwgZW5kOyBpICs9IDEpIHtcbiAgICAgICAgZnVuYyhfcXVldWVbaV0sIGkpO1xuICAgICAgfVxuICAgICAgX2kgKz0gX3JhdGU7XG4gICAgfVxuXG4gICAgZDMudGltZXIoZG9GcmFtZSk7XG4gIH07XG5cbiAgcnEuZGF0YSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgcnEuaW52YWxpZGF0ZSgpO1xuICAgIF9xdWV1ZSA9IGRhdGEuc2xpY2UoMCk7XG4gICAgcmV0dXJuIHJxO1xuICB9O1xuXG4gIHJxLnJhdGUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBfcmF0ZTtcbiAgICBfcmF0ZSA9IHZhbHVlO1xuICAgIHJldHVybiBycTtcbiAgfTtcblxuICBycS5yZW1haW5pbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9xdWV1ZS5sZW5ndGggLSBfaTtcbiAgfTtcblxuICAvLyBjbGVhciB0aGUgY2FudmFzXG4gIHJxLmNsZWFyID0gZnVuY3Rpb24gKGZ1bmMpIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIF9jbGVhcigpO1xuICAgICAgcmV0dXJuIHJxO1xuICAgIH1cbiAgICBfY2xlYXIgPSBmdW5jO1xuICAgIHJldHVybiBycTtcbiAgfTtcblxuICBycS5pbnZhbGlkYXRlID0gZnVuY3Rpb24gKCkge307XG5cbiAgcmV0dXJuIHJxO1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./plugins/legacy-plugin-chart-parallel-coordinates/src/vendor/parcoords/d3.parcoords.js\n");

/***/ }),

/***/ "./plugins/legacy-plugin-chart-parallel-coordinates/src/vendor/parcoords/divgrid.js":
/*!******************************************************************************************!*\
  !*** ./plugins/legacy-plugin-chart-parallel-coordinates/src/vendor/parcoords/divgrid.js ***!
  \******************************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* module decorator */ module = __webpack_require__.hmd(module);\n(function () {var enterModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.enterModule : undefined;enterModule && enterModule(module);})();var __signature__ = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default.signature : function (a) {return a;};const _default =\n\n\nfunction (config) {\n  var columns = [];\n\n  var dg = function (selection) {\n    if (columns.length == 0) columns = d3.keys(selection.data()[0][0]);\n\n    // header\n    selection.\n    selectAll('.header').\n    data([true]).\n    enter().\n    append('div').\n    attr('class', 'header');\n\n    var header = selection.select('.header').selectAll('.cell').data(columns);\n\n    header.\n    enter().\n    append('div').\n    attr('class', function (d, i) {\n      return 'col-' + i;\n    }).\n    classed('cell', true);\n\n    selection.selectAll('.header .cell').text(function (d) {\n      return d;\n    });\n\n    header.exit().remove();\n\n    // rows\n    var rows = selection.selectAll('.row').data(function (d) {\n      return d;\n    });\n\n    rows.enter().append('div').attr('class', 'row');\n\n    rows.exit().remove();\n\n    var cells = selection.\n    selectAll('.row').\n    selectAll('.cell').\n    data(function (d) {\n      return columns.map(function (col) {\n        return d[col];\n      });\n    });\n\n    // cells\n    cells.\n    enter().\n    append('div').\n    attr('class', function (d, i) {\n      return 'col-' + i;\n    }).\n    classed('cell', true);\n\n    cells.exit().remove();\n\n    selection.selectAll('.cell').text(function (d) {\n      return d;\n    });\n\n    return dg;\n  };\n\n  dg.columns = function (_) {\n    if (!arguments.length) return columns;\n    columns = _;\n    return this;\n  };\n\n  return dg;\n}; /* [LICENSE TBD] */ /* eslint-disable */ // from http://bl.ocks.org/3687826\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_default);;(function () {var reactHotLoader = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default : undefined;if (!reactHotLoader) {return;}reactHotLoader.register(_default, \"default\", \"/app/superset-frontend/plugins/legacy-plugin-chart-parallel-coordinates/src/vendor/parcoords/divgrid.js\");})();;(function () {var leaveModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.leaveModule : undefined;leaveModule && leaveModule(module);})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9wbHVnaW5zL2xlZ2FjeS1wbHVnaW4tY2hhcnQtcGFyYWxsZWwtY29vcmRpbmF0ZXMvc3JjL3ZlbmRvci9wYXJjb29yZHMvZGl2Z3JpZC5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBekVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc3VwZXJzZXQvLi9wbHVnaW5zL2xlZ2FjeS1wbHVnaW4tY2hhcnQtcGFyYWxsZWwtY29vcmRpbmF0ZXMvc3JjL3ZlbmRvci9wYXJjb29yZHMvZGl2Z3JpZC5qcz80MDQxIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIFtMSUNFTlNFIFRCRF0gKi9cbi8qIGVzbGludC1kaXNhYmxlICovXG4vLyBmcm9tIGh0dHA6Ly9ibC5vY2tzLm9yZy8zNjg3ODI2XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiAoY29uZmlnKSB7XG4gIHZhciBjb2x1bW5zID0gW107XG5cbiAgdmFyIGRnID0gZnVuY3Rpb24gKHNlbGVjdGlvbikge1xuICAgIGlmIChjb2x1bW5zLmxlbmd0aCA9PSAwKSBjb2x1bW5zID0gZDMua2V5cyhzZWxlY3Rpb24uZGF0YSgpWzBdWzBdKTtcblxuICAgIC8vIGhlYWRlclxuICAgIHNlbGVjdGlvblxuICAgICAgLnNlbGVjdEFsbCgnLmhlYWRlcicpXG4gICAgICAuZGF0YShbdHJ1ZV0pXG4gICAgICAuZW50ZXIoKVxuICAgICAgLmFwcGVuZCgnZGl2JylcbiAgICAgIC5hdHRyKCdjbGFzcycsICdoZWFkZXInKTtcblxuICAgIHZhciBoZWFkZXIgPSBzZWxlY3Rpb24uc2VsZWN0KCcuaGVhZGVyJykuc2VsZWN0QWxsKCcuY2VsbCcpLmRhdGEoY29sdW1ucyk7XG5cbiAgICBoZWFkZXJcbiAgICAgIC5lbnRlcigpXG4gICAgICAuYXBwZW5kKCdkaXYnKVxuICAgICAgLmF0dHIoJ2NsYXNzJywgZnVuY3Rpb24gKGQsIGkpIHtcbiAgICAgICAgcmV0dXJuICdjb2wtJyArIGk7XG4gICAgICB9KVxuICAgICAgLmNsYXNzZWQoJ2NlbGwnLCB0cnVlKTtcblxuICAgIHNlbGVjdGlvbi5zZWxlY3RBbGwoJy5oZWFkZXIgLmNlbGwnKS50ZXh0KGZ1bmN0aW9uIChkKSB7XG4gICAgICByZXR1cm4gZDtcbiAgICB9KTtcblxuICAgIGhlYWRlci5leGl0KCkucmVtb3ZlKCk7XG5cbiAgICAvLyByb3dzXG4gICAgdmFyIHJvd3MgPSBzZWxlY3Rpb24uc2VsZWN0QWxsKCcucm93JykuZGF0YShmdW5jdGlvbiAoZCkge1xuICAgICAgcmV0dXJuIGQ7XG4gICAgfSk7XG5cbiAgICByb3dzLmVudGVyKCkuYXBwZW5kKCdkaXYnKS5hdHRyKCdjbGFzcycsICdyb3cnKTtcblxuICAgIHJvd3MuZXhpdCgpLnJlbW92ZSgpO1xuXG4gICAgdmFyIGNlbGxzID0gc2VsZWN0aW9uXG4gICAgICAuc2VsZWN0QWxsKCcucm93JylcbiAgICAgIC5zZWxlY3RBbGwoJy5jZWxsJylcbiAgICAgIC5kYXRhKGZ1bmN0aW9uIChkKSB7XG4gICAgICAgIHJldHVybiBjb2x1bW5zLm1hcChmdW5jdGlvbiAoY29sKSB7XG4gICAgICAgICAgcmV0dXJuIGRbY29sXTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcblxuICAgIC8vIGNlbGxzXG4gICAgY2VsbHNcbiAgICAgIC5lbnRlcigpXG4gICAgICAuYXBwZW5kKCdkaXYnKVxuICAgICAgLmF0dHIoJ2NsYXNzJywgZnVuY3Rpb24gKGQsIGkpIHtcbiAgICAgICAgcmV0dXJuICdjb2wtJyArIGk7XG4gICAgICB9KVxuICAgICAgLmNsYXNzZWQoJ2NlbGwnLCB0cnVlKTtcblxuICAgIGNlbGxzLmV4aXQoKS5yZW1vdmUoKTtcblxuICAgIHNlbGVjdGlvbi5zZWxlY3RBbGwoJy5jZWxsJykudGV4dChmdW5jdGlvbiAoZCkge1xuICAgICAgcmV0dXJuIGQ7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gZGc7XG4gIH07XG5cbiAgZGcuY29sdW1ucyA9IGZ1bmN0aW9uIChfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gY29sdW1ucztcbiAgICBjb2x1bW5zID0gXztcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICByZXR1cm4gZGc7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./plugins/legacy-plugin-chart-parallel-coordinates/src/vendor/parcoords/divgrid.js\n");

/***/ }),

/***/ "./node_modules/core-js/internals/define-built-in-accessor.js":
/*!********************************************************************!*\
  !*** ./node_modules/core-js/internals/define-built-in-accessor.js ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var makeBuiltIn = __webpack_require__(/*! ../internals/make-built-in */ \"./node_modules/core-js/internals/make-built-in.js\");\nvar defineProperty = __webpack_require__(/*! ../internals/object-define-property */ \"./node_modules/core-js/internals/object-define-property.js\");\n\nmodule.exports = function (target, name, descriptor) {\n  if (descriptor.get) makeBuiltIn(descriptor.get, name, { getter: true });\n  if (descriptor.set) makeBuiltIn(descriptor.set, name, { setter: true });\n  return defineProperty.f(target, name, descriptor);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZGVmaW5lLWJ1aWx0LWluLWFjY2Vzc29yLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zdXBlcnNldC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9kZWZpbmUtYnVpbHQtaW4tYWNjZXNzb3IuanM/ZWRkMCJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgbWFrZUJ1aWx0SW4gPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvbWFrZS1idWlsdC1pbicpO1xudmFyIGRlZmluZVByb3BlcnR5ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1kZWZpbmUtcHJvcGVydHknKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAodGFyZ2V0LCBuYW1lLCBkZXNjcmlwdG9yKSB7XG4gIGlmIChkZXNjcmlwdG9yLmdldCkgbWFrZUJ1aWx0SW4oZGVzY3JpcHRvci5nZXQsIG5hbWUsIHsgZ2V0dGVyOiB0cnVlIH0pO1xuICBpZiAoZGVzY3JpcHRvci5zZXQpIG1ha2VCdWlsdEluKGRlc2NyaXB0b3Iuc2V0LCBuYW1lLCB7IHNldHRlcjogdHJ1ZSB9KTtcbiAgcmV0dXJuIGRlZmluZVByb3BlcnR5LmYodGFyZ2V0LCBuYW1lLCBkZXNjcmlwdG9yKTtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/core-js/internals/define-built-in-accessor.js\n");

/***/ }),

/***/ "./node_modules/core-js/internals/regexp-flags.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/internals/regexp-flags.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nvar anObject = __webpack_require__(/*! ../internals/an-object */ \"./node_modules/core-js/internals/an-object.js\");\n\n// `RegExp.prototype.flags` getter implementation\n// https://tc39.es/ecma262/#sec-get-regexp.prototype.flags\nmodule.exports = function () {\n  var that = anObject(this);\n  var result = '';\n  if (that.hasIndices) result += 'd';\n  if (that.global) result += 'g';\n  if (that.ignoreCase) result += 'i';\n  if (that.multiline) result += 'm';\n  if (that.dotAll) result += 's';\n  if (that.unicode) result += 'u';\n  if (that.unicodeSets) result += 'v';\n  if (that.sticky) result += 'y';\n  return result;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvcmVnZXhwLWZsYWdzLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3N1cGVyc2V0Ly4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3JlZ2V4cC1mbGFncy5qcz9hZDZkIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hbi1vYmplY3QnKTtcblxuLy8gYFJlZ0V4cC5wcm90b3R5cGUuZmxhZ3NgIGdldHRlciBpbXBsZW1lbnRhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1nZXQtcmVnZXhwLnByb3RvdHlwZS5mbGFnc1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciB0aGF0ID0gYW5PYmplY3QodGhpcyk7XG4gIHZhciByZXN1bHQgPSAnJztcbiAgaWYgKHRoYXQuaGFzSW5kaWNlcykgcmVzdWx0ICs9ICdkJztcbiAgaWYgKHRoYXQuZ2xvYmFsKSByZXN1bHQgKz0gJ2cnO1xuICBpZiAodGhhdC5pZ25vcmVDYXNlKSByZXN1bHQgKz0gJ2knO1xuICBpZiAodGhhdC5tdWx0aWxpbmUpIHJlc3VsdCArPSAnbSc7XG4gIGlmICh0aGF0LmRvdEFsbCkgcmVzdWx0ICs9ICdzJztcbiAgaWYgKHRoYXQudW5pY29kZSkgcmVzdWx0ICs9ICd1JztcbiAgaWYgKHRoYXQudW5pY29kZVNldHMpIHJlc3VsdCArPSAndic7XG4gIGlmICh0aGF0LnN0aWNreSkgcmVzdWx0ICs9ICd5JztcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/core-js/internals/regexp-flags.js\n");

/***/ }),

/***/ "./node_modules/core-js/modules/es.regexp.flags.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/modules/es.regexp.flags.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

eval("var global = __webpack_require__(/*! ../internals/global */ \"./node_modules/core-js/internals/global.js\");\nvar DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ \"./node_modules/core-js/internals/descriptors.js\");\nvar defineBuiltInAccessor = __webpack_require__(/*! ../internals/define-built-in-accessor */ \"./node_modules/core-js/internals/define-built-in-accessor.js\");\nvar regExpFlags = __webpack_require__(/*! ../internals/regexp-flags */ \"./node_modules/core-js/internals/regexp-flags.js\");\nvar fails = __webpack_require__(/*! ../internals/fails */ \"./node_modules/core-js/internals/fails.js\");\n\n// babel-minify and Closure Compiler transpiles RegExp('.', 'd') -> /./d and it causes SyntaxError\nvar RegExp = global.RegExp;\nvar RegExpPrototype = RegExp.prototype;\n\nvar FORCED = DESCRIPTORS && fails(function () {\n  var INDICES_SUPPORT = true;\n  try {\n    RegExp('.', 'd');\n  } catch (error) {\n    INDICES_SUPPORT = false;\n  }\n\n  var O = {};\n  // modern V8 bug\n  var calls = '';\n  var expected = INDICES_SUPPORT ? 'dgimsy' : 'gimsy';\n\n  var addGetter = function (key, chr) {\n    // eslint-disable-next-line es-x/no-object-defineproperty -- safe\n    Object.defineProperty(O, key, { get: function () {\n      calls += chr;\n      return true;\n    } });\n  };\n\n  var pairs = {\n    dotAll: 's',\n    global: 'g',\n    ignoreCase: 'i',\n    multiline: 'm',\n    sticky: 'y'\n  };\n\n  if (INDICES_SUPPORT) pairs.hasIndices = 'd';\n\n  for (var key in pairs) addGetter(key, pairs[key]);\n\n  // eslint-disable-next-line es-x/no-object-getownpropertydescriptor -- safe\n  var result = Object.getOwnPropertyDescriptor(RegExpPrototype, 'flags').get.call(O);\n\n  return result !== expected || calls !== expected;\n});\n\n// `RegExp.prototype.flags` getter\n// https://tc39.es/ecma262/#sec-get-regexp.prototype.flags\nif (FORCED) defineBuiltInAccessor(RegExpPrototype, 'flags', {\n  configurable: true,\n  get: regExpFlags\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLnJlZ2V4cC5mbGFncy5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3N1cGVyc2V0Ly4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5yZWdleHAuZmxhZ3MuanM/NTM3NyJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2dsb2JhbCcpO1xudmFyIERFU0NSSVBUT1JTID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Rlc2NyaXB0b3JzJyk7XG52YXIgZGVmaW5lQnVpbHRJbkFjY2Vzc29yID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2RlZmluZS1idWlsdC1pbi1hY2Nlc3NvcicpO1xudmFyIHJlZ0V4cEZsYWdzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3JlZ2V4cC1mbGFncycpO1xudmFyIGZhaWxzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2ZhaWxzJyk7XG5cbi8vIGJhYmVsLW1pbmlmeSBhbmQgQ2xvc3VyZSBDb21waWxlciB0cmFuc3BpbGVzIFJlZ0V4cCgnLicsICdkJykgLT4gLy4vZCBhbmQgaXQgY2F1c2VzIFN5bnRheEVycm9yXG52YXIgUmVnRXhwID0gZ2xvYmFsLlJlZ0V4cDtcbnZhciBSZWdFeHBQcm90b3R5cGUgPSBSZWdFeHAucHJvdG90eXBlO1xuXG52YXIgRk9SQ0VEID0gREVTQ1JJUFRPUlMgJiYgZmFpbHMoZnVuY3Rpb24gKCkge1xuICB2YXIgSU5ESUNFU19TVVBQT1JUID0gdHJ1ZTtcbiAgdHJ5IHtcbiAgICBSZWdFeHAoJy4nLCAnZCcpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIElORElDRVNfU1VQUE9SVCA9IGZhbHNlO1xuICB9XG5cbiAgdmFyIE8gPSB7fTtcbiAgLy8gbW9kZXJuIFY4IGJ1Z1xuICB2YXIgY2FsbHMgPSAnJztcbiAgdmFyIGV4cGVjdGVkID0gSU5ESUNFU19TVVBQT1JUID8gJ2RnaW1zeScgOiAnZ2ltc3knO1xuXG4gIHZhciBhZGRHZXR0ZXIgPSBmdW5jdGlvbiAoa2V5LCBjaHIpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMteC9uby1vYmplY3QtZGVmaW5lcHJvcGVydHkgLS0gc2FmZVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShPLCBrZXksIHsgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICBjYWxscyArPSBjaHI7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IH0pO1xuICB9O1xuXG4gIHZhciBwYWlycyA9IHtcbiAgICBkb3RBbGw6ICdzJyxcbiAgICBnbG9iYWw6ICdnJyxcbiAgICBpZ25vcmVDYXNlOiAnaScsXG4gICAgbXVsdGlsaW5lOiAnbScsXG4gICAgc3RpY2t5OiAneSdcbiAgfTtcblxuICBpZiAoSU5ESUNFU19TVVBQT1JUKSBwYWlycy5oYXNJbmRpY2VzID0gJ2QnO1xuXG4gIGZvciAodmFyIGtleSBpbiBwYWlycykgYWRkR2V0dGVyKGtleSwgcGFpcnNba2V5XSk7XG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzLXgvbm8tb2JqZWN0LWdldG93bnByb3BlcnR5ZGVzY3JpcHRvciAtLSBzYWZlXG4gIHZhciByZXN1bHQgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKFJlZ0V4cFByb3RvdHlwZSwgJ2ZsYWdzJykuZ2V0LmNhbGwoTyk7XG5cbiAgcmV0dXJuIHJlc3VsdCAhPT0gZXhwZWN0ZWQgfHwgY2FsbHMgIT09IGV4cGVjdGVkO1xufSk7XG5cbi8vIGBSZWdFeHAucHJvdG90eXBlLmZsYWdzYCBnZXR0ZXJcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtZ2V0LXJlZ2V4cC5wcm90b3R5cGUuZmxhZ3NcbmlmIChGT1JDRUQpIGRlZmluZUJ1aWx0SW5BY2Nlc3NvcihSZWdFeHBQcm90b3R5cGUsICdmbGFncycsIHtcbiAgY29uZmlndXJhYmxlOiB0cnVlLFxuICBnZXQ6IHJlZ0V4cEZsYWdzXG59KTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/core-js/modules/es.regexp.flags.js\n");

/***/ }),

/***/ "./packages/superset-ui-core/src/chart/components/reactify.tsx":
/*!*********************************************************************!*\
  !*** ./packages/superset-ui-core/src/chart/components/reactify.tsx ***!
  \*********************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ reactify)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var _emotion_react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @emotion/react */ \"./node_modules/@emotion/react/dist/emotion-react.browser.esm.js\");\n/* module decorator */ module = __webpack_require__.hmd(module);\n(function () {var enterModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.enterModule : undefined;enterModule && enterModule(module);})();var __signature__ = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default.signature : function (a) {return a;}; /*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nfunction reactify(renderFn, callbacks) {\n  class ReactifiedComponent extends react__WEBPACK_IMPORTED_MODULE_0__.Component {\n\n    constructor(props) {\n      super(props);this.container = void 0;\n      this.setContainerRef = this.setContainerRef.bind(this);\n    }\n    componentDidMount() {\n      this.execute();\n    }\n    componentDidUpdate() {\n      this.execute();\n    }\n    componentWillUnmount() {\n      this.container = undefined;\n      if (callbacks != null && callbacks.componentWillUnmount) {\n        callbacks.componentWillUnmount.bind(this)();\n      }\n    }\n    setContainerRef(ref) {\n      this.container = ref;\n    }\n    execute() {\n      if (this.container) {\n        renderFn(this.container, this.props);\n      }\n    }\n    render() {\n      const { id, className } = this.props;\n      return (0,_emotion_react__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"div\", { ref: this.setContainerRef, id: id, className: className });\n    } // @ts-ignore\n    __reactstandin__regenerateByEval(key, code) {// @ts-ignore\n      this[key] = eval(code);}}const ReactifiedClass = ReactifiedComponent;\n  if (renderFn.displayName) {\n    ReactifiedClass.displayName = renderFn.displayName;\n  }\n  // eslint-disable-next-line react/forbid-foreign-prop-types\n  if (renderFn.propTypes) {\n    ReactifiedClass.propTypes = {\n      ...ReactifiedClass.propTypes,\n      ...renderFn.propTypes };\n\n  }\n  if (renderFn.defaultProps) {\n    ReactifiedClass.defaultProps = renderFn.defaultProps;\n  }\n  return ReactifiedComponent;\n};(function () {var reactHotLoader = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default : undefined;if (!reactHotLoader) {return;}reactHotLoader.register(reactify, \"reactify\", \"/app/superset-frontend/packages/superset-ui-core/src/chart/components/reactify.tsx\");})();;(function () {var leaveModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.leaveModule : undefined;leaveModule && leaveModule(module);})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9wYWNrYWdlcy9zdXBlcnNldC11aS1jb3JlL3NyYy9jaGFydC9jb21wb25lbnRzL3JlYWN0aWZ5LnRzeC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBbUJBO0FBK0JBO0FBSUE7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFyQ0E7QUFBQTtBQTJDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3N1cGVyc2V0Ly4vcGFja2FnZXMvc3VwZXJzZXQtdWktY29yZS9zcmMvY2hhcnQvY29tcG9uZW50cy9yZWFjdGlmeS50c3g/ZWNhNCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuICogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4gKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuICogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuICogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuICogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4gKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4gKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuICogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiAqIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuICogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuICogdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcblxuLy8gVE9ETzogTm90ZSB0aGF0IGlkIGFuZCBjbGFzc05hbWUgY2FuIGNvbGxpZGUgYmV0d2VlbiBQcm9wcyBhbmQgUmVhY3RpZnlQcm9wc1xuLy8gbGVhZGluZyB0byAobGlrZWx5KSB1bmV4cGVjdGVkIGJlaGF2aW9ycy4gV2Ugc2hvdWxkIGVpdGhlciByZXF1aXJlIFByb3BzIHRvIG5vdFxuLy8gY29udGFpbiBhbiBpZC9jbGFzc05hbWUsIG9yIG5vdCBjb21iaW5lIHRoZW0gKHZpYSBpbnRlcnNlY3Rpb24pLCBpbnN0ZWFkIHByZWZlcnJpbmdcbi8vIHdyYXBwaW5nIChjb21wb3NpdGlvbikuIEFzIGFuIGV4YW1wbGU6XG4vLyBpbnRlcmZhY2UgTXlQcm9wcyB7XG4vLyAgIGlkOiBudW1iZXI7XG4vLyB9XG4vLyBmdW5jdGlvbiBteVJlbmRlcihjb250YWluZXI6IEhUTUxEaXZFbGVtZW50LCBwcm9wczogUmVhZG9ubHk8TXlQcm9wcz4pOiB2b2lkIHtcbi8vICAgcHJvcHMuaWQgLy8gdW51c2FibGU6IGlkIGlzIHN0cmluZyAmIG51bWJlclxuLy8gfVxuLy8gbmV3IChyZWFjdGlmeShteVJlbmRlcikpKHsgaWQ6IDUgfSk7IC8vIGVycm9yOiBpZCBoYXMgdG8gYmUgc3RyaW5nICYgbnVtYmVyXG5cbmV4cG9ydCB0eXBlIFJlYWN0aWZ5UHJvcHMgPSB7XG4gIGlkPzogc3RyaW5nO1xuICBjbGFzc05hbWU/OiBzdHJpbmc7XG59O1xuXG4vLyBUT0RPOiBhZGQgbW9yZSBSZWFjdCBsaWZlY3ljbGUgY2FsbGJhY2tzIGFzIG5lZWRlZFxuZXhwb3J0IHR5cGUgTGlmZUN5Y2xlQ2FsbGJhY2tzID0ge1xuICBjb21wb25lbnRXaWxsVW5tb3VudD86ICgpID0+IHZvaWQ7XG59O1xuXG5leHBvcnQgaW50ZXJmYWNlIFJlbmRlckZ1bmNUeXBlPFByb3BzPiB7XG4gIChjb250YWluZXI6IEhUTUxEaXZFbGVtZW50LCBwcm9wczogUmVhZG9ubHk8UHJvcHMgJiBSZWFjdGlmeVByb3BzPik6IHZvaWQ7XG4gIGRpc3BsYXlOYW1lPzogc3RyaW5nO1xuICBkZWZhdWx0UHJvcHM/OiBQYXJ0aWFsPFByb3BzICYgUmVhY3RpZnlQcm9wcz47XG4gIHByb3BUeXBlcz86IFJlYWN0LldlYWtWYWxpZGF0aW9uTWFwPFByb3BzICYgUmVhY3RpZnlQcm9wcz47XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHJlYWN0aWZ5PFByb3BzIGV4dGVuZHMgb2JqZWN0PihcbiAgcmVuZGVyRm46IFJlbmRlckZ1bmNUeXBlPFByb3BzPixcbiAgY2FsbGJhY2tzPzogTGlmZUN5Y2xlQ2FsbGJhY2tzLFxuKTogUmVhY3QuQ29tcG9uZW50Q2xhc3M8UHJvcHMgJiBSZWFjdGlmeVByb3BzPiB7XG4gIGNsYXNzIFJlYWN0aWZpZWRDb21wb25lbnQgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQ8UHJvcHMgJiBSZWFjdGlmeVByb3BzPiB7XG4gICAgY29udGFpbmVyPzogSFRNTERpdkVsZW1lbnQ7XG5cbiAgICBjb25zdHJ1Y3Rvcihwcm9wczogUHJvcHMgJiBSZWFjdGlmeVByb3BzKSB7XG4gICAgICBzdXBlcihwcm9wcyk7XG4gICAgICB0aGlzLnNldENvbnRhaW5lclJlZiA9IHRoaXMuc2V0Q29udGFpbmVyUmVmLmJpbmQodGhpcyk7XG4gICAgfVxuXG4gICAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgICB0aGlzLmV4ZWN1dGUoKTtcbiAgICB9XG5cbiAgICBjb21wb25lbnREaWRVcGRhdGUoKSB7XG4gICAgICB0aGlzLmV4ZWN1dGUoKTtcbiAgICB9XG5cbiAgICBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICAgIHRoaXMuY29udGFpbmVyID0gdW5kZWZpbmVkO1xuICAgICAgaWYgKGNhbGxiYWNrcz8uY29tcG9uZW50V2lsbFVubW91bnQpIHtcbiAgICAgICAgY2FsbGJhY2tzLmNvbXBvbmVudFdpbGxVbm1vdW50LmJpbmQodGhpcykoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzZXRDb250YWluZXJSZWYocmVmOiBIVE1MRGl2RWxlbWVudCkge1xuICAgICAgdGhpcy5jb250YWluZXIgPSByZWY7XG4gICAgfVxuXG4gICAgZXhlY3V0ZSgpIHtcbiAgICAgIGlmICh0aGlzLmNvbnRhaW5lcikge1xuICAgICAgICByZW5kZXJGbih0aGlzLmNvbnRhaW5lciwgdGhpcy5wcm9wcyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmVuZGVyKCkge1xuICAgICAgY29uc3QgeyBpZCwgY2xhc3NOYW1lIH0gPSB0aGlzLnByb3BzO1xuXG4gICAgICByZXR1cm4gPGRpdiByZWY9e3RoaXMuc2V0Q29udGFpbmVyUmVmfSBpZD17aWR9IGNsYXNzTmFtZT17Y2xhc3NOYW1lfSAvPjtcbiAgICB9XG4gIH1cblxuICBjb25zdCBSZWFjdGlmaWVkQ2xhc3M6IFJlYWN0LkNvbXBvbmVudENsYXNzPFByb3BzICYgUmVhY3RpZnlQcm9wcz4gPVxuICAgIFJlYWN0aWZpZWRDb21wb25lbnQ7XG5cbiAgaWYgKHJlbmRlckZuLmRpc3BsYXlOYW1lKSB7XG4gICAgUmVhY3RpZmllZENsYXNzLmRpc3BsYXlOYW1lID0gcmVuZGVyRm4uZGlzcGxheU5hbWU7XG4gIH1cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0L2ZvcmJpZC1mb3JlaWduLXByb3AtdHlwZXNcbiAgaWYgKHJlbmRlckZuLnByb3BUeXBlcykge1xuICAgIFJlYWN0aWZpZWRDbGFzcy5wcm9wVHlwZXMgPSB7XG4gICAgICAuLi5SZWFjdGlmaWVkQ2xhc3MucHJvcFR5cGVzLFxuICAgICAgLi4ucmVuZGVyRm4ucHJvcFR5cGVzLFxuICAgIH07XG4gIH1cbiAgaWYgKHJlbmRlckZuLmRlZmF1bHRQcm9wcykge1xuICAgIFJlYWN0aWZpZWRDbGFzcy5kZWZhdWx0UHJvcHMgPSByZW5kZXJGbi5kZWZhdWx0UHJvcHM7XG4gIH1cblxuICByZXR1cm4gUmVhY3RpZmllZENvbXBvbmVudDtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./packages/superset-ui-core/src/chart/components/reactify.tsx\n");

/***/ })

}]);